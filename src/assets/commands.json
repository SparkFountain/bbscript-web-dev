{
  "countgfxdrivers": {
    "name": "CountGfxDrivers",
    "description": {
      "en": "",
      "de": "Ermittelt die Anzahl der installierten Grafiktreiber im System. Einige Rechner k\u00f6nnen mehrere Grafikkarten haben - mit unterschiedlichen Treibern. Mit SetGfxDriver kann ein Treiber ausgew\u00e4hlt werden. "
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [],
    "return": {
      "name": "gfxDriverNumber",
      "description": { "en": "Number of graphic drivers", "de": "Anzahl der Grafiktreiber" }
    },
    "code": ""
  },
  "countgfxmodes": {
    "name": "CountGfxModes",
    "description": {
      "en": "",
      "de": "Ermittelt die Anzahl der unterst\u00fctzten Grafikmodi von der Grafikkarte. Benutze GfxModeWidth, GfxModeHeight und GfxModeDepth, um weitere Informationen \u00fcber einen Grafikmodus zu ermitteln. Mit Graphicskann man einen Grafikbildschirm \u00f6ffnen."
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [],
    "return": {
      "name": "gfxModeNumber",
      "description": { "en": "Number of supported graphics modes", "de": "Anzahl der unterst\u00fctzten Grafikmodi" }
    },
    "code": ""
  },
  "endgraphics": {
    "name": "EndGraphics",
    "description": {
      "en": "",
      "de": "Dieser Befehl \"schlie\u00dft\" ein Grafikfenster, das mit Graphics oder Graphics3D ge\u00f6ffnet wurde. In Blitz2D/Blitz3D wird ein Grafikfenster in Standardgr\u00f6\u00dfe wieder ge\u00f6ffnet, in BlitzPlus wird es dagegen richtig geschlossen. Beim Beenden kann BlitzBasic automatisch dieses Fenster schlie\u00dfen."
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "gfxdrivername": {
    "name": "GfxDriverName",
    "description": {
      "en": "",
      "de": "Ermittelt den Namen eines installierten Grafiktreibers im System. Einige Rechner k\u00f6nnen mehrere Grafikkarten haben - mit unterschiedlichen Treibern. Um die Anzahl der Treiber zu ermitteln, muss man CountGfxDriversbenutzen. Mit SetGfxDriver kann ein anderer Treiber ausgew\u00e4hlt werden."
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [{ "name": "gfxDriverIndex", "optional": 0 }],
    "return": {
      "name": "driverName",
      "description": { "en": "", "de": "Es wird der Name eines Treibers als String zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "gfxmodedepth": {
    "name": "GfxModeDepth",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die Farbtiefe eines Bildschirmmodus. Ein PC unterst\u00fctzt eine Vielzahl an Aufl\u00f6sungen. Mit CountGfxModes wird die Anzahl der m\u00f6glichen Aufl\u00f6sungen ermittelt."
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [{ "name": "screenMode", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "Farbtiefe in Bit." } },
    "code": ""
  },
  "gfxmodeexists": {
    "name": "GfxModeExists",
    "description": {
      "en": "",
      "de": "Diese Funktion \u00fcberpr\u00fcft, ob ein bestimmter Grafikmodus von der Grafikkarte unterst\u00fctzt wird. Dabei liefert es 0 (existiert nicht) oder 1 (existiert) zur\u00fcck."
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [
      { "name": "width", "optional": 0 },
      { "name": "height", "optional": 0 },
      { "name": "depth", "optional": 0 }
    ],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "0 = Dieser Modus wird nicht unterst\u00fctzt  1 = Dieser Modus wird unterst\u00fctzt"
      }
    },
    "code": ""
  },
  "gfxmodeformat": {
    "name": "GfxModeFormat",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die Farbtiefe eines Bildschirmmodus. Ein PC unterst\u00fctzt eine Vielzahl an Aufl\u00f6sungen. Mit CountGfxModes wird die Anzahl der m\u00f6glichen Aufl\u00f6sungen ermittelt.   Anders als GfxModeDepth gibt diese Funktion die Farbtiefe als Codenummer zur\u00fcck (n\u00fctzlich f\u00fcr Pixelbefehle). "
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [{ "name": "screenMode", "optional": 0 }],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "1\t=\t16 Bit RGB (5 Bit R, 6 Bit G, 5 Bit B)  2\t=\t16 Bit RGB (5 Bit R, 5 Bit G, 5 Bit B, 1 Bit ungenutzt)  3\t=\t24 Bit RGB (8 Bit R, 8 Bit G, 8 Bit B)  4\t=\t32 Bit RGB (8 Bit R, 8 Bit G, 8 Bit B, 8 Bit ungenutzt)"
      }
    },
    "code": ""
  },
  "gfxmodeheight": {
    "name": "GfxModeHeight",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die H\u00f6he eines Bildschirmmodus. Ein PC unterst\u00fctzt eine Vielzahl an Aufl\u00f6sungen. Mit CountGfxModes kann die Anzahl der m\u00f6glichen Aufl\u00f6sungen ermittelt werden."
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [{ "name": "screenMode", "optional": 0 }],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die H\u00f6he in Pixel zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "gfxmodewidth": {
    "name": "GfxModeWidth",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die Breite eines Bildschirmmodus. Ein PC unterst\u00fctzt eine Vielzahl an Aufl\u00f6sungen. Mit CountGfxModes kann die Anzahl der m\u00f6glichen Aufl\u00f6sungen ermittelt werden."
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [{ "name": "screenMode", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "Es wird die Breite in Pixel zur\u00fcckgeliefert." } },
    "code": ""
  },
  "graphics": {
    "name": "Graphics",
    "description": { "en": "", "de": "Initialisiert den Grafikmodus." },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [
      { "name": "width", "optional": 0 },
      { "name": "height", "optional": 0 },
      { "name": "colorDepth", "optional": 1 },
      { "name": "screenMode", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "graphicsbuffer": {
    "name": "GraphicsBuffer",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die Identit\u00e4t des aktuell gesetzten Buffers. Es wird ein Wert zur\u00fcckgeliefert, der mit BackBuffer, FrontBuffer oder ImageBuffer verglichen werden kann. So kann man erfahren welcher Buffer gerade ausgew\u00e4hlt ist."
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Wert, der die Identit\u00e4t des Buffers angibt." } },
    "code": ""
  },
  "graphicsdepth": {
    "name": "GraphicsDepth",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die aktuelle Farbtiefe. Wird bei Graphics der Wert f\u00fcr Farbtiefe nicht angegeben, so kann man \u00fcber diese Funktion die gesetzte Farbtiefe ermitteln. F\u00fcr sp\u00e4tere Grafikausgabe hat dieser Wert keine Bedeutung. Man kann h\u00f6chstens einen Hinweis ausgeben, dass die Farbtiefe zu gering ist."
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Farbtiefe in Bit." } },
    "code": ""
  },
  "graphicsformat": {
    "name": "GraphicsFormat",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die aktuelle Farbtiefe. Wird bei Graphics der Wert f\u00fcr Farbtiefe nicht angegeben, so kann man \u00fcber diese Funktion die gesetzte Farbtiefe ermitteln.   Anders als GraphicsDepth gibt diese Funktion die Farbtiefe als Codenummer zur\u00fcck (n\u00fctzlich f\u00fcr Pixelbefehle)."
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "1\t=\t16 Bit RGB (5 Bit R, 6 Bit G, 5 Bit B)  2\t=\t16 Bit RGB (5 Bit R, 5 Bit G, 5 Bit B, 1 Bit ungenutzt)  3\t=\t24 Bit RGB (8 Bit R, 8 Bit G, 8 Bit B)  4\t=\t32 Bit RGB (8 Bit R, 8 Bit G, 8 Bit B, 8 Bit ungenutzt)"
      }
    },
    "code": ""
  },
  "graphicsheight": {
    "name": "GraphicsHeight",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die H\u00f6he des Grafikfensters in Pixel. Die H\u00f6he wird mit dem Befehl Graphics eingestellt - und wer es einprogrammiert hat, wei\u00df auch die aktuelle Aufl\u00f6sung. Somit hat diese Funktion einen geringen Nutzen - h\u00f6chstens zur Pr\u00fcfung der korrekten Ausf\u00fchrung. "
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "H\u00f6he des Grafikfensters in Pixel" } },
    "code": ""
  },
  "graphicslost": {
    "name": "GraphicsLost",
    "description": {
      "en": "",
      "de": "Bei einigen Manipulationen (z.B. unter Windows das aktive Fenster wechseln oder die Aufl\u00f6sung \u00e4ndern) kann es vorkommen das Blitzbasic die Grafiken \"verliert\". Mit diesem Befehl kann man das Problem abfangen und beheben, indem man die Grafiken neu l\u00e4dt oder den Anwender auffordert das Programm neu zu starten."
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0 = kein Fehler  1 = Fehler, Grafiken sind nicht mehr im Speicher." }
    },
    "code": ""
  },
  "graphicswidth": {
    "name": "GraphicsWidth",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die Breite des Grafikfensters in Pixel. Die Breite wird mit dem Befehl Graphics eingestellt - und wer es einprogrammiert hat, wei\u00df auch die aktuelle Aufl\u00f6sung. Somit hat diese Funktion einen geringen Nutzen - h\u00f6chstens zur Pr\u00fcfung der korrekten Ausf\u00fchrung."
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Breite des Grafikfensters in Pixel." } },
    "code": ""
  },
  "setgfxdriver": {
    "name": "SetGfxDriver",
    "description": {
      "en": "",
      "de": "Mit diesem Befehl kann ein Grafiktreiber ausgew\u00e4hlt werden. Einige Rechner k\u00f6nnen mehrere Grafikkarten haben - mit unterschiedlichen Treibern. Mit CountGfxDrivers kann die Anzahl der Treiber ermittelt werden. "
    },
    "category": "graphics2d",
    "subCategory": "display",
    "params": [{ "name": "gfxDriverIndex", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "automidhandle": {
    "name": "AutoMidHandle",
    "description": {
      "en": "",
      "de": "Setzt den Bezugspunkt von Bildern in die Mitte des Bildes. Standardm\u00e4\u00dfig und wenn der Effekt abgeschaltet wird, befindet sich der Bezugspunkt von Bildern oben links."
    },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [{ "name": "enable", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "bufferdirty": {
    "name": "BufferDirty",
    "description": {
      "en": "",
      "de": "Bilder, auf denen mit Zeichenbefehlen wie z.B. Rect, Text oder WritePixel/WritePixelFast gezeichnet wurde, k\u00f6nnen mit BufferDirty als \"unsauber\" markiert werden. Dies teilt DirectX mit, dass der Buffer ver\u00e4ndert wurde und neu in den Grafikspeicher \u00fcbertragen werden muss. Unterl\u00e4sst man dies, passiert es sehr h\u00e4ufig, dass das Bild verloren geht, wenn dem Programm aus irgendeinem Grund der Grafikkartenzugriff entzogen wird (z.B. 'Alt-Tab' im Vollbildmodus, Minimieren des Spiels oder beim Sperren des Computers mit 'Win+L'). "
    },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [{ "name": "buffer", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "copyimage": {
    "name": "CopyImage",
    "description": { "en": "", "de": "Kopiert ein bereits vorhandenes Bild und erzeugt eine neue Referenz." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [{ "name": "image", "optional": 0 }],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird die Identit\u00e4t des neuen Bildes zur\u00fcckgeliefert. Sollte eine Null zur\u00fcckgeliefert werden, dann konnte das Bild nicht kopiert werden."
      }
    },
    "code": ""
  },
  "createimage": {
    "name": "CreateImage",
    "description": {
      "en": "",
      "de": "Erstellt ein leeres Bild mit einer bestimmten Aufl\u00f6sung und gibt die Referenz zur\u00fcck."
    },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "width", "optional": 0 },
      { "name": "height", "optional": 0 },
      { "name": "frames", "optional": 0 },
      { "name": "mode", "optional": 0 }
    ],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t des neuen Bildes. Wird nur eine Null zur\u00fcckgeliefert, dann konnte dieses Bild nicht erstellt werden."
      }
    },
    "code": ""
  },
  "drawblock": {
    "name": "DrawBlock",
    "description": { "en": "", "de": "Zeichnet ein Bild ohne Transparenzfarbe." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "frame", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "drawblockrect": {
    "name": "DrawBlockRect",
    "description": { "en": "", "de": "Zeichnet einen bestimmten Ausschnitt eines Bildes ohne Transparenzfarbe." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "left", "optional": 0 },
      { "name": "top", "optional": 0 },
      { "name": "width", "optional": 0 },
      { "name": "height", "optional": 0 },
      { "name": "frame", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "drawimage": {
    "name": "DrawImage",
    "description": {
      "en": "",
      "de": "Zeichnet ein Bild. Wenn das Bild eine Transparenzfarbe besitzt, werden Bereiche mit dieser Farbe nicht eingezeichnet."
    },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "frame", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "drawimagerect": {
    "name": "DrawImageRect",
    "description": {
      "en": "",
      "de": "Zeichnet einen bestimmten Ausschnitt eines Bildes. Wenn das Bild eine Transparenzfarbe besitzt, werden Bereiche mit dieser Farbe nicht eingezeichnet."
    },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "left", "optional": 0 },
      { "name": "top", "optional": 0 },
      { "name": "width", "optional": 0 },
      { "name": "height", "optional": 0 },
      { "name": "frame", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "freeimage": {
    "name": "FreeImage",
    "description": { "en": "", "de": "L\u00f6scht ein Bild aus dem Speicher." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [{ "name": "image", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "grabimage": {
    "name": "GrabImage",
    "description": {
      "en": "",
      "de": "Kopiert einen Ausschnitt des aktuellen Grafik-Kontextes und speichert ihn in der abgegeben Referenz."
    },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "frame", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "handleimage": {
    "name": "HandleImage",
    "description": { "en": "", "de": "Legt den Bezugspunkt eines Bildes fest." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "imagebuffer": {
    "name": "ImageBuffer",
    "description": { "en": "", "de": "Wechselt in den Grafik-Kontext eines bestimmten Bildes." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "frame", "optional": 1 }
    ],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Wert, der die Identit\u00e4t des Bild-Buffers f\u00fcr SetBuffer angibt" }
    },
    "code": ""
  },
  "imageheight": {
    "name": "ImageHeight",
    "description": { "en": "", "de": "Ermittelt die H\u00f6he eines Bildes." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [{ "name": "image", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "H\u00f6he des Bildes in Pixel" } },
    "code": ""
  },
  "imagerectcollide": {
    "name": "ImageRectCollide",
    "description": {
      "en": "",
      "de": "\u00dcberpr\u00fcft, ob ein Bild mit einem Rechteck kollidiert (pixelgenaue Abfrage)."
    },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "frame", "optional": 0 },
      { "name": "startX", "optional": 0 },
      { "name": "startY", "optional": 0 },
      { "name": "width", "optional": 0 },
      { "name": "height", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "0 = keine Kollision  1 = Kollision" } },
    "code": ""
  },
  "imagerectoverlap": {
    "name": "ImageRectOverlap",
    "description": {
      "en": "",
      "de": "\u00dcberpr\u00fcft, ob ein Bild mit einem Rechteck \u00fcberlappt (nicht pixelgenau)."
    },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "startX", "optional": 0 },
      { "name": "startY", "optional": 0 },
      { "name": "width", "optional": 0 },
      { "name": "height", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "0 = keine Kollision  1 = Kollision" } },
    "code": ""
  },
  "imagescollide": {
    "name": "ImagesCollide",
    "description": {
      "en": "",
      "de": "\u00dcberpr\u00fcft, ob zwei Bilder miteinander kollidieren (pixelgenaue Abfrage)."
    },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image1", "optional": 0 },
      { "name": "x1", "optional": 0 },
      { "name": "y1", "optional": 0 },
      { "name": "frame1", "optional": 0 },
      { "name": "image2", "optional": 0 },
      { "name": "x2", "optional": 0 },
      { "name": "y2", "optional": 0 },
      { "name": "frame2", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "0 = keine Kollision  1 = Kollision" } },
    "code": ""
  },
  "imagesoverlap": {
    "name": "ImagesOverlap",
    "description": { "en": "", "de": "\u00dcberpr\u00fcft, ob zwei Bilder sich \u00fcberlappen (nicht pixelgenau)." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image1", "optional": 0 },
      { "name": "x1", "optional": 0 },
      { "name": "y1", "optional": 0 },
      { "name": "image2", "optional": 0 },
      { "name": "x2", "optional": 0 },
      { "name": "y2", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "0 = keine Kollision  1 = Kollision" } },
    "code": ""
  },
  "imagewidth": {
    "name": "ImageWidth",
    "description": { "en": "", "de": "Ermittelt die Breite eines Bildes." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [{ "name": "image", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "Breite des Bildes in Pixel" } },
    "code": ""
  },
  "imagexhandle": {
    "name": "ImageXHandle",
    "description": { "en": "", "de": "Ermittelt die horizontale Verschiebung des Bezugspunktes eines Bildes." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [{ "name": "image", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "Verschiebung in X-Richtung" } },
    "code": ""
  },
  "imageyhandle": {
    "name": "ImageYHandle",
    "description": { "en": "", "de": "Ermittelt die vertikale Verschiebung des Bezugspunktes eines Bildes." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [{ "name": "image", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "Verschiebung in Y-Richtung" } },
    "code": ""
  },
  "loadanimimage": {
    "name": "LoadAnimImage",
    "description": { "en": "", "de": "L\u00e4dt ein animiertes Bild, das aus mehreren Einzelbildern besteht." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "file", "optional": 0 },
      { "name": "width", "optional": 0 },
      { "name": "height", "optional": 0 },
      { "name": "startFrame", "optional": 0 },
      { "name": "totalFrames", "optional": 0 }
    ],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t des geladenen Bildes. Wenn eine Null zur\u00fcckgeliefert wird, dann konnte die Grafikdatei nicht geladen werden."
      }
    },
    "code": ""
  },
  "loadimage": {
    "name": "LoadImage",
    "description": { "en": "", "de": "L\u00e4dt ein Bild." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [{ "name": "file", "optional": 0 }],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t des Bildes. Bei Null wurde die Datei nicht geladen/gefunden. "
      }
    },
    "code": ""
  },
  "maskimage": {
    "name": "MaskImage",
    "description": {
      "en": "",
      "de": "Setzt die Transparenzfarbe eines Bildes. Alle Bildpunkte mit dieser Farbe werden dann transparent (unsichtbar)."
    },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "red", "optional": 0 },
      { "name": "green", "optional": 0 },
      { "name": "blue", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "midhandle": {
    "name": "MidHandle",
    "description": { "en": "", "de": "Verschiebt den Bezugspunkt eines Bildes in die Bildmitte." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [{ "name": "image", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "rectsoverlap": {
    "name": "RectsOverlap",
    "description": { "en": "", "de": "Pr\u00fcft, ob zwei Rechtecke sich \u00fcberlappen." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "x1", "optional": 0 },
      { "name": "y1", "optional": 0 },
      { "name": "width1", "optional": 0 },
      { "name": "height1", "optional": 0 },
      { "name": "x2", "optional": 0 },
      { "name": "y2", "optional": 0 },
      { "name": "width2", "optional": 0 },
      { "name": "height2", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "0 = keine Kollision  1 = Kollision" } },
    "code": ""
  },
  "resizeimage": {
    "name": "ResizeImage",
    "description": { "en": "", "de": "\u00c4ndert die H\u00f6he und Breite eines Bildes." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "width", "optional": 0 },
      { "name": "height", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "rotateimage": {
    "name": "RotateImage",
    "description": { "en": "", "de": "Dreht das Bild an seinem Bezugspunkt um einen bestimmten Winkel." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "angle", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "saveimage": {
    "name": "SaveImage",
    "description": { "en": "", "de": "Speichert ein Bild ab." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "fileName", "optional": 0 },
      { "name": "frame", "optional": 1 }
    ],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0 = Bild konnte nicht abgespeichert werden  1 = Bild wurde abgespeichert" }
    },
    "code": ""
  },
  "scaleimage": {
    "name": "ScaleImage",
    "description": { "en": "", "de": "Skaliert ein Bild um einen bestimmten Faktor." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "zoomX", "optional": 0 },
      { "name": "zoomY", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "tformfilter": {
    "name": "TFormFilter",
    "description": {
      "en": "",
      "de": "Schaltet den bilinearen Filter ein bzw. aus. Je nach Einstellung werden Farbverl\u00e4ufe beim Skalieren oder Rotieren von Bildern weich oder hart berechnet."
    },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [{ "name": "enabled", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "tformimage": {
    "name": "TFormImage",
    "description": { "en": "", "de": "Dreht, skaliert, zerrt und spiegelt ein Bild gleichzeitig." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "scaleX", "optional": 0 },
      { "name": "dragY", "optional": 0 },
      { "name": "dragX", "optional": 0 },
      { "name": "scaleY", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "tileblock": {
    "name": "TileBlock",
    "description": { "en": "", "de": "Zeichnet ein Bild \u00fcber den gesamten Bildschirm (ohne Transparenzfarbe)." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "x", "optional": 1 },
      { "name": "y", "optional": 1 },
      { "name": "frame", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "tileimage": {
    "name": "TileImage",
    "description": { "en": "", "de": "Zeichnet ein Bild \u00fcber den gesamten Bildschirm (mit Transparenzfarbe)." },
    "category": "graphics2d",
    "subCategory": "images",
    "params": [
      { "name": "image", "optional": 0 },
      { "name": "x", "optional": 1 },
      { "name": "y", "optional": 1 },
      { "name": "frame", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "availvidmem": {
    "name": "AvailVidMem",
    "description": { "en": "", "de": "Ermittelt den freien Grafikspeicher." },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Gibt den freien Grafikspeicher in Byte zur\u00fcck" } },
    "code": ""
  },
  "backbuffer": {
    "name": "BackBuffer",
    "description": {
      "en": "",
      "de": "Liefert die Identit\u00e4t des Hintergrundbuffers, auf welchem Bilder vorgezeichnet werden."
    },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Wert, der die Identit\u00e4t angibt" } },
    "code": ""
  },
  "cls": {
    "name": "Cls",
    "description": { "en": "", "de": "L\u00f6scht den Inhalt des aktuellen Grafikbuffers." },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "clscolor": {
    "name": "ClsColor",
    "description": {
      "en": "",
      "de": "Legt die Hintergrundfarbe fest, die beim L\u00f6schen des Grafikbuffers eingezeichnet wird."
    },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [
      { "name": "red", "optional": 0 },
      { "name": "green", "optional": 0 },
      { "name": "blue", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "color": {
    "name": "Color",
    "description": { "en": "", "de": "Setzt die aktuelle Farbe f\u00fcr Zeichenbefehle." },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [
      { "name": "red", "optional": 0 },
      { "name": "green", "optional": 0 },
      { "name": "blue", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "copyrect": {
    "name": "CopyRect",
    "description": { "en": "", "de": "Kopiert einen Ausschnitt das aktuellen Grafikbuffers." },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [
      { "name": "sourceX", "optional": 0 },
      { "name": "sourceY", "optional": 0 },
      { "name": "width", "optional": 0 },
      { "name": "height", "optional": 0 },
      { "name": "targetX", "optional": 0 },
      { "name": "targetY", "optional": 0 },
      { "name": "sourceBuffer", "optional": 1 },
      { "name": "targetBuffer", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "flip": {
    "name": "Flip",
    "description": { "en": "", "de": "Tauscht den Inhalt des Front- und Backbuffers." },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [{ "name": "vSync", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "frontbuffer": {
    "name": "FrontBuffer",
    "description": {
      "en": "",
      "de": "Liefert die Identit\u00e4t des Vordergrundbuffers, auf welchem Bilder direkt eingezeichnet werden."
    },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Identit\u00e4t des Buffers" } },
    "code": ""
  },
  "line": {
    "name": "Line",
    "description": { "en": "", "de": "Zeichnet eine gerade Linie." },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [
      { "name": "startX", "optional": 0 },
      { "name": "startY", "optional": 0 },
      { "name": "endX", "optional": 0 },
      { "name": "endY", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "loadbuffer": {
    "name": "LoadBuffer",
    "description": { "en": "", "de": "L\u00e4dt ein Bild in einen bestimmten Grafikbuffer." },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [
      { "name": "buffer", "optional": 0 },
      { "name": "filePath", "optional": 0 }
    ],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0 - Fehler beim Laden aufgetreten  1 - Laden erfolgreich" }
    },
    "code": ""
  },
  "origin": {
    "name": "Origin",
    "description": {
      "en": "",
      "de": "Verschiebt den Ursprung des Koordinatensystems. Standardm\u00e4\u00dfig befindet sich der Punkt 0,0 ganz oben links."
    },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "oval": {
    "name": "Oval",
    "description": { "en": "", "de": "Zeichnet eine Ellipse." },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "width", "optional": 0 },
      { "name": "height", "optional": 0 },
      { "name": "filled", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "rect": {
    "name": "Rect",
    "description": { "en": "", "de": "Zeichnet ein Rechteck." },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "width", "optional": 0 },
      { "name": "height", "optional": 0 },
      { "name": "filled", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": "Graphics 640, 480\r\nSetBuffer BackBuffer()\r\nbox_x = -20\r\nbox_y = 100\r\nWhile Not KeyHit(1)\r\nCls\r\nRect box_x, box_y, 20, 20, 1\r\nFlip\r\nbox_x = box_x + 1\r\nIf box_x = 640 Then box_x = -20\r\nWend"
  },
  "savebuffer": {
    "name": "SaveBuffer",
    "description": { "en": "", "de": "Speichert den Inhalt eines Grafikbuffers in eine Datei." },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [
      { "name": "buffer", "optional": 0 },
      { "name": "filePath", "optional": 0 }
    ],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "0 - Bild konnte nicht gespeichert werden  1 - Bild wurde erfolgreich gespeichert"
      }
    },
    "code": ""
  },
  "scanline": {
    "name": "ScanLine",
    "description": {
      "en": "",
      "de": "Diese Funktion liefert die Zeile des Bildschirms, die gerade vom Monitor aktualisiert (also gezeichnet) wird. Normalerweise gibt es keine Anwendung f\u00fcr diesen Befehl.  Beachte: jeder Monitor hat andere Wiederholfrequenz."
    },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Zeile - Zeile des Bildschirms in Pixel" } },
    "code": ""
  },
  "setbuffer": {
    "name": "SetBuffer",
    "description": {
      "en": "",
      "de": "Der Befehl SetBuffer setzt den aktuellen Grafikbuffer. Alle Grafikbefehle, die danach ausgef\u00fchrt werden, erscheinen auf dem gesetzten Buffer. Nach dem Programmstart ist der gesetzte Buffer FrontBuffer. Dadurch erscheint die Grafik sofort auf dem Bildschirm. Wird BackBuffer verwendet, dann wird die Grafik erst im unsichtbaren Hintergrund berechnet und danach mit Flip sichtbar gemacht. Man kann aber auch ImageBufferverwenden und die Grafik in ein Bild einzeichnen."
    },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [{ "name": "buffer", "optional": 0 }],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t eines Buffers, das vor SetBuffer aktiv war." }
    },
    "code": ""
  },
  "totalvidmem": {
    "name": "TotalVidMem",
    "description": {
      "en": "",
      "de": "Ermittelt den zur Verf\u00fcgung stehenden Grafikspeicher in Byte. Beachte: Von der Gr\u00f6\u00dfe der Grafikspeichers wird noch die Gr\u00f6\u00dfe von FrontBuffer und BackBuffer abgezogen. Die ausgegebene Speichergr\u00f6\u00dfe kann danach problemlos belegt werden. Die Funktion AvailVidMem liefert dagegen die Gr\u00f6\u00dfe des freien Grafikspeichers zur\u00fcck.   Sollte diese Funktion sehr wenig Speicher anzeigen (weniger als zul\u00e4ssig oder \u00fcblich), so handelt es sich wahrscheinlich um einen alten Rechner mit wenig Grafikspeicher."
    },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Gr\u00f6\u00dfe des Grafikspeichers in Byte" } },
    "code": ""
  },
  "viewport": {
    "name": "Viewport",
    "description": {
      "en": "",
      "de": "Mit Viewport kann man einen Bereich auf dem Bildschirm eingrenzen in dem Grafiken ausgegeben werden sollen. Die Grafik erscheint nur innerhalb dieses Rechtecks. Sollte eine Grafik \u00fcber den Viewport-Bereich hinausgehen, so wird die einfach abgeschnitten. Profis nennen das auch 'windowing', 'portaling' oder 'clipping'. Der Grafikbereich au\u00dferhalb des Viewport-Bereichs wird dagegen nicht ge\u00e4ndert. Dieser Befehl wirkt sich auf den aktuell zum Zeichnen verwendeten Buffer aus. Um Viewport zu deaktivieren, muss man einfach den kompletten Buffer markieren.   F\u00fcr diesen Befehl gibt es Tausende von Anwendungsm\u00f6glichkeiten. So kann man z.B. Einen Splitscreen f\u00fcr zwei Spieler bauen, oder auch ein Scrollbereich ist somit realisierbar. Eine weitere Anwendungsm\u00f6glichkeit ist das Sch\u00fctzen eines Grafikbereichs. Somit kann man keine Bildschirmbereiche \"aus versehen\" \u00fcbermalen."
    },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "width", "optional": 0 },
      { "name": "height", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "vwait": {
    "name": "VWait",
    "description": {
      "en": "",
      "de": "Diese Anweisung wartet solange, bis sich das komplette Bild auf dem Bildschirm aufgebaut hat. Ein Monitor zeichnet das Bild Pixel f\u00fcr Pixel von oben nach unten. Wurde die Letzte Zeile gezeichnet, dann wird die Programmausf\u00fchrung fortgesetzt. Zus\u00e4tzlich kann man die Anzahl der Frames angeben, die das Programm abwarten soll."
    },
    "category": "graphics2d",
    "subCategory": "graphics",
    "params": [{ "name": "frames", "optional": 1 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "colorblue": {
    "name": "ColorBlue",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt den Blau-Anteil der aktuellen Zeichenfarbe, die mit dem Befehl Color eingestellt wurde."
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Blau-Anteil der aktuellen Farbe (0-255 m\u00f6glich)" }
    },
    "code": ""
  },
  "colorgreen": {
    "name": "ColorGreen",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt den Gr\u00fcn-Anteil der aktuellen Zeichenfarbe, die mit dem Befehl Color eingestellt wurde."
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Gr\u00fcn-Anteil der aktuellen Farbe (0-255 m\u00f6glich)" }
    },
    "code": ""
  },
  "colorred": {
    "name": "ColorRed",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt den Rot-Anteil der aktuellen Zeichenfarbe, die mit dem Befehl Color eingestellt wurde."
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Rot-Anteil der aktuellen Farbe (0-255 m\u00f6glich)" }
    },
    "code": ""
  },
  "copypixel": {
    "name": "CopyPixel",
    "description": {
      "en": "",
      "de": "Diese Anweisung kopiert einen Pixel von einer Stelle (und Buffer) zur anderen. Es ist nicht notwendig den Befehl LockBuffer zu benutzen, doch damit l\u00e4uft das Programm etwas schneller. Um noch mehr Geschwindigkeit zu entlocken, ist der Befehl CopyPixelFast besser. "
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [
      { "name": "sourceX", "optional": 0 },
      { "name": "sourceY", "optional": 0 },
      { "name": "sourceBuffer", "optional": 0 },
      { "name": "targetX", "optional": 0 },
      { "name": "sourceY", "optional": 0 },
      { "name": "targetBuffer", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "copypixelfast": {
    "name": "CopyPixelFast",
    "description": {
      "en": "",
      "de": "Diese Anweisung kopiert einen Pixel von einer Stelle (und Buffer) zur anderen. Es ist schneller als CopyPixel. "
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [
      { "name": "sourceX", "optional": 0 },
      { "name": "sourceY", "optional": 0 },
      { "name": "sourceBuffer", "optional": 0 },
      { "name": "targetX", "optional": 0 },
      { "name": "sourceY", "optional": 0 },
      { "name": "targetBuffer", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "getcolor": {
    "name": "GetColor",
    "description": {
      "en": "",
      "de": "Dieser Befehl \u00e4ndert die aktuelle Zeichenfarbe, indem die Farbe von einem Pixel auf dem Bildschirm ausgew\u00e4hlt wird. Es funktioniert prinzipiell genau wie die Pipette-Funktion in Grafikprogrammen."
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "Aktuelle Zeichenfarbe wird ge\u00e4ndert" } },
    "code": ""
  },
  "lockbuffer": {
    "name": "LockBuffer",
    "description": {
      "en": "",
      "de": "Dieser Befehl sperrt einen Buffer f\u00fcr eine sehr schnelle Pixelverarbeitung. Dadurch wird die Fehlerpr\u00fcfung deaktiviert. LockBuffer wurde speziell f\u00fcr CopyPixelFast, ReadPixelFast und WritePixelFast geschrieben, um eine noch h\u00f6here Geschwindigkeit zu erzielen. Mit UnlockBuffer wird diese Funktion dann wieder deaktiviert."
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [{ "name": "buffer", "optional": 1 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "lockedformat": {
    "name": "LockedFormat",
    "description": {
      "en": "",
      "de": "Die Funktion LockedFormat ermittelt Farbtiefe eines Grafikbuffers. Die Farbtiefe wird als Code zur\u00fcckgeliefert. Dies ist dann n\u00fctzlich, wenn Pixel direkt ins Video-RAM mit Poke/Peek-Befehlen gezeichnet/gelesen werden sollen und nicht mir WritePixel/ReadPixel. Dazu ist eine vorherige Sperrung des Grafikbuffers mit LockBuffer notwendig.   Direktes Zeichnen mit Poke ist deutlich schneller (bis zu 6x schneller als WritePixelFast). Jedoch muss man Speicherposition und Ausgabewert manuell berechnen. Dies ist nicht so einfach und nur mit Hilfe von LockedFormat, LockedPitch und LockedPixels m\u00f6glich. F\u00fcr schnelle Grafikausgabe muss man zudem f\u00fcr jedes Grafikformat eine gesonderte Routine programmieren!"
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [{ "name": "buffer", "optional": 1 }],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Wert zwischen 1 und 4, der die Farbtiefe des Buffers folgenderma\u00dfen repr\u00e4sentiert:  1 = 16 Bit RGB (5 Bit R, 6 Bit G, 5 Bit B)  2 = 16 Bit RGB (5 Bit R, 5 Bit G, 5 Bit B, 1 Bit ungenutzt)  3 = 24 Bit RGB (8 Bit R, 8 Bit G, 8 Bit B)  4 = 32 Bit RGB (8 Bit R, 8 Bit G, 8 Bit B, 8 Bit ungenutzt)"
      }
    },
    "code": ""
  },
  "lockedpitch": {
    "name": "LockedPitch",
    "description": {
      "en": "",
      "de": "Die Funktion LockedPitch ermittelt die Gr\u00f6\u00dfe in Byte, die f\u00fcr eine horizontale Zeile eines Grafikbuffers ben\u00f6tigt wird. Diese Gr\u00f6\u00dfe h\u00e4ngt von Breite des Grafikbuffers und Farbtiefe ab. Dies ist dann n\u00fctzlich, wenn Pixel direkt ins Video-RAM mit Poke/Peek-Befehlen gezeichnet/gelesen werden sollen und nicht mir WritePixel/ReadPixel. Dazu ist eine vorherige Sperrung des Grafikbuffers mit LockBuffer notwendig.   Direktes Zeichnen mit Poke ist deutlich schneller (bis zu 6x schneller als WritePixelFast). Jedoch muss man Speicherposition und Ausgabewert manuell berechnen. Dies ist nicht so einfach und nur mit Hilfe von LockedFormat, LockedPitch und LockedPixels m\u00f6glich. F\u00fcr schnelle Grafikausgabe muss man zudem f\u00fcr jedes Grafikformat eine gesonderte Routine programmieren!"
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [{ "name": "buffer", "optional": 1 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "lockedpixels": {
    "name": "LockedPixels",
    "description": {
      "en": "",
      "de": "Die Funktion LockedPixels liefert die Identit\u00e4t einer Bank zur\u00fcck. Diese Bank repr\u00e4sentiert den Videospeicher und enth\u00e4lt Pixelinformationen, die mit Peek-/Poke-Befehlen manipuliert werden k\u00f6nnen. Dazu ist eine vorherige Sperrung des Grafikbuffers mit LockBuffer notwendig.   Direktes Zeichnen mit Poke ist deutlich schneller (bis zu 6x schneller als WritePixelFast). Jedoch muss man Speicherposition und Ausgabewert manuell berechnen. Dies ist nicht so einfach und nur mit Hilfe von LockedFormat, LockedPitch und LockedPixels m\u00f6glich. F\u00fcr schnelle Grafikausgabe muss man zudem f\u00fcr jedes Grafikformat eine gesonderte Routine programmieren!"
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [{ "name": "buffer", "optional": 1 }],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t einer Bank wird zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "plot": {
    "name": "Plot",
    "description": {
      "en": "",
      "de": "Dieser Befehl zeichnet einen einfachen Punkt auf dem Bildschirm. Man muss nur die X- und Y-Koordinaten eingeben. Die Farbe ist immer die aktuelle Zeichenfarbe und kann mit Color eingestellt werden."
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "readpixel": {
    "name": "ReadPixel",
    "description": {
      "en": "",
      "de": "Diese Funktion liest die Farbe eines Pixels an der X/Y-Koordinate aus. Dabei wird die Farbe immer aus dem aktuellen Buffer ermitteln. Wenn man m\u00f6chte, dann kann man einen speziellen Grafikbuffer mit dem optionalen Parameter \"Buffer\" angeben - dann wird daraus die Farbe ausgelesen. (siehe BackBuffer, FrontBuffer und ImageBuffer).   Benutze WritePixel oder WritePixelFast, um die ausgelesene Farbe wieder einzuzeichnen."
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "buffer", "optional": 1 }
    ],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Integerwert, der einen Farbcode als RGB-Wert beinhaltet. Siehe Zusatzinformationen, um zu sehen wie man es ausrechnet."
      }
    },
    "code": ""
  },
  "readpixelfast": {
    "name": "ReadPixelFast",
    "description": {
      "en": "",
      "de": "Diese Funktion liest die Farbe eines Pixels an der X/Y-Koordinate aus. Dabei wird die Farbe immer aus dem aktuellen Buffer ermitteln. Wenn man m\u00f6chte, dann kann man einen speziellen Grafikbuffer mit dem optionalen Parameter \"Buffer\" angeben - dann wird daraus die Farbe ausgelesen. (siehe BackBuffer, FrontBuffer und ImageBuffer).   Bevor man ReadPixelFast oder WritePixelFast verwenden kann, muss man noch den Befehl LockBuffer verwenden. Dadurch wird ein Buffer f\u00fcr andere Befehle gesperrt und die Fehlerpr\u00fcfung deaktiviert. Danach muss ein Buffer mit UnlockBuffer wieder ge\u00f6ffnet werden. "
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "buffer", "optional": 1 }
    ],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Integerwert, der einen Farbcode als RGB-Wert beinhaltet. Siehe Zusatzinformationen, um zu sehen wie man es ausrechnet."
      }
    },
    "code": ""
  },
  "unlockbuffer": {
    "name": "UnlockBuffer",
    "description": {
      "en": "",
      "de": "Dieser Befehl \u00f6ffnet einen Buffer, der mit LockBuffer vorher gesperrt wurde. Dadurch k\u00f6nnen die normalen Grafikbefehle wieder benutzt werden. Die Fehlerpr\u00fcfung wird wieder aktiviert. UnlockBuffer wurde speziell f\u00fcr CopyPixelFast, ReadPixelFast und WritePixelFast geschrieben, um eine noch h\u00f6here Geschwindigkeit zu erzielen. Mit LockBuffer kann ein Buffer f\u00fcr normale Grafikbefehle gesperrt werden."
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [{ "name": "buffer", "optional": 1 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "writepixel": {
    "name": "WritePixel",
    "description": {
      "en": "",
      "de": "Diese Anweisung zeichnet einen Punkt an der X/Y-Koordinate ein. F\u00fcr die Ausgabe wird immer der aktuelle Buffer verwendet. Mit der Buffer-Option kann die Grafikausgabe auf einem anderen Buffer erfolgen (siehe BackBuffer, FrontBuffer und ImageBuffer)."
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "rgb", "optional": 0 },
      { "name": "buffer", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "writepixelfast": {
    "name": "WritePixelFast",
    "description": {
      "en": "",
      "de": "Diese Anweisung zeichnet einen Punkt an der X/Y-Koordinate ein. F\u00fcr die Ausgabe wird immer der aktuelle Buffer verwendet. Mit der Buffer-Option kann die Grafikausgabe auf einem anderen Buffer erfolgen (siehe BackBuffer, FrontBuffer und ImageBuffer).   Bevor man ReadPixelFast / WritePixelFast verwenden kann, muss man noch den Befehl LockBuffer verwenden. Dadurch wird ein Buffer f\u00fcr andere Befehle gesperrt und die Fehlerpr\u00fcfung deaktiviert. Danach muss ein Buffer mit UnlockBuffer wieder ge\u00f6ffnet werden. "
    },
    "category": "graphics2d",
    "subCategory": "pixel",
    "params": [
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "rgb", "optional": 0 },
      { "name": "buffer", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "fontascent": {
    "name": "FontAscent",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt den Ascent-Wert einer Schriftart. Mit Hilfe diesen Wertes kann man die Grundlinie der Buchstaben ausrechnen."
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [{ "name": "font", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "Liefert Ascent-Wert einer Schriftart." } },
    "code": ""
  },
  "fontdescent": {
    "name": "FontDescent",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt den Descent-Wert einer Schriftart. Mit Hilfe diesen Wertes kann man die Grundlinie der Buchstaben errechnen. Da man dies allerdings mit FontAscent bequemer kann, braucht man diesen Befehl in der Regel nicht."
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [{ "name": "font", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "Liefert den Descent-Wert einer Schriftart." } },
    "code": ""
  },
  "fontheight": {
    "name": "FontHeight",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die maximale H\u00f6he einer Schrift in Pixel. Dabei wird immer die aktuell gesetzte Schrift ber\u00fccksichtigt, die mit LoadFont geladen und mit SetFont gesetzt wurde.   Diese Funktion ist f\u00fcr Berechnungen gedacht, um einen Text genau zu platzieren bzw. um einen Text \u00fcber dem Bildschirm zu bewegen.   Die Funktion StringHeight ermittelt dagegen die tats\u00e4chliche H\u00f6he eines Textes."
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Maximale H\u00f6he der aktuellen Schrift in Pixel." } },
    "code": ""
  },
  "fontname": {
    "name": "FontName",
    "description": {
      "en": "",
      "de": "Liefert Name einer Schriftart aus dem Font-Handle zur\u00fcck. Handle ist ein R\u00fcckgabewert von LoadFont oder RequestFont."
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [{ "name": "font", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "Name der Schriftart" } },
    "code": ""
  },
  "fontsize": {
    "name": "FontSize",
    "description": {
      "en": "",
      "de": "Liefert die Gr\u00f6\u00dfe einer Schriftart in Punkt aus dem Font-Handle zur\u00fcck. Handle ist ein R\u00fcckgabewert von LoadFont oder RequestFont."
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [{ "name": "font", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "Gr\u00f6\u00dfe einer Schriftart in Punkt" } },
    "code": ""
  },
  "fontstyle": {
    "name": "FontStyle",
    "description": {
      "en": "",
      "de": "Liefert Schrift-Style aus Font-Handle zur\u00fcck. Handle ist ein R\u00fcckgabewert von LoadFont oder RequestFont."
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [{ "name": "font", "optional": 0 }],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Stylewert der Schriftart  (style AND 1 = fett  style AND 2 = kursiv  style AND 4 = unterstrichen)"
      }
    },
    "code": ""
  },
  "fontwidth": {
    "name": "FontWidth",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die maximale Breite des breitesten Zeichens in Pixel. Dabei wird immer die aktuell gesetzte Schrift ber\u00fccksichtigt, die mit LoadFont/RequestFont geladen und mit SetFont gesetzt wurde.   Diese Funktion ist f\u00fcr Berechnungen gedacht, um einen Text genau zu platzieren bzw. um einen Text \u00fcber dem Bildschirm zu bewegen.   Die Funktion StringWidth ermittelt dagegen die tats\u00e4chliche L\u00e4nge eines Textes."
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Breite des breitesten Zeichens in Pixel" } },
    "code": ""
  },
  "freefont": {
    "name": "FreeFont",
    "description": {
      "en": "",
      "de": "Diese Anweisung entfernt eine vorher mit LoadFont/RequestFont geladene Schrift aus dem Speicher. Dadurch wird mehr Speicher frei. Die FONT-Befehle von BlitzBasic arbeiten nicht mit Symbolschriften wie Webdings and Wingdings zusammen. "
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [{ "name": "font", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "loadfont": {
    "name": "LoadFont",
    "description": {
      "en": "",
      "de": "Dieser Befehl l\u00e4dt eine Schrift in den Speicher. Die Schrift muss bereits im System installiert sein. Es wird aber keine Datei, sondern ein Fontname angegeben (siehe Zeichentabelle). Um diese geladene Schrift dann zu aktivieren, muss man SetFont verwenden. Danach kann diese Schrift mit dem Text-Befehl dargestellt werden. Um die Schrift wieder zu entfernen, sollte FreeFont verwendet werden."
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [
      { "name": "fontName", "optional": 0 },
      { "name": "size", "optional": 0 },
      { "name": "bold", "optional": 1 },
      { "name": "italic", "optional": 1 },
      { "name": "underline", "optional": 1 }
    ],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t der Schritart als Integer. Sollte eine Schriftart nicht vorhanden sein, wird eine Standardschriftart geladen. In diesem Fall wird trotzdem ein g\u00fcltiger Wert (ungleich 0) zur\u00fcckgegeben."
      }
    },
    "code": ""
  },
  "locate": {
    "name": "Locate",
    "description": {
      "en": "",
      "de": "Diese Anweisung setzt den Textcursor an die angegebene Bildschirmposition. Die Cursorposition ist dabei pixelgenau. Ab dieser Position wird dann der n\u00e4chste Text ausgegeben. Locate kann mit Print oder Inputverwendet werden."
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "print": {
    "name": "Print",
    "description": {
      "en": "",
      "de": "Dieser Befehl gibt einen Text oder einen Zahlenwert auf dem Bildschirm aus. Danach erfolgt automatisch ein Zeilenvorschub. Um die Position zu bestimmen, sollte LOCATE verwendet werden. WRITE funktioniert \u00e4hnlich, allerdings ohne den Zeilenvorschub. "
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [{ "name": "value", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "setfont": {
    "name": "SetFont",
    "description": {
      "en": "",
      "de": "Mit diesem Befehl kann eine Schrift ausgew\u00e4hlt werden, die f\u00fcr weitere Textausgabe benutzt werden soll. Die Schrift muss man aber vorher mit LoadFont/RequestFont laden. Die somit Identit\u00e4t wird danach f\u00fcr diesen Befehl verwendet. Mit dem Text-Befehl kann die Schrift gezeichnet werden. Wird die Schrift sp\u00e4ter nicht mehr gebraucht, so sollte sie dann mit FreeFont entfernt werden. "
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [{ "name": "font", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "stringheight": {
    "name": "StringHeight",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die H\u00f6he eines Textes in Pixel. Dabei wird immer die aktuell gesetzte Schrift ber\u00fccksichtigt, die mit LoadFont/RequestFont geladen und mit SetFont gesetzt wurde.   Diese Funktion ist f\u00fcr Berechnungen gedacht, um einen Text genau zu platzieren bzw. um einen Text \u00fcber dem Bildschirm zu bewegen. "
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [{ "name": "text", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "maximale H\u00f6he des Textes in Pixel" } },
    "code": ""
  },
  "stringwidth": {
    "name": "StringWidth",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die Breite eines Textes in Pixel. Dabei wird immer die aktuell gesetzte Schrift ber\u00fccksichtigt, die mit LoadFont/RequestFont geladen und mit SetFont gesetzt wurde.   Diese Funktion ist f\u00fcr Berechnungen gedacht, um einen Text genau zu platzieren bzw. um einen Text \u00fcber dem Bildschirm zu bewegen."
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [{ "name": "text", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "Breite des Textes in Pixel" } },
    "code": ""
  },
  "text": {
    "name": "Text",
    "description": {
      "en": "",
      "de": "Mit diesem Befehl kann man einen beliebigen Text ausgeben. Dabei wird die aktuelle Schrift benutzt, die mit SetFont eingestellt wurde. Der Text erscheint nur auf dem aktuellen Buffer, der mit SetBuffer eingestellt wurde. Der Hintergrund wird mit Text-Befehl nicht gel\u00f6scht, so dass ein Text auf das Spielfeld eingezeichnet werden kann. Allerdings gibt es keine Antialiasing-Funktion, wodurch der Text scharfkantig und bei kleinen Aufl\u00f6sungen leicht pixelig wirkt.   Die optionalen Parameter zentr_x und zentr_y k\u00f6nnen einen Text in horizontale bzw. vertikale Richtung zentrieren."
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "text", "optional": 0 },
      { "name": "centerX", "optional": 1 },
      { "name": "centerY", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "write": {
    "name": "Write",
    "description": {
      "en": "",
      "de": "Dieser Befehl gibt einen Text oder einen Zahlenwert auf dem Bildschirm aus. Danach erfolgt aber kein automatischer Zeilenvorschub. Um die Position zu bestimmen, sollte Locate verwendet werden. Print funktioniert \u00e4hnlich, allerdings mit dem Zeilenvorschub."
    },
    "category": "graphics2d",
    "subCategory": "text",
    "params": [{ "name": "text", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "closemovie": {
    "name": "CloseMovie",
    "description": {
      "en": "",
      "de": "Die Anweisung CloseMove beendet den Zugriff auf eine Video-Datei, die mit OpenMovie vorher ge\u00f6ffnet wurde.   Wenn ein Video nach dem Beenden wieder abgespielt werden soll, dann muss man die Datei schlie\u00dfen und wieder \u00f6ffnen."
    },
    "category": "graphics2d",
    "subCategory": "movies",
    "params": [{ "name": "movie", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "drawmovie": {
    "name": "DrawMovie",
    "description": {
      "en": "",
      "de": "Die Anweisung DrawMovie zeichnet ein Video auf dem aktuellen Grafikbuffer ein. Die Koordinaten X und Y entsprechen der linken, oberen Ecke des Videos. Die optionalen Parameter \"Breite\" und \"H\u00f6he\" bestimmen die Gr\u00f6\u00dfe des Videos. Wenn diese Parameter ausgelassen werden, dann wird das Video in der Standardgr\u00f6\u00dfe wiedergeben. "
    },
    "category": "graphics2d",
    "subCategory": "movies",
    "params": [
      { "name": "movie", "optional": 0 },
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "width", "optional": 1 },
      { "name": "height", "optional": 1 }
    ],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Wenn Video noch abgespielt wird, dann wird -1 zur\u00fcckgegeben, sonst aber 0."
      }
    },
    "code": ""
  },
  "movieheight": {
    "name": "MovieHeight",
    "description": {
      "en": "",
      "de": "Die Funktion MovieHeight liefert die H\u00f6he eines Videos, welches bereits vorher mit OpenMovie ge\u00f6ffnet wurde. Beachte: DrawMovie zeigt das Video bereits standardm\u00e4\u00dfig in Originalgr\u00f6\u00dfe."
    },
    "category": "graphics2d",
    "subCategory": "movies",
    "params": [{ "name": "movie", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "H\u00f6he des Videos in Pixel" } },
    "code": ""
  },
  "movieplaying": {
    "name": "MoviePlaying",
    "description": {
      "en": "",
      "de": "Die Funktion MoviePlaying liefert 1 zur\u00fcck, wenn das Video noch abgespielt wird. Wenn es nicht abgespielt wird, dann wird 0 zur\u00fcckgeliefert."
    },
    "category": "graphics2d",
    "subCategory": "movies",
    "params": [{ "name": "movie", "optional": 0 }],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Wenn das Video noch abgespielt wird, dann wird 1 zur\u00fcckgeliefert, andernfalls wird 0 zur\u00fcckgegeben."
      }
    },
    "code": ""
  },
  "moviewidth": {
    "name": "MovieWidth",
    "description": {
      "en": "",
      "de": "Die Funktion MovieWidht liefert die Breite eines Videos, welches bereits vorher mit OpenMovie ge\u00f6ffnet wurde. Beachte: DrawMovie zeigt das Video bereits standardm\u00e4\u00dfig in Originalgr\u00f6\u00dfe."
    },
    "category": "graphics2d",
    "subCategory": "movies",
    "params": [{ "name": "movie", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "Breite des Videos in Pixel" } },
    "code": ""
  },
  "openmovie": {
    "name": "OpenMovie",
    "description": {
      "en": "",
      "de": "Die Funktion OpenMovie \u00f6ffnet eine Videodatei und liefert die Identit\u00e4t des Videos als Integer zur\u00fcck.   Nach diesem Befehl wird das Video abgespielt. Mit DrawMovie kann es an beliebiger Stelle gezeichnet werden. Wenn das Video zu Ende ist, dann muss man es mit CloseMovie schlie\u00dfen und mit OpenMovie erneut \u00f6ffnen. "
    },
    "category": "graphics2d",
    "subCategory": "movies",
    "params": [{ "name": "filePath", "optional": 0 }],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird die Identit\u00e4t des Videos zur\u00fcckgeliefert. Falls die Datei nicht gefunden/gelesen werden kann, dann wird 0 zur\u00fcckgeliefert."
      }
    },
    "code": ""
  },
  "addanimseq": {
    "name": "AddAnimSeq",
    "description": {
      "en": "",
      "de": "Die Anweisung AddAnimSeq f\u00fcgt eine Animationssequenz an ein Objekt an.   Doch bevor man diesen Befehl ausf\u00fchren kann, muss man noch Animations-Keys setzten. Dazu muss man ein Objekt verschieben und mit SetAnimKey die Daten speichern. Erst danach kann man die Animationssequenz mit AddAnimSeq definieren. Die Animation wird mit Animating gestartet. UpdateWorld muss jedes Mal f\u00fcr die Bewegung ausgef\u00fchrt werden."
    },
    "category": "graphics3d",
    "subCategory": "animations",
    "params": [
      { "name": "entity", "optional": 0 },
      { "name": "duration", "optional": 0 }
    ],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Nummer der Animationssequenz zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "animate": {
    "name": "Animate",
    "description": {
      "en": "",
      "de": "Die Anweisung Animate \u00e4ndert die Animationsart eines Objekts.   Dazu muss man die Identit\u00e4t eines Objekts angeben.   Danach den \"Modus\" angeben (0=stoppt die Animation, 1=spielt im Loop, 2=spielt eine Animation hin und her, 3=spielt eine Animation nur 1x ab).   Mit dem Parameter \"Geschw\" kann man die Geschwindigkeit \u00e4ndern (Standard ist 1). Wird eine negative Nummer angegeben, dann wird die Animation r\u00fcckw\u00e4rts abgespielt.   Ein Entity, das mit LoadAnimMesh geladen wurde, hat zu Beginn nur eine Animationssequenz. Weitere k\u00f6nnen mit LoadAnimSeq oder mit AddAnimSeq hinzugef\u00fcgt werden. Die Nummer der Sequenz beginnt mit 0.   Mit dem Parameter \"Trans\" kann man den Animations\u00fcbergang einstellen. Wird der Wert 0 \u00fcbergeben, dann erscheint zwischen den Animationssequenzen ein Animationssprung. Bei einem gr\u00f6\u00dferen Wert als 0, wird die Animation \"gegl\u00e4ttet\"."
    },
    "category": "graphics3d",
    "subCategory": "animations",
    "params": [
      { "name": "entity", "optional": 0 },
      { "name": "mode", "optional": 1 },
      { "name": "speed", "optional": 1 },
      { "name": "sequence", "optional": 1 },
      { "name": "transition", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "animating": {
    "name": "Animating",
    "description": {
      "en": "",
      "de": "Die Funktion Animating ermittelt, ob ein Objekt gerade animiert wird. Dabei wird 0 zur\u00fcckgeliefert, wenn es nicht animiert wird und 1 wenn es gerade animiert wird. Diese Funktion kann nicht mit MD2-Objekten benutzt werden. Benutze f\u00fcr MD2-Objekte den Befehl MD2Animating."
    },
    "category": "graphics3d",
    "subCategory": "animations",
    "params": [{ "name": "entity", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "0 = wird nicht animiert  1 = wird animiert" } },
    "code": ""
  },
  "animlength": {
    "name": "AnimLength",
    "description": {
      "en": "",
      "de": "Die Funktion AnimLength ermittelt die aktuelle Animationszeit eines Objekts (relativ zur aktuellen Animationssequenz). F\u00fcr diese Funktion muss man nur die Identit\u00e4t eines Objekts angeben. Diese Funktion kann nicht mit MD2-Objekten benutzt werden. Benutze f\u00fcr MD2-Objekte den Befehl MD2AnimLength."
    },
    "category": "graphics3d",
    "subCategory": "animations",
    "params": [{ "name": "entity", "optional": 0 }],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Aktuelle Animationszeit eines Objekts in msek (relativ zur aktuellen Animationssequenz)."
      }
    },
    "code": ""
  },
  "animseq": {
    "name": "AnimSeq",
    "description": {
      "en": "",
      "de": "Die Funktion AnimSeq ermittelt die aktuelle Animationssequenz eines Objekts. F\u00fcr diese Funktion muss man nur die Identit\u00e4t eines Objekts angeben. Diese Funktion kann nicht mit MD2-Objekten benutzt werden."
    },
    "category": "graphics3d",
    "subCategory": "animations",
    "params": [{ "name": "entity", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "Aktuelle Animationssequenz (ab 0)" } },
    "code": ""
  },
  "animtime": {
    "name": "AnimTime",
    "description": {
      "en": "",
      "de": "Die Funktion AnimTime ermittelt die aktuelle Animationszeit eines Objekts. F\u00fcr diese Funktion muss man nur die Identit\u00e4t eines Objekts angeben. Diese Funktion kann nicht mit MD2-Objekten benutzt werden. Benutze f\u00fcr MD2-Objekte den Befehl MD2AnimTime."
    },
    "category": "graphics3d",
    "subCategory": "animations",
    "params": [{ "name": "entity", "optional": 0 }],
    "return": { "name": "", "description": { "en": "", "de": "Aktuelle Animationszeit im Frames." } },
    "code": ""
  },
  "extractanimseq": {
    "name": "ExtractAnimSeq",
    "description": {
      "en": "",
      "de": "Dank ExtractAnimSeq k\u00f6nnen einfache Meshanimationen fast wie MD2-Animationen funktionieren. Dazu wird ein Mesh ganz normal geladen - es hat dann bereits eine Animationssequenz. Weitere Animationssequenzen k\u00f6nnen dann mit ExtractAnimSeq erstellt werden. Mit Animate kann dann eine beliebige Animationssequenz abgespielt werden. "
    },
    "category": "graphics3d",
    "subCategory": "animations",
    "params": [
      { "name": "entity", "optional": 0 },
      { "name": "startFrame", "optional": 0 },
      { "name": "endFrame", "optional": 0 },
      { "name": "animSeq", "optional": 1 }
    ],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Nummer der Animationssequenz zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "loadanimseq": {
    "name": "LoadAnimSeq",
    "description": {
      "en": "",
      "de": "Die Funktion LoadAnimSeq l\u00e4dt eine Animationssequenz aus einer Datei aus und f\u00fcgt die zu einem Objekt (entity) hinzu.   Der Parameter \"entity%\" ist die Identit\u00e4t eines Objekts, zu dem die Animationssequenz hinzugef\u00fcgt werden soll.   Die Animation kann nur aus X-, 3DS- oder B3D-Dateien geladen werden.   Wenn es keine Probleme gab, dann wird die Nummer der Animationssequenz zur\u00fcckgeliefert."
    },
    "category": "graphics3d",
    "subCategory": "animations",
    "params": [
      { "name": "entity", "optional": 0 },
      { "name": "filePath", "optional": 0 }
    ],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Nummer der Animationssequenz zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "setanimkey": {
    "name": "SetAnimKey",
    "description": {
      "en": "",
      "de": "Die Anweisung SetAnimKey setzt die Animationsparameter f\u00fcr ein Objekt (entity).   Der Parameter \"frame%\" gibt den Zeitindex an. Es f\u00e4ngt mit 0 an und wird mit nachfolgenden SetAnimKey-Befehlen erh\u00f6ht (siehe Beispiel).   Wenn Verschiebung, Rotation oder Skalierung beachtet werden soll, dann muss man bei den entsprechenden Parametern 1 angeben, andernfalls 0."
    },
    "category": "graphics3d",
    "subCategory": "animations",
    "params": [
      { "name": "entity", "optional": 0 },
      { "name": "frame", "optional": 0 },
      { "name": "translation", "optional": 1 },
      { "name": "rotation", "optional": 1 },
      { "name": "scaling", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "setanimtime": {
    "name": "SetAnimTime",
    "description": {
      "en": "",
      "de": "Die Funktion SetAnimTime erlaubt eine manuelle \u00c4nderung der Animationszeit. Gebe einfach die Identit\u00e4t eines Objekts, zusammen mit Zeitangabe (in Frames) und evtl. Nummer der Animationssequenz an."
    },
    "category": "graphics3d",
    "subCategory": "animations",
    "params": [
      { "name": "entity", "optional": 0 },
      { "name": "Zeitangabe in Frames", "optional": 0 },
      { "name": "sequence", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "aligntovector": {
    "name": "AlignToVector",
    "description": {
      "en": "",
      "de": "Die Anweisung AlignToVector richtet eine Objekt-Achse entlang eines Vektors aus. Dazu wird die Identit\u00e4t des Objekts angegeben und die drei Komponenten des Vektors. Danach wird die Achse des Objekts angegeben. Diese Angaben reichen aus, um ein Objekt auszurichten.   Der optionale Parameter \"tempo#\" gibt die Geschwindigkeit der Drehung an. Bei 1 wird es sofort auf den Vector gedreht. Bei kleinerem Wert ist die Bewegung glatter."
    },
    "category": "graphics3d",
    "subCategory": "coordinates",
    "params": [
      { "name": "entity", "optional": 0 },
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "z", "optional": 0 },
      { "name": "axis", "optional": 0 },
      { "name": "alignFactor", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "moveentity": {
    "name": "MoveEntity",
    "description": {
      "en": "",
      "de": "Die Anweisung MoveEntity verschiebt ein Objekt (entity) um einen bestimmten XYZ-Abstand.   Beachte, dass das Objekt relativ zu seiner Position und Drehrichtung verschoben wird. Eine Kamera kann somit immer nach vorne verschoben werden - egal ob man zur Seite guckt oder nach unten oder oben... Auch die Abst\u00e4nde werden relativ zur letzten Position betrachtet."
    },
    "category": "graphics3d",
    "subCategory": "coordinates",
    "params": [
      { "name": "entity", "optional": 0 },
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "z", "optional": 0 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "pointentity": {
    "name": "PointEntity",
    "description": {
      "en": "",
      "de": "Die Anweisung PointEntity dreht ein Quell-Objekt so, dass es danach direkt auf ein Ziel-Objekt zeigt. Bei der Drehung werden nur die Pitch- und Yaw-Winkel ge\u00e4ndert. Roll-Winkel wird nicht ge\u00e4ndert. Deshalb gibt es noch den optionalen Parameter \"Roll\"."
    },
    "category": "graphics3d",
    "subCategory": "coordinates",
    "params": [
      { "name": "source", "optional": 0 },
      { "name": "target", "optional": 0 },
      { "name": "rollAngle", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "positionentity": {
    "name": "PositionEntity",
    "description": {
      "en": "",
      "de": "Die Anweisung PositionEntity setzt ein Objekt an eine bestimmte absolute Position in der 3D-Welt.   Alle 3D-Objekte m\u00fcssen positioniert werden, da neue Objekte automatisch an der Koordinate 0,0,0 erstellt werden. Dazu muss man die Koordinaten x#, y# und z# angeben.   Der optionale Parameter \"global%\" gibt an, ob ein Objekt abh\u00e4ngig von der Position eines Parent-Objekt positioniert werden soll. Wenn 0 angegeben wurde, dann wird die Parent-Position ber\u00fccksichtigt. Wenn 1 angegeben wurde, dann wird die 3D-Welt-Koordinate ber\u00fccksichtigt. "
    },
    "category": "graphics3d",
    "subCategory": "coordinates",
    "params": [
      { "name": "entity", "optional": 0 },
      { "name": "x", "optional": 0 },
      { "name": "y", "optional": 0 },
      { "name": "z", "optional": 0 },
      { "name": "global", "optional": 1 }
    ],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "rotateentity": {
    "name": "RotateEntity",
    "description": {
      "en": "",
      "de": "Die Anweisung RotateEntity dreht ein Objekt (entity) auf einen bestimmten absoluten Winkel.   Der Winkel pitch# ist ein Drehwinkel f\u00fcr die X-Achse  Der Winkel yaw# ist ein Drehwinkel f\u00fcr die Y-Achse  Der Winkel roll# ist ein Drehwinkel f\u00fcr die Z-Achse   Der optionale Parameter \"global%\" gibt an, ob der Drehwinkel vom Parent-Objekt ber\u00fccksichtigt werden soll. Gebe 0 ein, wenn das Objekt die Winkel vom Parent-Objekt ber\u00fccksichtigen soll. Gebe 1 an, wenn es vom Parent-Objekt unabh\u00e4ngig gedreht werden soll. "
    },
    "category": "graphics3d",
    "subCategory": "coordinates",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "scaleentity": {
    "name": "ScaleEntity",
    "description": {
      "en": "",
      "de": "Die Anweisung ScaleEntity skaliert ein Objekt auf eine bestimmte absolute Gr\u00f6\u00dfe.   Normalerweise wird jedes Objekt mit Skalierungsfaktor 1 erstellt/geladen. Gibt man nun eine kleine Zahl ein, dann wird dieses Objekt entsprechend verkleinert (0.5=50%). Gibt man dagegen gr\u00f6\u00dferen Wert ein, dann wird es vergr\u00f6\u00dfert (2.0=200%).   Negative Skalierungsfaktoren sind aber auch m\u00f6glich. Dieses Objekt wird dann in der entsprechenden Achse gespiegelt.   Der optionale Parameter \"global%\" gibt an, ob die Skalierungsfaktoren (un)abh\u00e4ngig von Parent \u00fcbergeben werden. Gebe 0 ein, wenn Skalierungsgr\u00f6\u00dfe vom Parent in Berechnung einflie\u00dfen soll. Sonst gebe 1 ein, wenn dieses Objekt unabh\u00e4ngig vom Parent skaliert werden soll."
    },
    "category": "graphics3d",
    "subCategory": "coordinates",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "translateentity": {
    "name": "TranslateEntity",
    "description": {
      "en": "",
      "de": "Die Anweisung TranslateEntity verschiebt ein Objekt (entity) um einen bestimmten XYZ-Abstand.   Beachte, dass das Objekt relativ zu seiner Position verschoben wird, wobei die Drehwinkel im Gegensatz zu MoveEntity nicht beachtet werden.   Der optionale Parameter \"Global\" gibt an, ob die Drehwinkel vom Parent-Objekt ber\u00fccksichtigt werden sollen. Bei 0 werden die Winkel des Parent-Objekts beachtet. Bei 1 wird es unabh\u00e4ngig vom Parent-Objekt verschoben."
    },
    "category": "graphics3d",
    "subCategory": "coordinates",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "turnentity": {
    "name": "TurnEntity",
    "description": {
      "en": "",
      "de": "Die Anweisung TurnEntity dreht ein Objekt (entity%) um einen bestimmten relativen Winkel.   Der Winkel pitch# ist ein Drehwinkel f\u00fcr die X-Achse  Der Winkel yaw# ist ein Drehwinkel f\u00fcr die Y-Achse  Der Winkel roll# ist ein Drehwinkel f\u00fcr die Z-Achse   Der optionale Parameter \"global%\" gibt an, ob der Drehwinkel vom Parent-Objekt ber\u00fccksichtigt werden soll. Gebe 0 ein, wenn das Objekt die Winkel vom Parent-Objekt ber\u00fccksichtigen soll. Gebe 1 an, wenn es vom Parent-Objekt unabh\u00e4ngig gedreht werden soll."
    },
    "category": "graphics3d",
    "subCategory": "coordinates",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "brushalpha": {
    "name": "BrushAlpha",
    "description": {
      "en": "",
      "de": "Die Anweisung BrushAlpha \u00e4ndert den Alphawert von einem Pinsel (brush%). Der Alphawert kann nur im Bereich von 0.0 bis 1.0 liegen (1.0=Standard).   Alpha ist ein Transparenzwert. Dabei bedeutet 1.0=sichtbar und 0.0=unsichtbar. Mit den Werten, die zwischen 0.0 und 1.0 liegen, kann man Glas, Eis oder Wasser simulieren.   Der Alphawert 0.0 kann besonders n\u00fctzlich sein. Blitz3D rendert solche Objekte nicht. Daf\u00fcr kann man es auf Kollision testen. Deshalb ist es anders als HideEntity, welches Kollisionspr\u00fcfung nicht zul\u00e4sst."
    },
    "category": "graphics3d",
    "subCategory": "brushes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "brushblend": {
    "name": "BrushBlend",
    "description": {
      "en": "",
      "de": "Die Anweisung BrushBlend setzt einen anderen Pinselmodus.   Wird Modus 1 verwendet, so erscheint dieses Objekt ganz normal.   Wird Modus 2 verwendet, so werden die Farben der Objekte unter diesem Objekt dazugemischt.   Wird Modus 3 verwendet, so werden die Farben der Objekte unter diesem Objekt addiert (gut f\u00fcr Lichteffekte). "
    },
    "category": "graphics3d",
    "subCategory": "brushes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "brushcolor": {
    "name": "BrushColor",
    "description": {
      "en": "",
      "de": "Die Anweisung BrushColor w\u00e4hlt eine andere Pinselfarbe aus. Die einzelnen Farbanteile k\u00f6nnen nur im Bereich von 0-255 liegen. Die Standardfarbe ist 255,255,255 (=wei\u00df)."
    },
    "category": "graphics3d",
    "subCategory": "brushes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "brushfx": {
    "name": "BrushFX",
    "description": {
      "en": "",
      "de": "Die Anweisung BrushFX weist einem Pinsel bestimmte Effekte zu. Mehrere Effekte k\u00f6nnen kombiniert werden. Dazu muss man nur die einzelnen Werte addieren. Sollen z.B. Effekte 1 und 2 angewendet werden, so muss man den Wert 3 \u00fcbergeben."
    },
    "category": "graphics3d",
    "subCategory": "brushes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "brushshininess": {
    "name": "BrushShininess",
    "description": {
      "en": "",
      "de": "Mit diesem Befehl kann man reflektierenden Glanz einem Pinsel zuweisen.   Der Wert Glanz sollte nur im Bereich von 0 bis 1 liegen. Der Standardwert ist 0.   Damit kann man einstellen, wie stark die Reflektion aussehen soll, wenn die Seite einer Fl\u00e4che zur Lichtquelle zeigt."
    },
    "category": "graphics3d",
    "subCategory": "brushes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "brushtexture": {
    "name": "BrushTexture",
    "description": {
      "en": "",
      "de": "Die Anweisung BrushTexture kann eine Textur einem Pinsel zugeweisen.   Der optionale Parameter \"frame%\" muss nur dann angegeben werden, wenn eine geladene Textur mehr als ein Animationsframe enth\u00e4lt. Der Standardwert daf\u00fcr ist 0.   Der optionale Parameter \"index%\" gibt an, welcher Texturebene (layer) des Pinseln eine Textur zugewiesen werden soll. Einem Objekt k\u00f6nnen mehrere Texturen (0-7) zugewiesen werden. Dies nennt man Multitextur."
    },
    "category": "graphics3d",
    "subCategory": "brushes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "createbrush": {
    "name": "CreateBrush",
    "description": {
      "en": "",
      "de": "Der Befehl CreateBrush erstellt einen Pinsel (brush) und liefert danach die Identit\u00e4t des Pinsels zur\u00fcck.   Mit den optionalen Parametern kann man die Pinselfarbe einstellen. Die Werte der Farbanteile k\u00f6nnen nur im Bereich von 0-255 liegen. Standardfarbe ist 255,255,255.   Ein Pinsel ist eine Ansammlung von vielen Informationen wie: Farbe, Transparenz, Glanz, Textur usw. Nach der Definition eines Pinsels kann man ein Objekt (entity), Gitterobjekt (mesh) oder Oberfl\u00e4che (surface) mit dem Pinsel \"bemalen\" - alle Eigenschaften werden dann auf diese Objekte \u00fcbertragen. Dazu muss man diese Befehle benutzen: PaintEntity, PaintMesh, PaintSurface.   Wenn ein Gitterobjekt erstellt wird, dann m\u00f6chte man die einzelnen Oberfl\u00e4chen unterschiedlich bemalen. Benutzt man dagegen die Befehle EntityColor, EntityAlpha usw., dann werden alle Oberfl\u00e4chen eines Gitterobjekts einheitlich ge\u00e4ndert."
    },
    "category": "graphics3d",
    "subCategory": "brushes",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t eines Pinsels (brush) zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "freebrush": {
    "name": "FreeBrush",
    "description": {
      "en": "",
      "de": "Der Befehl FreeBrush l\u00f6scht einen Pinsel (brush%) aus dem Speicher. Man kann danach einen neuen erstellen.   Das L\u00f6schen eines Pinsels \u00fcbernimmt BlitzBasic auch automatisch am Ende des Programms. Trotzdem ist es besser, wenn man es manuell macht. Zudem kann man w\u00e4hrend der Laufzeit Pinsel l\u00f6schen."
    },
    "category": "graphics3d",
    "subCategory": "brushes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "getbrushtexture": {
    "name": "GetBrushTexture",
    "description": {
      "en": "",
      "de": "Die Funktion GetBrushTexture liefert die Identit\u00e4t einer Textur zur\u00fcck, die vorher zu einem Brush zugewiesen wurde. Index kann ein Wert 0-7 sein, um auch Multitexturen verarbeiten zu k\u00f6nnen.   Nach Benutzung sollte diese Textur wieder mit FreeTexture gel\u00f6scht werden, um MemoryLeaks zu verhindern!   Benutze eventuell TextureName, um den Texturnamen zu ermitteln."
    },
    "category": "graphics3d",
    "subCategory": "brushes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Textur-Identit\u00e4t wird zur\u00fcckgeliefert" } },
    "code": ""
  },
  "getentitybrush": {
    "name": "GetEntityBrush",
    "description": {
      "en": "",
      "de": "Die Funktion GetEntityBrush liefert Brush-Identit\u00e4t zur\u00fcck, die alle Eigenschaften aufweist, mit dem ein Entity \"bemalt\" wurde.   Wenn diese Funktion keinen Wert zur\u00fcck liefert, dann muss man es mit GetSurfaceBrush versuchen (1. Surface).   Benutze danach GetBrushTexture und TextureName, um mehr Details zu erhalten. "
    },
    "category": "graphics3d",
    "subCategory": "brushes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Brush-Identit\u00e4t wird zur\u00fcckgeliefert" } },
    "code": ""
  },
  "getsurfacebrush": {
    "name": "GetSurfaceBrush",
    "description": {
      "en": "",
      "de": "Die Funktion GetSurfaceBrush liefert Brush-Identit\u00e4t zur\u00fcck, die alle Eigenschaften aufweist, mit dem ein Surface \"bemalt\" wurde.   Wenn diese Funktion keinen Wert zur\u00fcck liefert, dann muss man es mit GetEntityBrush versuchen.   Benutze danach GetBrushTexture und TextureName, um mehr Details zu erhalten."
    },
    "category": "graphics3d",
    "subCategory": "brushes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Brush-Identit\u00e4t wird zur\u00fcckgeliefert" } },
    "code": ""
  },
  "loadbrush": {
    "name": "LoadBrush",
    "description": {
      "en": "",
      "de": "Die Funktion LoadBrush erstellt einen Pinsel. Nachdem ein Pinsel erstellt wurde, wird noch eine Textur geladen und zum Pinsel zugewiesen. Diese Funktion liefert einen Wert zur\u00fcck. Es handelt sich um die Identit\u00e4t des Pinsels.   Der Parameter \"datei$\" ist der Pfad zu einer Grafikdatei, die die Textur enth\u00e4lt.   Der optionale Parameter \"modus%\" stellt Textureffekte ein. Mehrere Effekte k\u00f6nnen kombiniert werden, indem die Zahlen addiert werden. "
    },
    "category": "graphics3d",
    "subCategory": "brushes",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t eines Pinsels zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "paintentity": {
    "name": "PaintEntity",
    "description": {
      "en": "",
      "de": "Die Anweisung PaintEntity \u00fcbergibt alle Eigenschaften eines Pinsels (brush%) an ein Objekt (entity%).   Normalerweise kann man mit den Befehlen EntityColor, EntityShininess oder EntityTexture die Eigenschaften zuweisen. Da daf\u00fcr jedes Mal ziemlich viele Befehle notwendig sind, gibt es noch das Brush-Feature. Dabei werden die Eigenschaften einfach mit Brush gespeichert. Diese Eigenschaften lassen sich danach sehr einfach mit nur einem Befehl auf beliebig viele Objekte \u00fcbertragen.   Gebe daf\u00fcr die Identit\u00e4t eines Objekts (entity%) an. Danach muss man noch die Identit\u00e4t eines Pinsels angeben. Dieser Pinsel kann mit CreateBrush erstellt oder mit LoadBrush geladen werden."
    },
    "category": "graphics3d",
    "subCategory": "brushes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "paintmesh": {
    "name": "PaintMesh",
    "description": {
      "en": "",
      "de": "Die Anweisung PaintMesh \u00fcbergibt alle Eigenschaften eines Pinsels (brush) an ein Gitterobjekt (mesh).   Normalerweise kann man mit den Befehlen EntityColor, EntityShininess oder EntityTexture die Eigenschaften zuweisen. Da daf\u00fcr jedes Mal ziemlich viele Befehle notwendig sind, gibt es noch das Brush-Feature. Dabei werden die Eigenschaften einfach mit Brush gespeichert. Diese Eigenschaften lassen sich danach sehr einfach mit nur einem Befehl auf beliebig viele Objekte \u00fcbertragen.   Gebe daf\u00fcr die Identit\u00e4t eines Gitterobjekts (mesh%) an. Danach muss man noch die Identit\u00e4t eines Pinsels angeben. Dieser Pinsel kann mit CreateBrush erstellt oder mit LoadBrush geladen werden"
    },
    "category": "graphics3d",
    "subCategory": "brushes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "paintsurface": {
    "name": "PaintSurface",
    "description": {
      "en": "",
      "de": "Die Anweisung PaintSurface \u00fcbergibt alle Eigenschaften eines Pinsels (brush%) an eine Gitteroberfl\u00e4che (surface%).   Normalerweise kann man mit den Befehlen EntityColor, EntityShininess oder EntityTexture die Eigenschaften zuweisen. Da daf\u00fcr jedes Mal ziemlich viele Befehle notwendig sind, gibt es noch das Brush-Feature. Dabei werden die Eigenschaften einfach mit Brush gespeichert. Diese Eigenschaften lassen sich danach sehr einfach mit nur einem Befehl auf beliebig viele Objekte \u00fcbertragen.   Gebe daf\u00fcr die Identit\u00e4t einer Gitteroberfl\u00e4che (surface%) an. Danach muss man noch die Identit\u00e4t eines Pinsels angeben. Dieser Pinsel kann mit CreateBrush erstellt oder mit LoadBrush geladen werden. "
    },
    "category": "graphics3d",
    "subCategory": "brushes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "createmirror": {
    "name": "CreateMirror",
    "description": {
      "en": "",
      "de": "Der Befehl CreateMirror erstellt ein Spiegelobjekt und liefert danach die Identit\u00e4t des Objekts zur\u00fcck.   Ein Spiegel ist ein flacher, unendlicher Boden. Dieser Boden ist unsichtbar, stellt aber alle Objekte \u00fcber/unter dem Spiegel kopiert dar. Es ist \u00fcberall dort n\u00fctzlich, wo ein polierter Boden mit einer Reflektion dargestellt werden soll. Benutze f\u00fcr einen noch realistischeren Effekt die Kombination aus Spiegel und texturierter Plane (mit 50% Transparenz).   Wurde der Parameter \"parent%\" angegeben, dann wird dieser Spiegel zu einem anderen Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.   Ein Spiegel wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird es an der Position des Parent-Objekts erstellt."
    },
    "category": "graphics3d",
    "subCategory": "diverse",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t des Spiegels zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "createpivot": {
    "name": "CreatePivot",
    "description": {
      "en": "",
      "de": "Der Befehl CreatePivot erstellt einen Drehpunkt und liefert danach die Identit\u00e4t des Objekts zur\u00fcck.   Ein Drehpunkt (pivot entity) ist ein unsichtbares Objekt in der 3D-Welt. Es wird haupts\u00e4chlich als Parent f\u00fcr andere Objekte benutzt. Danach k\u00f6nnen mit diesem Objekt viele hinzugef\u00fcgte Objekte gedreht (Zentrum der Rotation) oder verschoben werden.   Um dieses Feature zu benutzen, muss man entweder EntityParent benutzen oder den optionalen Parameter \"Parent\", das bei vielen Befehlen eingegeben werden kann.   Wurde der Parameter \"Parent\" angegeben, dann wird dieses Objekt zu einem anderen Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.   Ein Drehpunkt wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird es an der Position des Parent-Objekts erstellt."
    },
    "category": "graphics3d",
    "subCategory": "diverse",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t des Drehpunktes zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "createplane": {
    "name": "CreatePlane",
    "description": {
      "en": "",
      "de": "Mit dem Befehl CreatePlane wird eine Ebene (plane) erstellt und die Identit\u00e4t des Objekts zur\u00fcckgeliefert.   Plane ist ein flacher, unendlicher Boden. Es ist f\u00fcr die Spiele n\u00fctzlich, die einen \"unendlichen\" Horizont haben sollen.   Der optionale Parameter \"teilung%\" unterteil die Plane in mehrere Teile (wodurch mehr Polygone erstellt werden). Da eine Plane flach ist, kann die auch nicht gegl\u00e4ttet werden. Ein h\u00f6herer Wert verbessert jedoch die Lichtdetails auf dem Boden.   Wurde der Parameter \"parent%\" angegeben, dann wird dieses Objekt zu einem anderen Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.   Eine Plane wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird es an der Position des Parent-Objekts erstellt. "
    },
    "category": "graphics3d",
    "subCategory": "diverse",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t der Plane zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "getmatelement": {
    "name": "GetMatElement",
    "description": {
      "en": "",
      "de": "Die Funktion GetMatElement gibt den Wert eines Matrix-Elements zur\u00fcck. Ein Entity hat folgende Hauptinformationen: Skalierung, Drehung und Verschiebung. Alle diese Werte sind in einer 3x4-Matrix verschmolzen. Man kann nun diese Werte auslesen. Es gibt nur wenige Gr\u00fcnde, wo man diese Informationen ben\u00f6tigt."
    },
    "category": "graphics3d",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Es liefert Wert eines Matrix-Eintrags zur\u00fcck" } },
    "code": ""
  },
  "loadermatrix": {
    "name": "LoaderMatrix",
    "description": {
      "en": "",
      "de": "Die Anweisung LoaderMatrix setzt Matrix f\u00fcr 3D-Dateien.   Dies ist nur dann sinnvoll, wenn das Koordinatensystem der 3D-Datei ge\u00e4ndert werden muss. So kann man z.B. Koordinate X und Y tauschen - diese Anweisung ist somit f\u00fcr Profis interessant.   Standardm\u00e4\u00dfig gilt diese Matrix:   LoaderMatrix \"x\",1,0,0,0,1,0,0,0,1"
    },
    "category": "graphics3d",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "stats3d": {
    "name": "Stats3D",
    "description": {
      "en": "",
      "de": "Diese Funktion diente dem Entwickler zum Debuggen. Sie wird zwar noch im Compiler aufgef\u00fchrt, hat aber keinen direkten Zweck mehr. Benutzung auf eigene Gefahr."
    },
    "category": "graphics3d",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Floatwert mit unbekannter Bedeutung." } },
    "code": ""
  },
  "trisrendered": {
    "name": "TrisRendered",
    "description": {
      "en": "",
      "de": "Die Funktion TrisRendered liefert die Anzahl der Dreiecke (triangles), die mit der letzten Anweisung RENDERWORLD verarbeitet wurden.   Die Anzahl der tats\u00e4chlich gerenderten Dreiecke ist normalerweise geringer, da Dreiecke auf der R\u00fcckseite von Objekten nicht beachtet werden."
    },
    "category": "graphics3d",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Anzahl der verarbeiteten Dreiecke." } },
    "code": ""
  },
  "vectorpitch": {
    "name": "VectorPitch",
    "description": {
      "en": "",
      "de": "Die Funktion VectorPitch berechnet den absoluten Pitch-Winkel f\u00fcr die X-Achse. F\u00fcr die Berechnung muss man nur die drei Abst\u00e4nde angeben. Diese werden aus der Differenz von zwei 3D-Weltpunkten berechnet (siehe Beispiel).   Die Funktion VectorYaw berechnet den zweiten Winkel f\u00fcr die Y-Achse. Ein dritter Winkel wird nicht ben\u00f6tigt."
    },
    "category": "graphics3d",
    "subCategory": "diverse",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Winkel f\u00fcr die X-Achse (pitch) wird zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "vectoryaw": {
    "name": "VectorYaw",
    "description": {
      "en": "",
      "de": "Die Funktion VectorYaw berechnet den absoluten Pitch-Winkel f\u00fcr die Y-Achse. F\u00fcr die Berechnung muss man nur die drei Abst\u00e4nde angeben. Diese werden aus der Differenz von zwei 3D-Weltpunkten berechnet (siehe Beispiel).   Die Funktion VectorPitch berechnet den zweiten Winkel f\u00fcr die X-Achse. Ein dritter Winkel wird nicht ben\u00f6tigt."
    },
    "category": "graphics3d",
    "subCategory": "diverse",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Winkel f\u00fcr die Y-Achse (yaw) wird zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "antialias": {
    "name": "AntiAlias",
    "description": {
      "en": "",
      "de": "Die Anweisung AntiAlias kann Fullscreen-Antialiasing ein- oder ausschalten. Dies ist eine spezielle Technik, die eine Treppenbildung und scharfe Kantenbildung verhindert, indem \"Zwischenpunkte\" berechnet werden."
    },
    "category": "graphics3d",
    "subCategory": "scenery",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "captureworld": {
    "name": "CaptureWorld",
    "description": {
      "en": "",
      "de": "Mit CaptureWorld kann ein \"snapshot\" aller Objekte (entitys) erstellt werden. Dabei werden Positionen und Drehwinkel der Objekte gespeichert.   Nachdem ein \"snapshot\" gemacht wurde, k\u00f6nnen die Objekte verschoben und gedreht werden. Danach kann man eine Animation zwischen den zwei Bewegungen erstellen. Dazu muss man den Befehl RenderWorldbenutzen. RenderWorld 0 zeichnet die Objekte an der Position, wo ein \"snapshot\" erstellt wurde. Mit RenderWorld 1 werden die Objekte dagegen an der aktuellen Position eingezeichnet. Mit den Zwischenwerten k\u00f6nnen die Objekte animiert werden.   Der Grund f\u00fcr diese Technik ist sehr einfach. Die Spielobjekte k\u00f6nnen mit einer geringeren CPU-Belastung bewegt werden, da nur die Ver\u00e4nderungen berechnet werden. Zudem kann man das Updaten der Objekte etwas reduzieren. So kann man z.B. 30 Animationsstufen erstellen, aber ganze 60 anzeigen (mit Zwischensequenzen)."
    },
    "category": "graphics3d",
    "subCategory": "scenery",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "clearworld": {
    "name": "ClearWorld",
    "description": {
      "en": "",
      "de": "L\u00f6scht alle Objekte, Pinsel und/oder Texturen.   Dies ist dann sinnvoll, wenn ein Level beendet wurde und dann alle Objekte gel\u00f6scht werden sollen. Die Objekte, Pinsel oder Texturen k\u00f6nnen dann neu erstellt/geladen werden, ohne die alten Objekte einzeln l\u00f6schen zu m\u00fcssen."
    },
    "category": "graphics3d",
    "subCategory": "scenery",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "dither": {
    "name": "Dither",
    "description": {
      "en": "",
      "de": "Die Anweisung Dither schaltet \"hardware dithering\" ein oder aus.   Hardware dithering ist dann sinnvoll, wenn eine 16 Bit Farbtiefe benutzt wird. Beachte, dass im 16 Bit Modus wesentlich weniger Farben dargestellt werden k\u00f6nnen als das menschliche Auge unterscheiden kann. Man erkennt deutlich schlechtere Farbabstufungen. Hardware dithering zeichnet Farben nicht einfach ein, sondern zeichnet die in einem Streumuster. Dadurch erscheint es so, als ob mehr Farben vorhanden w\u00e4ren - die Ausgabe sieht besser aus. "
    },
    "category": "graphics3d",
    "subCategory": "scenery",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "hwmultitex": {
    "name": "HWMultiTex",
    "description": {
      "en": "",
      "de": "Die Anweisung HWMultiTex schaltet hardware multitexturing ein oder aus.   Multitextur ist eine spezielle Technik, die mehr als eine Textur auf Objekte projizieren kann. Wenn 3D-Grafikkarte dieses Feature unterst\u00fctzt, dann sind mehrere Texturen auf einem Objekt kein Problem - auch von Geschwindigkeit her.   Manche Grafikkarten haben aber Probleme damit - deshalb kann es mit diesem Befehl deaktiviert werden. Dann benutzt BlitzBasic software multitexturing - es ist aber langsamer als hardware multitexturing!"
    },
    "category": "graphics3d",
    "subCategory": "scenery",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "hwtexunits": {
    "name": "HWTexUnits",
    "description": { "en": "", "de": "Liefert die Anzahl der \"hardware texturing units\" zur\u00fcck." },
    "category": "graphics3d",
    "subCategory": "scenery",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Anzahl \"hardware texturing units\"" } },
    "code": ""
  },
  "renderworld": {
    "name": "RenderWorld",
    "description": {
      "en": "",
      "de": "Die Anweisung RenderWorld rendert komplette 3D-Szene und zeichnet es auf BackBuffer ein.   Der optionale Parameter gibt den Animationsschritt an. Wenn keine Zwischenanimationen erstellt werden sollen, dann muss man nichts angeben. Sollen Objekte animiert werden, dann muss man folgendes tun:   Mit CaptureWorld kann ein \"snapshot\" aller Objekte (entitys) erstellt werden. Dabei werden Positionen und Drehwinkel der Objekte gespeichert.   Nachdem ein \"snapshot\" gemacht wurde, k\u00f6nnen die Objekte verschoben und gedreht werden. Danach kann man eine Animation zwischen den zwei Bewegungen erstellen. Dazu muss man den Befehl RenderWorld benutzen. RenderWorld 0 zeichnet die Objekte an der Position, wo ein \"snapshot\" erstellt wurde. Mit RenderWorld 1 werden die Objekte dagegen an der aktuellen Position eingezeichnet. Mit den Zwischenwerten k\u00f6nnen die Objekte animiert werden.   Der Grund f\u00fcr diese Technik ist sehr einfach. Die Spielobjekte k\u00f6nnen mit einer geringeren CPU-Belastung bewegt werden, da nur die Ver\u00e4nderungen berechnet werden. Zudem kann man das Updaten der Objekte etwas reduzieren. So kann man z.B. 30 Animationsstufen erstellen, aber ganze 60 anzeigen (mit Zwischensequenzen)."
    },
    "category": "graphics3d",
    "subCategory": "scenery",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "updateworld": {
    "name": "UpdateWorld",
    "description": {
      "en": "",
      "de": "Die Anweisung UpdateWorld animiert alle Objekte und \u00fcberpr\u00fcft die auf Kollision.   Der optionale Parameter \"zeit#\" gibt an, wie schnell die gesamte Animation ablaufen soll. Standardwert ist immer 1. Wenn es erh\u00f6ht wird, dann wird die Animation schneller abgespielt. Bei einem kleineren Wert wird die Animation entsprechend langsamer.   Die besten Ergebnisse werden erzielt, wenn UpdateWorld jedes Mal im Hauptprogramm ausgef\u00fchrt wird und vor RenderWorld geschrieben wird."
    },
    "category": "graphics3d",
    "subCategory": "scenery",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "wbuffer": {
    "name": "WBuffer",
    "description": {
      "en": "",
      "de": "Die Anweisung WBuffer schaltet W-Buffering ein oder aus.   W-Buffering ist eine spezielle Technik f\u00fcr Darstellung der 3D-Szenen. Hierbei werden weiter Objekte zuerst gezeichnet und nahe zuletzt.   Normales Z-Buffering versucht dies nachzumachen. Leider kann es in 16 Bit Grafikmodus nicht korrekt arbeiten. Es arbeitet mit geringeren Pr\u00e4zision als in 24/32 Bit. Dadurch k\u00f6nnen sich einige Objekte in machen Situationen \u00fcberlappen, obwohl die es nicht tun sollten.   Mit WBuffer kann man dies unterdr\u00fccken. Es ist wesentlich genauer, ist aber weniger kompatibel als Z-Buffering."
    },
    "category": "graphics3d",
    "subCategory": "scenery",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "wireframe": {
    "name": "WireFrame",
    "description": {
      "en": "",
      "de": "Die Anweisung WireFrame schaltet die 3D-Darstellung zwischen normaler Fl\u00e4chenansicht (=0) und Gitteransicht (=1) um.   Dies ist meistens nur f\u00fcrs Debugging notwendig/empfehlenswert. So kann man dann alle Gitterobjekte besser erkennen.   Diesen Befehl kann man aber nicht auf einen einzigen Objekt anwenden, sondern nur auf komplette Szene."
    },
    "category": "graphics3d",
    "subCategory": "scenery",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "cameraclscolor": {
    "name": "CameraClsColor",
    "description": {
      "en": "",
      "de": "Mit CameraClsColor wird die Hintergrundfarbe einer Kamera ausgew\u00e4hlt. Die einzelnen Farbanteile k\u00f6nnen nur im Bereich von 0-255 liegen. Die Standardfarbe ist 0,0,0 (=schwarz)."
    },
    "category": "graphics3d",
    "subCategory": "camera",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "cameraclsmode": {
    "name": "CameraClsMode",
    "description": {
      "en": "",
      "de": "Die Anweisung CameraClsMode setzt den L\u00f6sch-Modus einer Kamera.   Mit dem Parameter Farbe kann man das L\u00f6schen des Szenen-Hintergrundes ausschalten. Dann wird der Bereich, wo sich keine Objekte befinden, \u00fcberhaupt nicht gel\u00f6scht! Das kann zu schweren Grafikfehlern f\u00fchren, wenn es nicht richtig angewendet wird. Es ist dann sinnvoll, wenn zuerst 2D-Hintergrundbild gemalt wird und dann 3D-Objekte darauf gezeichnet werden."
    },
    "category": "graphics3d",
    "subCategory": "camera",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "camerafogcolor": {
    "name": "CameraFogColor",
    "description": {
      "en": "",
      "de": "Mit CameraFogColor wird die Nebelfarbe einer Kamera eingestellt. Die einzelnen Farbanteile k\u00f6nnen nur im Bereich von 0-255 liegen.   Je weiter ein Objekt von der Kamera entfernt ist, desto mehr Nebelfarbe wird hinzugerechnet. Dadurch haben weit entfernte Objekte weniger unterschiedlichere Farben - es entsteht ein Nebeleffekt.   Dieser Effekt wird meistens dazu benutzt, einen Pop-Up-Effekt zu verhindern, wenn ein Objekt in den Kamerabereich kommt.   Die Standard-Nebelfarbe ist schwarz (0,0,0) und die Standard-Entfernung des Nebels ist 1-1000. Die Entfernung kann mit CameraFogRange ge\u00e4ndert werden. "
    },
    "category": "graphics3d",
    "subCategory": "camera",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "camerafogmode": {
    "name": "CameraFogMode",
    "description": {
      "en": "",
      "de": "Mit CameraFogMode kann man den Nebeleffekt f\u00fcr eine Kamera ein- oder ausschalten. Der Modus kann nur 0 (=aus) oder 1 (=ein) sein.   Je weiter ein Objekt von der Kamera entfernt ist, desto mehr Nebelfarbe wird hinzugerechnet. Dadurch haben weit entfernte Objekte weniger unterschiedlichere Farben - es entsteht ein Nebeleffekt.   Dieser Effekt wird meistens dazu benutzt, einen Pop-Up-Effekt zu verhindern, wenn ein Objekt in den Kamerabereich kommt.   Die Standard-Nebelfarbe ist schwarz (0,0,0) und die Standard-Entfernung des Nebels ist 1-1000. Diese Werte k\u00f6nnen mit den Befehlen CameraFogColor und CameraFogRange ge\u00e4ndert werden."
    },
    "category": "graphics3d",
    "subCategory": "camera",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "camerafogrange": {
    "name": "CameraFogRange",
    "description": {
      "en": "",
      "de": "Mit CameraFogRange kann man die Entfernung des Nebels f\u00fcr eine Kamera einstellen.   Je weiter ein Objekt von der Kamera entfernt ist, desto mehr Nebelfarbe wird hinzugerechnet. Dadurch haben weit entfernte Objekte weniger unterschiedlichere Farben - es entsteht ein Nebeleffekt.   Dieser Effekt wird meistens dazu benutzt, einen Pop-Up-Effekt zu verhindern, wenn ein Objekt in den Kamerabereich kommt.   Die Standard-Entfernung des Nebels ist 1-1000. Soll ein st\u00e4rkerer Nebel simuliert werden, so muss man nur die Endentfernung verringern. Befindet sich ein Objekt vor der Startentfernung, so wird es nicht ge\u00e4ndert. Befindet es sich allerdings hinter der Endentfernung, so wird es komplett ausgefadet. "
    },
    "category": "graphics3d",
    "subCategory": "camera",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "cameraproject": {
    "name": "CameraProject",
    "description": {
      "en": "",
      "de": "Die Anweisung CameraProject errechnet aus den absoluten 3D-Raumkoordinaten die 2D-Bildschirmkoordinaten.   Nachdem CameraProject ausgef\u00fchrt wurde, m\u00fcssen noch Funktionen wie ProjectedX, ProjectedY und ProjectedZ benutzt werden. Die errechnete X- und Y-Werte sind dabei die 2D-Bildschirmkoordinaten. Der Z-Wert ist entweder 0 oder 1. Bei 0 liegt die Koordinate hinter der Kamera, bei 1 vor der Kamera.   Es gibt viele Anwendungsm\u00f6glichkeiten daf\u00fcr. Mithilfe dieser Funktionen kann man z.B. einen Sonnenschweif simulieren. "
    },
    "category": "graphics3d",
    "subCategory": "camera",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Die 'Projected'-Funktionen liefern die errechneten Werte zur\u00fcck." }
    },
    "code": ""
  },
  "cameraprojmode": {
    "name": "CameraProjMode",
    "description": {
      "en": "",
      "de": "Die Anweisung CameraProjMode schaltet die Projektion einer Kamera um. Projektion ist eine ganz spezielle Technik zur Darstellung der 3D-Welt auf dem Bildschirm.   Mit dem Parameter \"Modus\" kann man nur Werte 0-2 angeben. Wert 0 schaltet die Kamera komplett aus. Dies ist wesentlich schneller als die Kamera mit HideEntity zu verstecken. Der Wert 1 (Standard) schaltet die normale Projektion ein - die Objekte erscheinen so perspektivisch korrekt auf dem Bildschirm. Der Wert 2 schaltet auf eine ganz spezielle Darstellungsart um. Die 3D-Szene wird als 2D-Grafik, ohne perspektivische Tiefe dargestellt. So werden zwei Objekte mit der selben Gr\u00f6\u00dfe aber in unterschiedlicher Entfernung trotzdem identisch dargestellt. Orthographische Projektion ist besonders f\u00fcr 3D-Editoren n\u00fctzlich, wo drei Ansichten (Vorderansicht, Seitenansicht und Draufsicht) ohne Perspektive dargestellt werden m\u00fcssen. "
    },
    "category": "graphics3d",
    "subCategory": "camera",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "camerarange": {
    "name": "CameraRange",
    "description": {
      "en": "",
      "de": "Mit CameraRange kann man die minimale und maximale Objektentfernung einstellen. Nur in diesem Bereich werden alle Objekte eingezeichnet. Sollte ein Objekt n\u00e4her/weiter sein, so wird es geclippt (einzelne Dreiecke nicht eingezeichnet).   Mit dieser Einstellung kann man die 3D-Grafik wesentlich beschleunigen. Da dadurch nicht mehr alle Dreiecke gezeichnet werden. Mit dem Nebeleffekt kann ein pl\u00f6tzliches aufpoppen eines Objekts stark vermieden werden. "
    },
    "category": "graphics3d",
    "subCategory": "camera",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "cameraviewport": {
    "name": "CameraViewport",
    "description": {
      "en": "",
      "de": "Mit CameraViewport wird ein Bereich des 2D-Bildschirm ausgew\u00e4hlt, wohin die Kameraansicht einer 3D-Welt eingezeichnet werden soll.   Benutze diesen Befehl, wenn mehrere Kameraansichten eingezeichnet werden sollen. Dies ist z.B. dann der Fall, wenn mehrere Spieler in einem Splitscreen gegeneinander spielen sollen."
    },
    "category": "graphics3d",
    "subCategory": "camera",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "camerazoom": {
    "name": "CameraZoom",
    "description": {
      "en": "",
      "de": "Mit CameraZoom kann man eine ausgew\u00e4hlte Kamera hinein- und hinauszoomen. Der Standardwert ist 1. Ein kleinerer Wert verkleinert das Bild. Ein gr\u00f6\u00dferer Wert vergr\u00f6\u00dfert es. "
    },
    "category": "graphics3d",
    "subCategory": "camera",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "createcamera": {
    "name": "CreateCamera",
    "description": {
      "en": "",
      "de": "Der Befehl CreateCamera erstellt eine virtuelle Kamera und liefert die Identit\u00e4t der Kamera zur\u00fcck.   Ohne eine Kamera kann keine 3D-Welt dargestellt werden. Bei mehr als einer Kamera ist ein Spiel mit Splitscreen m\u00f6glich.   Eine 3D-Welt kann nur ins BackBuffer gerendert werden. Falls eine 3D-Szene in ein Image gespeichert werden soll, dann muss man einen Ausschnitt des BackBuffers mit GrabImage oder CopyRect kopieren.   Wurde der Parameter \"parent%\" angegeben, dann wird diese Kamera zu einem Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.   Die Kamera wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird die an der Position des Parent-Objekts erstellt. "
    },
    "category": "graphics3d",
    "subCategory": "camera",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t der Kamera zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "projectedx": {
    "name": "ProjectedX",
    "description": {
      "en": "",
      "de": "Die Anweisung ProjectedX liefert die horizontale Bildschirmkoordinate, die aus einer 3D-Koordinate mit CameraProject berechnet wurde.   Nachdem CameraProject ausgef\u00fchrt wurde, m\u00fcssen noch Funktionen wie ProjectedX, ProjectedY und ProjectedZ benutzt werden. Die errechnete X- und Y-Werte sind dabei die 2D-Bildschirmkoordinaten. Der Z-Wert ist entweder 0 oder 1. Bei 0 liegt die Koordinate hinter der Kamera, bei 1 vor der Kamera.   Es gibt viele Anwendungsm\u00f6glichkeiten daf\u00fcr. Mithilfe dieser Funktionen kann man z.B. einen Sonnenschweif simulieren. "
    },
    "category": "graphics3d",
    "subCategory": "camera",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Die horizontale Bildschirmkoordinate wird zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "projectedy": {
    "name": "ProjectedY",
    "description": {
      "en": "",
      "de": "Die Anweisung ProjectedY liefert die vertikale Bildschirmkoordinate, die aus einer 3D-Koordinate mit CameraProject berechnet wurde.   Nachdem CameraProject ausgef\u00fchrt wurde, m\u00fcssen noch Funktionen wie ProjectedX, ProjectedY und ProjectedZ benutzt werden. Die errechnete X- und Y-Werte sind dabei die 2D-Bildschirmkoordinaten. Der Z-Wert ist entweder 0 oder 1. Bei 0 liegt die Koordinate hinter der Kamera, bei 1 vor der Kamera.   Es gibt viele Anwendungsm\u00f6glichkeiten daf\u00fcr. Mithilfe dieser Funktionen kann man z.B. einen Sonnenschweif simulieren."
    },
    "category": "graphics3d",
    "subCategory": "camera",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Die vertikale Bildschirmkoordinate wird zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "projectedz": {
    "name": "ProjectedZ",
    "description": {
      "en": "",
      "de": "Die Anweisung ProjectedZ liefert 1 zur\u00fcck, wenn eine 3D-Koordinate vor der Kamera liegt.   Nachdem CameraProject ausgef\u00fchrt wurde, m\u00fcssen noch Funktionen wie ProjectedX, ProjectedY und ProjectedZ benutzt werden. Die errechnete X- und Y-Werte sind dabei die 2D-Bildschirmkoordinaten. Der Z-Wert ist entweder 0 oder 1. Bei 0 liegt die Koordinate hinter der Kamera, bei 1 vor der Kamera.   Es gibt viele Anwendungsm\u00f6glichkeiten daf\u00fcr. Mithilfe dieser Funktionen kann man z.B. einen Sonnenschweif simulieren."
    },
    "category": "graphics3d",
    "subCategory": "camera",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Liefert 1 zur\u00fcck, wenn eine 3D-Koordinate vor der Kamera liegt, sonst 0."
      }
    },
    "code": ""
  },
  "clearcollisions": {
    "name": "ClearCollisions",
    "description": {
      "en": "",
      "de": "Mit ClearCollisions wird die Kollisions-Liste gel\u00f6scht.   Immer wenn der Befehl Collisions benutzt wird, um die Kollisionspr\u00fcfung zwischen zwei Objekten einzuschalten, wird auch eine Kollisions-Liste im Speicher abgelegt. Mit dem Befehl ClearCollisions wird diese Liste wieder gel\u00f6scht - bis noch mal der Befehl Collisions ausgef\u00fchrt wird. "
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "collisionentity": {
    "name": "CollisionEntity",
    "description": {
      "en": "",
      "de": "Die Funktion CollisionEntity liefert die Identit\u00e4t eines Entitys, das mit einem anderen Entity kollidiert ist.   Dabei muss man zuerst die Identit\u00e4t des ersten Entity-Objekts angeben. Da ein Objekt mit mehreren anderen Objekten gleichzeitig kollidieren kann, muss man die Indexnummer angeben. Dieser Index kann nur von 1 bis CountCollisions reichen."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t eines Entitys, das mit diesem Entity kollidierte. " }
    },
    "code": ""
  },
  "collisionnx": {
    "name": "CollisionNX",
    "description": {
      "en": "",
      "de": "Die Funktion CollisionNX liefert die X-Koordinate eines kollidierten Normals. Die Funktion CollisionX berechnet dagegen die absolute Kollision von dem Nullpunkt der 3D-Welt.   Dabei muss man zuerst die Identit\u00e4t des ersten Entity-Objekts angeben. Da ein Objekt mit mehreren anderen Objekten gleichzeitig kollidieren kann, muss man die Indexnummer angeben. Dieser Index kann nur von 1 bis CountCollisions reichen."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "X-Koordinate des Normals" } },
    "code": ""
  },
  "collisionny": {
    "name": "CollisionNY",
    "description": {
      "en": "",
      "de": "Die Funktion CollisionNY liefert die Y-Koordinate eines kollidierten Normals. Der Befehl CollisionY berechnet dagegen die absolute Kollision von dem Nullpunkt der 3D-Welt.   Dabei muss man zuerst die Identit\u00e4t des ersten Entity-Objekts angeben. Da ein Objekt mit mehreren anderen Objekten gleichzeitig kollidieren kann, muss man die Indexnummer angeben. Dieser Index kann nur von 1 bis CountCollisions reichen."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Y-Koordinate des Normals" } },
    "code": ""
  },
  "collisionnz": {
    "name": "CollisionNZ",
    "description": {
      "en": "",
      "de": "Die Funktion CollisionNZ liefert die Z-Koordinate eines kollidierten Normals. Der Befehl CollisionZ berechnet dagegen die absolute Kollision von dem Nullpunkt der 3D-Welt.   Dabei muss man zuerst die Identit\u00e4t des ersten Entity-Objekts angeben. Da ein Objekt mit mehreren anderen Objekten gleichzeitig kollidieren kann, muss man die Indexnummer angeben. Dieser Index kann nur von 1 bis CountCollisions reichen."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Z-Koordinate des Normals" } },
    "code": ""
  },
  "collisions": {
    "name": "Collisions",
    "description": {
      "en": "",
      "de": "Aktiviert die Kollision zwischen zwei verschiedenen Objekttypen.   EntityTypes sind einfache Nummern die mit EntityType gesetzt werden k\u00f6nnen. BlitzBasic benutzt diese EntityTypes dann um die Kollision eines Objekts mit anderen zu \u00fcberpr\u00fcfen.   BlitzBasic hat mehrere M\u00f6glichkeiten der Kollisionspr\u00fcfung, als nur das einfache Kennzeichnen der Objekte. Auch der Kollisionsradius spielt eine bedeutende Rolle. Der Radius kann mit EntityRadius gesetzt werden.   Wurde die Methode auf 1 gesetzt (Kugel-Kugel), dann muss dem Zielobjekt EntityRadius zugeteilt werden. Wird die Methode 3 benutzt (Kugel-W\u00fcrfel), dann muss man EntityBox ausf\u00fchren. Die 2 Methode (Kugel-Polygon) ben\u00f6tigt keine besondere Zuweisung.   F\u00fcr den Fall, dass eine Kollision erkannt wurde, gibt es noch einen Parameter. Damit kann man die Reaktion des Objekts auf eine Kollision einstellen. Dadurch kann ein Objekt stoppen, sliden oder raufsliden.   Alle Reaktionen werden nur dann ausgef\u00fchrt, wenn UpdateWorld ausgef\u00fchrt wird.   Jedes Mal, wenn der Befehl Collisions ausgef\u00fchrt wird, wird die Information zu einer Kollisionsliste hinzugef\u00fcgt. Diese Liste kann jederzeit mit ClearCollisions gel\u00f6scht werden. "
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "collisionsurface": {
    "name": "CollisionSurface",
    "description": {
      "en": "",
      "de": "Die Funktion CollisionSurface ermittelt die Identit\u00e4t der kollidierten Gitteroberfl\u00e4che (Surface).   Dabei muss man zuerst die Identit\u00e4t des ersten Entity-Objekts angeben. Da ein Objekt mit mehreren anderen Objekten gleichzeitig kollidieren kann, muss man die Indexnummer angeben. Dieser Index kann nur von 1 bis CountCollisions reichen."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Identit\u00e4t einer Oberfl\u00e4che (Surface)" } },
    "code": ""
  },
  "collisiontime": {
    "name": "CollisionTime",
    "description": {
      "en": "",
      "de": "Die Funktion CollisionTime ermittelt die Zeit, die f\u00fcr eine Kollisionsberechnung ben\u00f6tigt wird.   Dabei muss man zuerst die Identit\u00e4t des ersten Entity-Objekts angeben. Da ein Objekt mit mehreren anderen Objekten gleichzeitig kollidieren kann, muss man die Indexnummer angeben. Dieser Index kann nur von 1 bis CountCollisions reichen."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Zeit in Millisekunden, die eine Kollisionsberechnung andauert." }
    },
    "code": ""
  },
  "collisiontriangle": {
    "name": "CollisionTriangle",
    "description": {
      "en": "",
      "de": "Die Funktion CollisionTriangle ermittelt die Identit\u00e4t des kollidierten Dreiecks (triangle).   Dabei muss man zuerst die Identit\u00e4t des ersten Entity-Objekts angeben. Da ein Objekt mit mehreren anderen Objekten gleichzeitig kollidieren kann, muss man die Indexnummer angeben. Dieser Index kann nur von 1 bis CountCollisions reichen."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Identit\u00e4t eines kollidierten Dreiecks." } },
    "code": ""
  },
  "collisionx": {
    "name": "CollisionX",
    "description": {
      "en": "",
      "de": "Die Funktion CollisionX liefert die X-Koordinate der Kollision. Dabei wird die absolute Koordinate von dem Nullpunkt der 3D-Welt berechnet. Der Befehl CollisionNX berechnet dagegen die Koordinate des Normals.   Dabei muss man zuerst die Identit\u00e4t des ersten Entity-Objekts angeben. Da ein Objekt mit mehreren anderen Objekten gleichzeitig kollidieren kann, muss man die Indexnummer angeben. Dieser Index kann nur von 1 bis CountCollisions reichen."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "X-Koordinate der Kollision" } },
    "code": ""
  },
  "collisiony": {
    "name": "CollisionY",
    "description": {
      "en": "",
      "de": "Die Funktion CollisionY liefert die Y-Koordinate der Kollision. Dabei wird die absolute Koordinate von dem Nullpunkt der 3D-Welt berechnet. Der Befehl CollisionNY berechnet dagegen die Koordinate des Normals.   Dabei muss man zuerst die Identit\u00e4t des ersten Entity-Objekts angeben. Da ein Objekt mit mehreren anderen Objekten gleichzeitig kollidieren kann, muss man die Indexnummer angeben. Dieser Index kann nur von 1 bis CountCollisions reichen."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Y-Koordinate der Kollision" } },
    "code": ""
  },
  "collisionz": {
    "name": "CollisionZ",
    "description": {
      "en": "",
      "de": "Die Funktion CollisionZ liefert die Z-Koordinate der Kollision. Dabei wird die absolute Koordinate von dem Nullpunkt der 3D-Welt berechnet. Der Befehl CollisionNZ berechnet dagegen die Koordinate des Normals.   Dabei muss man zuerst die Identit\u00e4t des ersten Entity-Objekts angeben. Da ein Objekt mit mehreren anderen Objekten gleichzeitig kollidieren kann, muss man die Indexnummer angeben. Dieser Index kann nur von 1 bis CountCollisions reichen."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Z-Koordinate der Kollision" } },
    "code": ""
  },
  "countcollisions": {
    "name": "CountCollisions",
    "description": {
      "en": "",
      "de": "Die Funktion CountCollisions ermittelt die Anzahl der Kollisionen, die seit der letzten UpdateWorld-Anweisung aufgetreten sind.   Gebe die Identit\u00e4t eines Objekts an, das auf Kollision \u00fcberpr\u00fcft werden soll."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Anzahl der Kollisionen wird zur\u00fcckgeliefert." } },
    "code": ""
  },
  "entitybox": {
    "name": "EntityBox",
    "description": {
      "en": "",
      "de": "Die Anweisung EntityBox definiert eine quaderf\u00f6rmige Kollisionsfl\u00e4che f\u00fcr ein Objekt.   In BlitzBasic gibt es zwei definierbare Kollisionsfl\u00e4chen: Quader (EntityBox) und Kugel (EntityRadius). Hat man die Kollisionsfl\u00e4che gew\u00e4hlt, dann kann man noch zus\u00e4tzlich mit dem Befehl EntityType den Kollisionstyp einstellen. Mit dem Befehl Collisions wird die Kollisionspr\u00fcfung aktiviert."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "entitycollided": {
    "name": "EntityCollided",
    "description": {
      "en": "",
      "de": "Die Funktion EntityCollided liefert die Identit\u00e4t eines Objekts zur\u00fcck, das mit einem ausgew\u00e4hlten Objekt kollidiert ist. Wenn nur eine 0 zur\u00fcckgeliefert wird, dann gab es keine Kollision.   Dazu muss man nur die Identit\u00e4t eines Objekts (entity) angeben. Type ist eine einfache Zahl, die mit EntityType gesetzt werden kann. BlitzBasic benutzt diese EntityTypes dann um die Kollision eines Objekts mit anderen zu \u00fcberpr\u00fcfen."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird die Identit\u00e4t eines kollidierten Objekts zur\u00fcckgeliefert. Wird 0 zur\u00fcckgeliefert, dann gab es keine Kollision."
      }
    },
    "code": ""
  },
  "entityradius": {
    "name": "EntityRadius",
    "description": {
      "en": "",
      "de": "Die Anweisung EntityRadius definiert eine kugelf\u00f6rmige (oder ellipsenf\u00f6rmige) Kollisionsfl\u00e4che f\u00fcr ein Objekt.   In BlitzBasic gibt es zwei definierbare Kollisionsfl\u00e4chen: Quader (EntityBox) und Kugel (EntityRadius). Hat man die Kollisionsfl\u00e4che gew\u00e4hlt, dann kann man noch zus\u00e4tzlich mit dem Befehl EntityType den Kollisionstyp einstellen. Mit dem Befehl Collisions wird die Kollisionspr\u00fcfung aktiviert."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "entitytype": {
    "name": "EntityType",
    "description": {
      "en": "",
      "de": "Die Anweisung EntityType stellt den Kollisionstyp eines Objekts ein.   Damit nicht erst alle Objekte auf Kollision \u00fcberpr\u00fcft werden m\u00fcssen (was einen enorm gro\u00dfen Rechenaufwand darstellt), k\u00f6nnen nur bestimmte Kollisionsgruppen ausgew\u00e4hlt werden. Die Gruppe wird mit diesem Befehl definiert, indem jedem Objekt ein Kollisionstyp zugeordnet wird.   Der Parameter \"entity%\" gibt die Identit\u00e4t eines Objekts an. Der Parameter \"typ%\" kann eine beliebige Integerzahl sein.   Wird mit dem optionalen Parameter \"rekursiv%\" der Wert 1 \u00fcbergeben, dann wird allen angef\u00fcgten Objekten (children entity) dieser Kollisionstyp zuweisen. Standardm\u00e4\u00dfig ist es aber 0."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "getentitytype": {
    "name": "GetEntityType",
    "description": {
      "en": "",
      "de": "Die Funktion GetEntityType liefert den Kollisionstyp eines Objekts. Dieser Kollisionstyp kann mit dem Befehl EntityType eingestellt werden.   Damit nicht erst alle Objekte auf Kollision \u00fcberpr\u00fcft werden m\u00fcssen (was einen enorm gro\u00dfen Rechenaufwand darstellt), k\u00f6nnen nur bestimmte Kollisionsgruppen ausgew\u00e4hlt werden. Die Gruppe wird mit dieser Funktion abgefragt."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Kollisionstyp des Objekts" } },
    "code": ""
  },
  "meshesintersect": {
    "name": "MeshesIntersect",
    "description": {
      "en": "",
      "de": "Der Befehl MeshesIntersect pr\u00fcft, ob zwei Gitterobjekte (mesh) sich gerade kreuzen. Falls dies der Fall ist, dann wird der Wert 1 zur\u00fcckgeliefert. Andernfalls wird nur 0 zur\u00fcckgeliefert."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "0=keine Kollision  1=Kollision" } },
    "code": ""
  },
  "resetentity": {
    "name": "ResetEntity",
    "description": {
      "en": "",
      "de": "Die Anweisung ResetEntity setzt den Kollisionsstatus eines bestimmten Objekts zur\u00fcck. Dies k\u00f6nnte z.B. dann n\u00fctzlich sein, wenn man ein Objekt mit PositionEntity verschieben m\u00f6chte und dabei nicht mehr auf Kollision getestet werden soll."
    },
    "category": "graphics3d",
    "subCategory": "collisions",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "copyentity": {
    "name": "CopyEntity",
    "description": {
      "en": "",
      "de": "Der Befehl CopyEntity kopiert ein Objekt und liefert sofort die Identit\u00e4t des neuen Objekts zur\u00fcck.   Wurde der Parameter \"parent%\" angegeben, dann wird es zu einem Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.   Das kopierte Objekt wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird es an der Position des Parent-Objekts erstellt."
    },
    "category": "graphics3d",
    "subCategory": "controls",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Neue Identit\u00e4t des kopierten Objekts." } },
    "code": ""
  },
  "entityalpha": {
    "name": "EntityAlpha",
    "description": {
      "en": "",
      "de": "Die Anweisung EntityAlpha \u00e4ndert den Alphawert eines Objekts. Der Alphawert kann nur im Bereich von 0.0 bis 1.0 liegen (1=Standard).   Alpha ist ein Transparenzwert. Dabei bedeutet 1.0=sichtbar und 0.0=unsichtbar. Mit den Werten, die zwischen 0 und 1 liegen, kann man Glas, Eis oder Wasser simulieren.   Der Alphawert 0 kann besonders n\u00fctzlich sein. Blitz3D rendert solche Objekte nicht. Daf\u00fcr kann man es auf Kollision testen. Deshalb ist es anders als HideEntity, welches Kollisionspr\u00fcfung nicht zul\u00e4sst. "
    },
    "category": "graphics3d",
    "subCategory": "controls",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "entityautofade": {
    "name": "EntityAutoFade",
    "description": {
      "en": "",
      "de": "Die Anweisung EntityAutoFade schaltet das automatische Fading ein.   Dazu muss man die Start- und Endentfernung f\u00fcr das Fading angeben. Bis zur Startentfernung erscheint ein Objekt ganz sichtbar. Nach der Endentfernung ist es dagegen ganz unsichtbar. Dazwischen wird ein Objekt je nach Entfernung transparent erscheinen."
    },
    "category": "graphics3d",
    "subCategory": "controls",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "entityblend": {
    "name": "EntityBlend",
    "description": {
      "en": "",
      "de": "Die Anweisung EntityBlend setzt einen anderen Zeichenmodus.   Wird Modus 1 verwendet, so erscheint dieses Objekt ganz normal.   Wird Modus 2 verwendet, so werden die Farben der Objekte unter diesem Objekt dazugemischt.   Wird Modus 3 verwendet, so werden die Farben der Objekte unter diesem Objekt addiert (gut f\u00fcr Lichteffekte). "
    },
    "category": "graphics3d",
    "subCategory": "controls",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "entitycolor": {
    "name": "EntityColor",
    "description": {
      "en": "",
      "de": "Die Anweisung EntityColor w\u00e4hlt eine andere Objektfarbe aus. Die einzelnen Farbanteile k\u00f6nnen nur im Bereich von 0-255 liegen. Die Standardfarbe ist 255,255,255 (=wei\u00df)."
    },
    "category": "graphics3d",
    "subCategory": "controls",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "entityfx": {
    "name": "EntityFX",
    "description": {
      "en": "",
      "de": "Die Anweisung EntityFX weist einem Objekt (entity) bestimmte Effekte zu. Mehrere Effekte k\u00f6nnen kombiniert werden. Dazu muss man nur die einzelnen Werte addieren. Sollen z.B. Effekte 1 und 2 angewendet werden, so muss man den Wert 3 \u00fcbergeben."
    },
    "category": "graphics3d",
    "subCategory": "controls",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "entityorder": {
    "name": "EntityOrder",
    "description": {
      "en": "",
      "de": "Die Anweisung EntityOrder stellt die Sortierreihenfolge f\u00fcr ein Objekts ein.   Dazu muss man zuerst die Identit\u00e4t eines Objekts angeben. Danach folgt der Wert f\u00fcr die Reihenfolge. Bei einem gr\u00f6\u00dferen Wert als 0 erscheint dieses Objekt hinter anderen. Bei einem kleineren Wert als 0 erscheint ein Objekt vor den anderen.   Werte kleiner/gr\u00f6\u00dfer als 0 schalten z buffering aus. Deshalb sollte es nur an einfache, konvexe Objekte angewendet werden (z.B. skybox...).   EntityOrder beeinflusst das angegebene Objekt - aber keine angeh\u00e4ngte Objekte (child entity)."
    },
    "category": "graphics3d",
    "subCategory": "controls",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "entityparent": {
    "name": "EntityParent",
    "description": {
      "en": "",
      "de": "Die Anweisung EntityParent f\u00fcgt ein Objekt an ein anderes Objekt an.   Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.   Mit \"entity%\" wird die Identit\u00e4t eines Objekts angegeben, das zu einem anderen Objekt hinzugef\u00fcgt werden soll.   Mit dem Wert \"parent%\" wird die Identit\u00e4t eines Objekts angegeben, zu dem es hinzuf\u00fcgt werden soll. \"parent%\" kann auch 0 sein. In dem Fall wird es an kein Objekt angef\u00fcgt.   Der optionale Parameter \"global%\" kann entweder 0 oder 1 sein. Bei 0 wird dieses Objekt an die Parent-Position verschoben und entsprechend gedreht. Bei 1 bleibt es an der Stelle, wo es auch vorher war (Standard)"
    },
    "category": "graphics3d",
    "subCategory": "controls",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "entityshininess": {
    "name": "EntityShininess",
    "description": {
      "en": "",
      "de": "Mit diesem Befehl kann man reflektierenden Glanz einem Objekt zuweisen.   Der Wert Glanz sollte nur im Bereich von 0.0 bis 1.0 liegen. Der Standardwert ist 0.   Damit kann man einstellen, wie stark die Reflexion aussehen soll, wenn die Seite einer Fl\u00e4che zur Lichtquelle zeigt.   Beispiel:  Wird einer Kugel (sphere) der Wert 1 zugewiesen, so erscheint es wie eine Billardkugel, wenn das Licht aus richtiger Richtung f\u00e4llt. "
    },
    "category": "graphics3d",
    "subCategory": "controls",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "entitytexture": {
    "name": "EntityTexture",
    "description": {
      "en": "",
      "de": "Die Anweisung EntityTexture weist einem Objekt eine Textur zu.   Der optionale Parameter \"frame%\" muss nur dann angegeben werden, wenn eine geladene Textur mehr als ein Animationsframe enth\u00e4lt. Der Standardwert daf\u00fcr ist 0.   Der optionale Parameter \"index%\" gibt an, welcher Texturebene (layer) des Objekts eine Textur zugewiesen werden soll. Einem Objekt k\u00f6nnen mehrere Texturen (0-7) zugewiesen werden. Dies nennt man Multitextur."
    },
    "category": "graphics3d",
    "subCategory": "controls",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "freeentity": {
    "name": "FreeEntity",
    "description": {
      "en": "",
      "de": "Der Befehl FreeEntity l\u00f6scht ein Objekt (Entity).   Das L\u00f6schen eines Entitys \u00fcbernimmt BlitzBasic auch automatisch am Ende des Programms. Trotzdem ist es besser, wenn man es manuell macht. Zudem kann man w\u00e4hrend der Ausf\u00fchrung Objekte l\u00f6schen."
    },
    "category": "graphics3d",
    "subCategory": "controls",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "hideentity": {
    "name": "HideEntity",
    "description": {
      "en": "",
      "de": "Die Anweisung HideEntity schaltet ein Objekt aus - es wird dadurch unsichtbar. Ausgeschaltete Objekte werden zudem nicht auf eine Kollision mit anderen Objekten gepr\u00fcft.   Am Anfang des Programms kann man dadurch beliebige Objekte erstellen. Diese Objekte k\u00f6nnen danach ausgeschaltet werden. Wird ein Objekt ben\u00f6tigt, dann kann es wieder eingeschaltet werden. Dies ist wesentlich besser, als wenn man neue Objekte mitten im Spiel erstellt. Das ist auch der Hauptzweck dieser Anweisung.   Wenn ein Objekt ausgeschaltet wurde, dann wird es nicht mehr auf Kollision \u00fcberpr\u00fcft. Wenn die Kollisionspr\u00fcfung weiterhin aktiviert sein soll, dann sollte man besser EntityAlpha mit Alphawert 0 benutzen. Solche Objekte werden nicht gerendert, aber trotzdem noch auf Kollision \u00fcberpr\u00fcft.   Wenn ein Objekt weitere angeh\u00e4ngte Objekte (child-entitys) hat, dann werden die automatisch ebenfalls deaktiviert."
    },
    "category": "graphics3d",
    "subCategory": "controls",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "showentity": {
    "name": "ShowEntity",
    "description": {
      "en": "",
      "de": "Die Anweisung ShowEntity schaltet ein ausgeschaltetes Objekt wieder ein - es wird dadurch sichtbar. Eingeschaltete Objekte werden zudem auf eine Kollision mit anderen Objekten gepr\u00fcft.   Am Anfang des Programms kann man beliebig viele Objekte erstellen. Diese Objekte k\u00f6nnen danach ausgeschaltet werden. Wird ein Objekt ben\u00f6tigt, dann kann es wieder eingeschaltet werden. Dies ist wesentlich besser, als wenn man neue Objekte mitten im Spiel erstellt. Das ist auch der Hauptzweck dieser Anweisung.   Wenn ein Objekt weitere angeh\u00e4ngte Objekte (child-entitys) hat, dann werden diese ebenfalls automatisch aktiviert."
    },
    "category": "graphics3d",
    "subCategory": "controls",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "ambientlight": {
    "name": "AmbientLight",
    "description": {
      "en": "",
      "de": "Die Anweisung AmbientLight \u00e4ndert die Farbe des Umgebungslichtes. Die einzelnen Farbanteile k\u00f6nnen nur im Bereich von 0-255 liegen. Die Standardfarbe ist 127,127,127 (=grau). Mit der Farbe 0,0,0 wird kein Umgebungslicht angezeigt.   Alle Objekte werden mit dieser Farbe \"beleuchtet\". Wird nur das Umgebungslicht benutzt, so erscheinen die Objekte flach/unecht, da keine Schattierungen hinzugef\u00fcgt werden. "
    },
    "category": "graphics3d",
    "subCategory": "light-shadow",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "createlight": {
    "name": "CreateLight",
    "description": {
      "en": "",
      "de": "Der Befehl CreateLight erstellt eine Lichtquelle und liefert danach die Identit\u00e4t des Lichts zur\u00fcck.   Licht beeinflusst alle Objektfarben innerhalb der Lichtreichweite. Es muss wenigstens ein Licht erstellt werden, da sonst alle 3D-Objekte flach erscheinen.   Der optionale Parameter \"art%\" gibt die Lichtart an. Es gibt 3 verschiedene Lichtquellen:   Der Wert \"1\" ist ein Richtungslicht (directional light). Das funktioniert so \u00e4hnlich wie das Sonnenlicht das auf ein Haus scheint. Alle W\u00e4nde die in gleiche Richtung zeigen, habe die selbe Helligkeit. Die Helligkeit ist von dem Winkel zur Lichtquelle abh\u00e4ngig.   Der Wert \"2\" ist ein Punktlicht (point light). Es funktioniert so wie bei einer Gl\u00fchlampe. Die Helligkeit startet von einem Punkt und breitet sich in alle Richtungen aus. Je weiter die Entfernung, desto dunkler wird es.   Der Wert \"3\" ist ein Spotlicht (spot light). Es ist ein Lichtkegel und funktioniert ungef\u00e4hr so wie eine Taschenlampe. Es startet von einem Punkt und breitet sich in einem Winkel auseinander.   Wurde der Parameter \"parent%\" angegeben, dann wird dieses Licht zu einem Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.   Das Licht wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird es an der Position des Parent-Objekts erstellt."
    },
    "category": "graphics3d",
    "subCategory": "light-shadow",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t des neuen Lichts zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "lightcolor": {
    "name": "LightColor",
    "description": {
      "en": "",
      "de": "Die Anweisung LightColor \u00e4ndert die Farbe einer Lichtquelle.   Die Farbanteile liegen im Bereich von -255 bis +255.  Bei 255,255,255 ist es das hellste Licht.  Bei 0,0,0 bleibt die Lichtquelle unwirksam  Bei -255,-255,-255 wird alles verdunkelt. Das ist bekannt als \"negative Beleuchtung\" und ist f\u00fcr Schatteneffekte n\u00fctzlich."
    },
    "category": "graphics3d",
    "subCategory": "light-shadow",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "lightconeangles": {
    "name": "LightConeAngles",
    "description": {
      "en": "",
      "de": "Die Anweisung LightConeAngles stellt die Kegelwinkel einer Lichtquelle ein. Diese Lichtquelle muss bereits vorher mit CreateLight erstellt worden sein (Lichtart 3). Normalerweise ist der Innenwinkel 0 Grad und Au\u00dfenwinkel 90 Grad."
    },
    "category": "graphics3d",
    "subCategory": "light-shadow",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "lightmesh": {
    "name": "LightMesh",
    "description": {
      "en": "",
      "de": "Die Anweisung LightMesh weist einem Gitterobjekt eine andere Lichtquelle zu. Es wird somit ein Licht simuliert, welches aber gar nicht erstellt wurde ('fake' lighting).   Der Parameter \"mesh%\" ist die Identit\u00e4t eines Gitterobjekts.   Die Parameter \"rot#\",\"gruen#\",\"blau#\" sind Farbanteile des Lichts und liegen im Bereich von 0 bis 255.   Der Parameter \"reichw#\" gibt die maximale Entfernung des Lichts an.   Die Parameter \"x#\",\"y#\",\"z#\" geben die Position des Lichts an. Standardm\u00e4\u00dfig ist es 0,0,0."
    },
    "category": "graphics3d",
    "subCategory": "light-shadow",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "lightrange": {
    "name": "LightRange",
    "description": {
      "en": "",
      "de": "Die Anweisung LightRange setzt die maximale Reichweite des Lichts einer Lichtquelle. Alles au\u00dferhalb dieses Bereichs wird von Lichtquelle nicht beeinflusst.   Der Parameter \"reichw#\" ist ein Wert, welcher am besten durch experimentieren eingestellt werden soll."
    },
    "category": "graphics3d",
    "subCategory": "light-shadow",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "addmesh": {
    "name": "AddMesh",
    "description": {
      "en": "",
      "de": "Die Anweisung AddMesh f\u00fcgt ein Quell-Mesh zu einem Ziel-Mesh hinzu (Mesh=Gitterobjekt).   Ein Mesh besteht nur aus Dreiecken (triangles). Wenn ein Mesh zu einem anderen hinzugef\u00fcgt wird, dann werden einfach alle Dreiecke kopiert.   Quellmesh kann nach dem Zusammenf\u00fcgen einfach gel\u00f6scht werden, da es nicht mehr gebraucht wird. Das Zusammenf\u00fcgen ist dann sinnvoll, wenn die Meshs mit einem Befehl schnell verschoben/gedreht/skaliert werden sollen. "
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "copymesh": {
    "name": "CopyMesh",
    "description": {
      "en": "",
      "de": "Die Funktion CopyMesh kopiert ein Gitterobjekt (mesh) und liefert danach die neue Identit\u00e4t des kopierten Objekts.   Wurde der Parameter \"parent%\" angegeben, dann wird es zu einem Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.   Das kopierte Objekt wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird es an der Position des Parent-Objekts erstellt. "
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Die Identit\u00e4t des neuen Gitterobjekts (mesh) wird zur\u00fcckgeliefert."
      }
    },
    "code": ""
  },
  "createcone": {
    "name": "CreateCone",
    "description": {
      "en": "",
      "de": "Der Befehl CreateCone erstellt ein Kegel-Gitterobjekt und liefert danach die Identit\u00e4t des Kegels zur\u00fcck.   Ein Kegel wird auf der Koordinate 0,0,0 erstellt und hat danach einen Radius von 1.   Der optionale Parameter \"segment%\" gibt die Anzahl der Segmente an. Je h\u00f6her dieser Wert, desto glatter erscheint das Objekt - allerdings ben\u00f6tigt so ein Objekt mehr Polygone. Der Wert kann nur im Bereich von 3-100 liegen. Dies wird nur im Debug-Modus \u00fcberpr\u00fcft. Ein gr\u00f6\u00dferer Wert wird bei ausgeschaltetem Debugger aber akzeptiert. Wird ein viel zu gro\u00dfer Wert \u00fcbergeben, dann kann der Computer sogar abst\u00fcrzen!   Berechnung der Polygonanzahl:  Polygone=Segmente+(Segmente-2)*Boden   4 Segmente: 6 Polygone - Pyramide  8 Segmente: 14 Polygone - minimale Anzahl der Segmente  16 Segmente: 30 Polygone - glatter Kegel (mittlere Entfernung)  32 Segmente: 62 Polygone - glatter Kegel (nahe Entfernung)   Mit dem optionalen Parameter \"boden%\" kann man den Kegelboden ein- oder ausschalten. Ist die Grundfl\u00e4che des Kegels nie sichtbar, dann sollte es unbedingt ausgeschaltet werden - dadurch wird die Polygonanzahl etwas reduziert.   Wurde der Parameter \"parent%\" angegeben, dann wird dieser Kegel zu einem Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.   Der Kegel wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird es an der Position des Parent-Objekts erstellt. "
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t des Kegels zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "createcube": {
    "name": "CreateCube",
    "description": {
      "en": "",
      "de": "Der Befehl CreateCube erstellt ein W\u00fcrfel-Gitterobjekt und liefert die Identit\u00e4t des W\u00fcrfels zur\u00fcck.   Der W\u00fcrfel wird an der Position 0,0,0 erstellt und reicht von -1,-1,-1 bis +1,+1,+1.   Wurde der Parameter \"parent%\" angegeben, dann wird dieser W\u00fcrfel zu einem Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.   Der W\u00fcrfel wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird es an der Position des Parent-Objekts erstellt. "
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t des W\u00fcrfels zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "createcylinder": {
    "name": "CreateCylinder",
    "description": {
      "en": "",
      "de": "Der Befehl CreateCylinder erstellt ein Zylinder-Gitterobjekt und liefert danach die Identit\u00e4t des Zylinders zur\u00fcck.   Ein Zylinder wird auf der Koordinate 0,0,0 erstellt und hat danach einen Radius von 1.   Der optionale Parameter \"segment%\" gibt die Anzahl der Segmente an. Je h\u00f6her dieser Wert, desto glatter erscheint das Objekt - allerdings ben\u00f6tigt so ein Objekt mehr Polygone. Der Wert kann nur im Bereich von 3-100 liegen. Dies wird nur im Debug-Modus \u00fcberpr\u00fcft. Ein gr\u00f6\u00dferer Wert wird bei ausgeschaltetem Debugger aber akzeptiert. Wird ein viel zu gro\u00dfer Wert \u00fcbergeben, dann kann der Computer sogar abst\u00fcrzen!   Berechnung der Polygonanzahl:  Polygone=(Segmente+(Segmente-2)*Boden)*2   3 Segmente: 8 Polygone - Prisma  8 Segmente: 28 Polygone - minimale Anzahl der Segmente  16 Segmente: 60 Polygone - glatter Zylinder (mittlere Entfernung)  32 Segmente: 124 Polygone - glatter Zylinder (nahe Entfernung)   Mit dem optionalen Parameter \"boden%\" kann man den Zylinderboden ein- oder ausschalten. Ist die Grundfl\u00e4che des Zylinders nie sichtbar (oben und unten), dann sollte es unbedingt ausgeschaltet werden - dadurch wird die Polygonanzahl etwas reduziert.   Wurde der Parameter \"parent%\" angegeben, dann wird dieser Zylinder zu einem Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.   Der Zylinder wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird es an der Position des Parent-Objekts erstellt. "
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t des Zylinders zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "createmesh": {
    "name": "CreateMesh",
    "description": {
      "en": "",
      "de": "Der Befehl CreateMesh erstellt ein Gitterobjekt (mesh) und liefert danach die Identit\u00e4t des Objekts zur\u00fcck.   Ein Mesh besteht aus Oberfl\u00e4chen, die noch mit CreateSurface erstellt werden m\u00fcssen. Diese Oberfl\u00e4chen werden dann an einen Mesh angef\u00fcgt. Ein Mesh verbindet somit alle Oberfl\u00e4chen zu einer Einheit.   Weiterhin besteht eine Oberfl\u00e4che aus Dreiecken, die durch Vertexpunkte definiert werden. Dazu muss man erst diese Punkte mit AddVertex definieren und mit AddTriangle verbinden.   Wurde der Parameter \"parent%\" angegeben, dann wird dieses Gitterobjekt zu einem anderen Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.   Ein Mesh wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird es an der Position des Parent-Objekts erstellt."
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t des Gitterobjekts zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "createsphere": {
    "name": "CreateSphere",
    "description": {
      "en": "",
      "de": "Der Befehl CreateSphere erstellt ein Kugel-Gitterobjekt und liefert danach die Identit\u00e4t der Kugel zur\u00fcck.   Eine Kugel wird auf der Koordinate 0,0,0 erstellt und hat danach einen Radius von 1.   Der optionale Parameter \"segment%\" gibt die Anzahl der Segmente an. Je h\u00f6her dieser Wert, desto glatter erscheint das Objekt - allerdings ben\u00f6tigt so ein Objekt mehr Polygone. Der Wert kann nur im Bereich von 2-100 liegen. Dies wird nur im Debug-Modus \u00fcberpr\u00fcft. Ein gr\u00f6\u00dferer Wert wird bei ausgeschaltetem Debugger aber akzeptiert. Wird ein viel zu gro\u00dfer Wert \u00fcbergeben, dann kann der Computer sogar abst\u00fcrzen! Eine Kugel ben\u00f6tigt enorm viele Polygone. Die Polygonanzahl verh\u00e4lt sich exponential zur Segmentanzahl.   Berechnung der Polygonanzahl:  Polygone=(Segmente*2*(Segmente-1))*2   8 Segmente: 224 Polygone - minimale Anzahl der Segmente  16 Segmente: 960 Polygone - glatte Kugel (mittlere Entfernung)  32 Segmente: 3968 Polygone - glatte Kugel (nahe Entfernung)   Wurde der Parameter \"parent%\" angegeben, dann wird diese Kugel zu einem Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.   Die Kugel wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird es an der Position des Parent-Objekts erstellt. "
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t der Kugel zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "fitmesh": {
    "name": "FitMesh",
    "description": {
      "en": "",
      "de": "Der Befehl FitMesh skaliert ein Gitterobjekt (mesh) so, dass es einen bestimmten Quader ausf\u00fcllt. Danach befindet sich dieses Objekt an der Position x#,y#,z# und hat danach bestimmte Abmessungen (breite#, hoehe# und tiefe#)."
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "flipmesh": {
    "name": "FlipMesh",
    "description": {
      "en": "",
      "de": "Der Befehl FlipMesh kehrt alle Dreiecke eines Gitterobjekts um.   Abh\u00e4ngig von der Anordnung der Ecken wird ein Dreieck nur von bestimmter Seite sichtbar. Ein Dreieck hat drei Punkte, die durch Vertex definiert werden. Die Vertexpunkte werden miteinander verbunden v0 bis v2. Ist die Reihenfolge der Punkte im Uhrzeigersinn (relativ zum Betrachter), so ist ein Dreieck sichtbar. Ist die Reihenfolge gegen den Uhrzeigersinn, so bleibt ein Dreieck unsichtbar.   Der Grund f\u00fcr die sichtbaren Dreiecke liegt auf der Hand: Dadurch wird die Anzahl der Dreiecke deutlich reduziert. Zudem wird somit nur die Seite gerendert, die auch tats\u00e4chlich sichtbar sein kann.   Falls nun ein Objekt von innen zu sehen sein soll, dann muss man die Dreiecke nach innen umkehren - mit dem Befehl FlipMesh."
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "loadanimmesh": {
    "name": "LoadAnimMesh",
    "description": {
      "en": "",
      "de": "Die Anweisung LoadAnimMesh l\u00e4dt ein Gitterobjekt. Es k\u00f6nnen nur X-, 3DS- oder B3D-Dateien geladen werden.   Wenn die Datei Information zur Animation des Objekts enth\u00e4lt, dann wird die Animation des Objekts automatisch geladen. Falls dies nicht erw\u00fcnscht ist, dann muss man den Befehl LoadMesh benutzen.   Wurde der Parameter \"parent%\" angegeben, dann wird dieser Mesh zu einem Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.   Das geladene Gitterobjekt wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird es an der Position des Parent-Objekts erstellt."
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t des Gitterobjekts (mesh). Falls eine Null zur\u00fcckgeliefert wird, dann wurde die Datei nicht gefunden."
      }
    },
    "code": ""
  },
  "loadmesh": {
    "name": "LoadMesh",
    "description": {
      "en": "",
      "de": "Die Anweisung LoadMesh l\u00e4dt ein Gitterobjekt. Es k\u00f6nnen nur X-, 3DS- oder B3D-Dateien geladen werden.   Wenn die Datei Information zur Animation des Objekts enth\u00e4lt, dann wird diese Information ignoriert und nur das Objekt geladen. Falls dies nicht erw\u00fcnscht ist, dann muss man den Befehl LoadAnimMesh benutzen.   Wurde der Parameter \"parent%\" angegeben, dann wird dieser Mesh zu einem Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.   Das geladene Gitterobjekt wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird es an der Position des Parent-Objekts erstellt."
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t des Gitterobjekts (mesh). Falls eine Null zur\u00fcckgeliefert wird, dann wurde die Datei nicht gefunden."
      }
    },
    "code": ""
  },
  "meshcullbox": {
    "name": "MeshCullBox",
    "description": {
      "en": "",
      "de": "MeshCullBox erstellt eine Box f\u00fcr ein festgelegtes Objekt. Dadurch ist es m\u00f6glich die Grenze, ab der das bestimmte Objekt gerendert werden soll, zu ver\u00e4ndern. (mesh culling)  Dies ist z.B. wichtig bei Bone animierten Objekten, denn bei diesen wird die Box auf Basis von Frame 0 gemacht, wenn aber diese Pose zb eine stehende Figur mit herunterh\u00e4ngenden Armen ist, wird es sehr h\u00e4ufig zu Fehlern kommen denn der ausgestreckte Arm h\u00e4tte dann keinen Einfluss auf das Renderverhalten was dazu f\u00fchrt das die Figur h\u00e4ufig gar nicht da ist und dann auf einmal der Arm \"mitten im Bild\" erscheinen kann."
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "meshdepth": {
    "name": "MeshDepth",
    "description": {
      "en": "",
      "de": "Die Funktion MeshDepth liefert die Tiefe eines Gitterobjekts (mesh) zur\u00fcck. Dazu muss man nur die Identit\u00e4t eines Objekts angeben. Zus\u00e4tzlich gibt es noch die Befehle MeshHeight (f\u00fcr H\u00f6he) und MeshWidth (f\u00fcr Breite)."
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Tiefe des Gitterobjekts (mesh) wird zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "meshheight": {
    "name": "MeshHeight",
    "description": {
      "en": "",
      "de": "Die Funktion MeshHeight liefert die H\u00f6he eines Gitterobjekts (mesh) zur\u00fcck. Dazu muss man nur die Identit\u00e4t eines Objekts angeben. Zus\u00e4tzlich gibt es noch die Befehle MeshDepth (f\u00fcr Tiefe) und MeshWidth (f\u00fcr Breite)."
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "H\u00f6he des Gitterobjekts (mesh) wird zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "meshwidth": {
    "name": "MeshWidth",
    "description": {
      "en": "",
      "de": "Die Funktion MeshWidth liefert die Breite eines Gitterobjekts (mesh) zur\u00fcck. Dazu muss man nur die Identit\u00e4t eines Objekts angeben. Zus\u00e4tzlich gibt es noch die Befehle MeshDepth (f\u00fcr Tiefe) und MeshHeight (f\u00fcr H\u00f6he)."
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Breite des Gitterobjekts (mesh) wird zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "positionmesh": {
    "name": "PositionMesh",
    "description": {
      "en": "",
      "de": "Die Anweisung PositionMesh verschiebt alle Eckpunkte eines Gitterobjekts um einen bestimmten XYZ-Abstand. Dadurch funktioniert es v\u00f6llig anders als PositionEntity. Bei PositionMesh werden die Gitterpunkte von Objektmitte verschoben. Wenn ein Objekt gedreht wird, dann hat es einen anderen Drehpunkt als vorher. "
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "rotatemesh": {
    "name": "RotateMesh",
    "description": {
      "en": "",
      "de": "Die Anweisung RotateMesh dreht alle Eckpunkte eines Gitterobjekts um einen bestimmten Winkel. Dadurch funktioniert es v\u00f6llig anders als RotateEntity. Bei RotateMesh werden komplett alle Gitterpunkte auf neuen Winkel umgerechnet. "
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "scalemesh": {
    "name": "ScaleMesh",
    "description": {
      "en": "",
      "de": "Die Anweisung ScaleMesh skaliert ein Gitterobjekt (mesh) um einen bestimmten Faktor.   Normalerweise wird jedes Objekt mit Skalierungsfaktor 1 erstellt/geladen. Gibt man nun eine kleine Zahl ein, dann wird dieses Objekt entsprechend verkleinert (0.5=50%). Gibt man dagegen gr\u00f6\u00dferen Wert ein, dann wird es vergr\u00f6\u00dfert (2.0=200%).   Beachte: ScaleMesh funktioniert anders als ScaleEntity und berechnet komplett alle Gitterpunkte um."
    },
    "category": "graphics3d",
    "subCategory": "meshes",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "camerapick": {
    "name": "CameraPick",
    "description": {
      "en": "",
      "de": "Die Funktion CameraPick ermittelt die Identit\u00e4t eines 3D-Objekts an der Koordinate x#,y#. Das Programm berechnet automatisch die 3D-Koordinate und sucht das n\u00e4chste Objekt. "
    },
    "category": "graphics3d",
    "subCategory": "picking",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t des Objekts. Wurde kein Objekt gefunden, so wird nur eine Null zur\u00fcckgeliefert."
      }
    },
    "code": ""
  },
  "entitypick": {
    "name": "EntityPick",
    "description": {
      "en": "",
      "de": "Die Funktion EntityPick liefert die Identit\u00e4t eines Objekts zur\u00fcck, das am n\u00e4chsten zum ausgew\u00e4hlten Objekt liegt.   Der Parameter \"entity%\" gibt die Identit\u00e4t eines Objekts an.   Der Parameter \"reichw#\" stellt die Suchreichweite ein.   Bei diesem Befehl ist die Blickrichtung des Entity-Objekts ganz wichtig. Man kann es sich wie einen Strahl vorstellen. Ber\u00fchrt ein anderes Objekt diesen Blickstrahl, dann wird seine Objektnummer zur\u00fcckgeliefert. "
    },
    "category": "graphics3d",
    "subCategory": "picking",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t des n\u00e4chsten Objekts (welches den Blickstrahl ber\u00fchrt hat)."
      }
    },
    "code": ""
  },
  "entitypickmode": {
    "name": "EntityPickMode",
    "description": {
      "en": "",
      "de": "Die Anweisung EntityPickMode stellt die Auswahlart f\u00fcr ein Objekt ein.   In BlitzBasic gibt es verschiedene Arten von Auswahlm\u00f6glichkeiten (pick mode). Mit EntityPickMode stellt man zuerst den Modus ein. Danach kann ein Objekt mit den Befehlen CameraPick, EntityPick oder LinePickausgew\u00e4hlt werden."
    },
    "category": "graphics3d",
    "subCategory": "picking",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "linepick": {
    "name": "LinePick",
    "description": {
      "en": "",
      "de": "Die Anweisung LinePick ermittelt die Identit\u00e4t des ersten Objekts, welches eine Linie vom Startpunkt zum Endpunkt ber\u00fchrt.   Der Startpunkt der Linie befindet sich an Position x#,y#,z#   Die Abst\u00e4nde der Linie sind dx#, dy# und dz#.   Der Radius einer Linie kann auch eingestellt werden (vergleichbar mit Durchmesser eines Rohrs). "
    },
    "category": "graphics3d",
    "subCategory": "picking",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t des ersten Objekts vom Startpunkt zum Endpunkt." }
    },
    "code": ""
  },
  "pickedentity": {
    "name": "PickedEntity",
    "description": {
      "en": "",
      "de": "Die Funktion PickedEntity liefert die Identit\u00e4t des zuletzt ausgew\u00e4hlten Objekts (entity) zur\u00fcck. Wenn 0 zur\u00fcckgeliefert wird, dann wurde kein Objekt ausgew\u00e4hlt.   Zum Ausw\u00e4hlen m\u00fcssen die Befehle CameraPick, EntityPick oder LinePick vorher ausgef\u00fchrt werden."
    },
    "category": "graphics3d",
    "subCategory": "picking",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird die Identit\u00e4t eines Objekts (entity) zur\u00fcckgeliefert. Bei 0 wurde kein Objekt ausgew\u00e4hlt."
      }
    },
    "code": ""
  },
  "pickednx": {
    "name": "PickedNX",
    "description": {
      "en": "",
      "de": "Die Funktion PickedNX liefert die X-Koordinate eines Normals der letzten Auswahl zur\u00fcck. Die Funktion PickedX berechnet dagegen die absolute Koordinate von dem Nullpunkt der 3D-Welt.   Zum Ausw\u00e4hlen m\u00fcssen die Befehle CameraPick, EntityPick oder LinePick vorher ausgef\u00fchrt werden."
    },
    "category": "graphics3d",
    "subCategory": "picking",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "X-Koordinate des Normals" } },
    "code": ""
  },
  "pickedny": {
    "name": "PickedNY",
    "description": {
      "en": "",
      "de": "Die Funktion PickedNY liefert die Y-Koordinate eines Normals der letzten Auswahl zur\u00fcck. Die Funktion PickedY berechnet dagegen die absolute Koordinate von dem Nullpunkt der 3D-Welt.   Zum Ausw\u00e4hlen m\u00fcssen die Befehle CameraPick, EntityPick oder LinePick vorher ausgef\u00fchrt werden."
    },
    "category": "graphics3d",
    "subCategory": "picking",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Y-Koordinate des Normals" } },
    "code": ""
  },
  "pickednz": {
    "name": "PickedNZ",
    "description": {
      "en": "",
      "de": "Die Funktion PickedNZ liefert die Z-Koordinate eines Normals der letzten Auswahl zur\u00fcck. Die Funktion PickedZ berechnet dagegen die absolute Koordinate von dem Nullpunkt der 3D-Welt.   Zum Ausw\u00e4hlen m\u00fcssen die Befehle CameraPick, EntityPick oder LinePick vorher ausgef\u00fchrt werden."
    },
    "category": "graphics3d",
    "subCategory": "picking",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Z-Koordinate des Normals" } },
    "code": ""
  },
  "pickedsurface": {
    "name": "PickedSurface",
    "description": {
      "en": "",
      "de": "Die Funktion PickedSurface liefert die Indexnummer einer Gitteroberfl\u00e4che (surface) des zuletzt ausgew\u00e4hlten Objekts (entity) zur\u00fcck.   Zum Ausw\u00e4hlen m\u00fcssen die Befehle CameraPick, EntityPick oder LinePick vorher ausgef\u00fchrt werden. "
    },
    "category": "graphics3d",
    "subCategory": "picking",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Liefert die Indexnummer einer Gitteroberfl\u00e4che (surface)." }
    },
    "code": ""
  },
  "pickedtime": {
    "name": "PickedTime",
    "description": {
      "en": "",
      "de": "Die Funktion PickedTime liefert die Zeit zur\u00fcck, die f\u00fcr die letzte Berechnung mit der Funktion CameraPick, EntityPick oder LinePick ben\u00f6tigt wurde."
    },
    "category": "graphics3d",
    "subCategory": "picking",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die ben\u00f6tigte Zeit zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "pickedtriangle": {
    "name": "PickedTriangle",
    "description": {
      "en": "",
      "de": "Die Funktion PickedTriangle liefert die Indexnummer eines Dreiecks des zuletzt ausgew\u00e4hlten Objekts (entity) zur\u00fcck.   Zum Ausw\u00e4hlen m\u00fcssen die Befehle CameraPick, EntityPick oder LinePick vorher ausgef\u00fchrt werden."
    },
    "category": "graphics3d",
    "subCategory": "picking",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Liefert die Indexnummer eines Dreiecks (triangle)." } },
    "code": ""
  },
  "pickedx": {
    "name": "PickedX",
    "description": {
      "en": "",
      "de": "Die Funktion PickedX liefert die X-Koordinate der letzten Auswahl zur\u00fcck. Dabei wird die Koordinate absolut zur 3D-Welt berechnet. Die Funktion PickedNX liefert dagegen die Koordinate des Normals zur\u00fcck.   Zum Ausw\u00e4hlen m\u00fcssen die Befehle CameraPick, EntityPick oder LinePick vorher ausgef\u00fchrt werden."
    },
    "category": "graphics3d",
    "subCategory": "picking",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "X-Koordinate der letzten Auswahl" } },
    "code": ""
  },
  "pickedy": {
    "name": "PickedY",
    "description": {
      "en": "",
      "de": "Die Funktion PickedY liefert die Y-Koordinate der letzten Auswahl zur\u00fcck. Dabei wird die Koordinate absolut zur 3D-Welt berechnet. Die Funktion PickedNY liefert dagegen die Koordinate des Normals zur\u00fcck.   Zum Ausw\u00e4hlen m\u00fcssen die Befehle CameraPick, EntityPick oder LinePick vorher ausgef\u00fchrt werden."
    },
    "category": "graphics3d",
    "subCategory": "picking",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Y-Koordinate der letzten Auswahl" } },
    "code": ""
  },
  "pickedz": {
    "name": "PickedZ",
    "description": {
      "en": "",
      "de": "Die Funktion PickedZ liefert die Z-Koordinate der letzten Auswahl zur\u00fcck. Dabei wird die Koordinate absolut zur 3D-Welt berechnet. Die Funktion PickedNZ liefert dagegen die Koordinate des Normals zur\u00fcck.   Zum Ausw\u00e4hlen m\u00fcssen die Befehle CameraPick, EntityPick oder LinePick vorher ausgef\u00fchrt werden."
    },
    "category": "graphics3d",
    "subCategory": "picking",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Z-Koordinate der letzten Auswahl" } },
    "code": ""
  },
  "countgfxmodes3d": {
    "name": "CountGfxModes3D",
    "description": {
      "en": "",
      "de": "Ermittelt die Anzahl der unterst\u00fctzten 3D-Grafikmodi von der Grafikkarte. Mit Graphics3D kann man einen Grafikbildschirm \u00f6ffnen."
    },
    "category": "graphics3d",
    "subCategory": "screen",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Anzahl der unterst\u00fctzten 3D-Grafikmodi" } },
    "code": ""
  },
  "gfxdriver3d": {
    "name": "GfxDriver3D",
    "description": {
      "en": "",
      "de": "Die Funktion GfxDriver3D pr\u00fcft, ob ein Treiber f\u00fcr 3D geeignet ist. Wenn es 3D-f\u00e4hig ist, dann wird 1, andernfalls wird nur 0 zur\u00fcckgeliefert.   Einige Rechner k\u00f6nnen mehrere Grafikkarten haben - mit unterschiedlichen Treibern. Mit SetGfxDriver kann ein Treiber ausgew\u00e4hlt werden.   Benutze CountGfxDrivers, um die Anzahl der unterschiedlichen Treiber festzustellen."
    },
    "category": "graphics3d",
    "subCategory": "screen",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "0=Der Grafiktreiber ist nicht f\u00fcr 3D geeignet  1=Der Grafiktreiber ist f\u00fcr 3D geeignet"
      }
    },
    "code": ""
  },
  "gfxdrivercaps3d": {
    "name": "GfxDriverCaps3D",
    "description": {
      "en": "",
      "de": "Die Funktion GfxDriverCaps3D ermittelt die F\u00e4higkeiten einer 3D-Grafikkarte. "
    },
    "category": "graphics3d",
    "subCategory": "screen",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "100 = Grafikkarte unterst\u00fctzt alle Standard 3D-Techniken  110 = Grafikkarte ist zus\u00e4tzlich Cubemapping-f\u00e4hig "
      }
    },
    "code": ""
  },
  "gfxmode3d": {
    "name": "GfxMode3D",
    "description": {
      "en": "",
      "de": "Die Funktion GfxMode3D pr\u00fcft, ob ein Grafikmodus f\u00fcr 3D geeignet ist. Wenn es 3D-f\u00e4hig ist, dann wird 1, andernfalls wird nur 0 zur\u00fcckgeliefert.   Benutze CountGfxModes, um die Anzahl der unterst\u00fctzten Aufl\u00f6sungen festzustellen."
    },
    "category": "graphics3d",
    "subCategory": "screen",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "0=Der Grafikmodus ist nicht f\u00fcr 3D geeignet  1=Der Grafikmodus ist f\u00fcr 3D geeignet"
      }
    },
    "code": ""
  },
  "gfxmode3dexists": {
    "name": "GfxMode3DExists",
    "description": {
      "en": "",
      "de": "Diese Funktion \u00fcberpr\u00fcft, ob ein bestimmter Grafikmodus von der Grafikkarte unterst\u00fctzt wird. Im Gegensatz zu GfxModeExists pr\u00fcft diese Funktion auch auf 3D-F\u00e4higkeit."
    },
    "category": "graphics3d",
    "subCategory": "screen",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "0 = FALSE = Dieser Modus wird nicht unterst\u00fctzt  1 = TRUE = Dieser Modus wird unterst\u00fctzt"
      }
    },
    "code": ""
  },
  "graphics3d": {
    "name": "Graphics3D",
    "description": {
      "en": "",
      "de": "Graphics3D ist der wichtigste Grafikbefehl \u00fcberhaupt. Dieser Befehl \u00f6ffnet ein Grafikfenster oder \u00e4ndert die Gr\u00f6\u00dfe des Fensters (Breite, H\u00f6he und Farbtiefe). Die Farbtiefe ist optional und kann weggelassen werden - dann w\u00e4hlt BlitzBasic automatisch die passende Farbtiefe aus. Das Benutzen des Graphics3D-Befehls setzt Color, ClsColor und aktive Grafikbuffer auf die Standardwerte zur\u00fcck. "
    },
    "category": "graphics3d",
    "subCategory": "screen",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "windowed3d": {
    "name": "Windowed3D",
    "description": {
      "en": "",
      "de": "Die Funktion Windowed3D pr\u00fcft, ob die 3D-Grafikausgabe in einem Fenster und nicht im Vollbildmodus erfolgen kann.   Einige Grafikkarten haben gro\u00dfe Probleme damit, die 3D-Grafik in einem Fenster anzuzeigen. Darum sollte man es vorher mit dieser Funktion pr\u00fcfen. Im Vollbildmodus gibt es dagegen fast nie Probleme.   Wenn Fenstermodus unterst\u00fctzt wird, dann wird 1 zur\u00fcckgeliefert. Ansonsten wird nur 0 zur\u00fcckgeliefert."
    },
    "category": "graphics3d",
    "subCategory": "screen",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Wenn Fenstermodus unterst\u00fctzt wird, dann wird 1 zur\u00fcckgeliefert, sonst aber 0."
      }
    },
    "code": ""
  },
  "createsprite": {
    "name": "CreateSprite",
    "description": {
      "en": "",
      "de": "Der Befehl CreateSprite erstellt ein Sprite und liefert danach die Identit\u00e4t des Objekts zur\u00fcck.  Ein Sprite wird auf der Koordinate 0,0,0 erstellt und erstreckt sich \u00fcber -1,-1 bis +1,+1.  Sprites sind flache, quadratische (es kann zu einem Rechteck gestreckt werden) 3D-Objekte.  Ein Sprite besteht nur aus 2 Polygonen - dadurch k\u00f6nnen sehr viele Objekte (z.B. f\u00fcr Explosionen) benutzt werden, ohne dass die Geschwindigkeit stark absinkt. Sprites k\u00f6nnen f\u00fcr 2D-Spiele in 3D-Grafik benutzt werden.  Zu einem Sprite kann Ansicht-Modus mit SpriteViewMode zugewiesen werden. Standardm\u00e4\u00dfig ist es auf 1 eingestellt. Somit wird es immer vor der Kamera dargestellt - egal wie die Drehwinkel sind.  Wurde der Parameter \"Parent\" angegeben, dann wird dieses Sprite zu einem Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.  Das Objekt wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird es an der Position des Parent-Objekts erstellt."
    },
    "category": "graphics3d",
    "subCategory": "sprites",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t des Objekts zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "handlesprite": {
    "name": "HandleSprite",
    "description": {
      "en": "",
      "de": "Die Anweisung HandleSprite \u00e4ndert den Bezugspunkt eines Sprites. Normalerweise ist der Bezugspunkt immer mittig bei Koordinate 0,0. Ein Sprite f\u00e4ngt bei -1,-1 und endet bei +1,+1. "
    },
    "category": "graphics3d",
    "subCategory": "sprites",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "loadsprite": {
    "name": "LoadSprite",
    "description": {
      "en": "",
      "de": "Der Befehl LoadSprite erstellt ein Sprite, l\u00e4dt danach eine Textur und texturiert das Objekt.  Ein Sprite ist nichts anderes als ein Objekt, welches aus nur 2 Dreiecken (triangles) besteht. \u00dcber diese Dreiecke wird eine Textur gezogen. Solche Objekte k\u00f6nnen sehr schnell gerendert werden - z.B. f\u00fcr Partikeleffekte.  Der Parameter \"Datei\" ist der Pfad zu einer Grafikdatei, die die Textur enth\u00e4lt.  Der optionale Parameter \"Modus\" stellt Textureffekte ein. Mehrere Effekte k\u00f6nnen kombiniert werden, indem die Zahlen addiert werden. "
    },
    "category": "graphics3d",
    "subCategory": "sprites",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird die Identit\u00e4t des Sprites zur\u00fcckgeliefert. Wenn eine Null zur\u00fcckgeliefert wird, dann konnte die Grafikdatei nicht geladen werden."
      }
    },
    "code": ""
  },
  "rotatesprite": {
    "name": "RotateSprite",
    "description": {
      "en": "",
      "de": "Die Anweisung RotateSprite dreht ein Sprite auf einen bestimmten absoluten Winkel. Alle Sprites werden nach dem Erstellen auf den Drehwinkel 0 gedreht. G\u00fcltige Winkel sind 0-360 Grad.  Da Sprites wie 2D-Grafiken behandelt werden, sind andere Drehwinkel nicht notwendig. "
    },
    "category": "graphics3d",
    "subCategory": "sprites",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "scalesprite": {
    "name": "ScaleSprite",
    "description": {
      "en": "",
      "de": "Die Anweisung ScaleSprite skaliert ein Sprite auf eine bestimmte absolute Gr\u00f6\u00dfe.  Nach dem Erstellen eines Sprite-Objekts hat es automatisch die Gr\u00f6\u00dfe 1x1. Wenn man einen kleineren Wert als 1 eingibt, dann wird es verkleinert (0.5=50%). Gibt man dagegen einen gr\u00f6\u00dferen Wert ein, dann wird es vergr\u00f6\u00dfert (2.0=200%).  Negative Skalierungsfaktoren sind aber auch m\u00f6glich. Dieses Objekt wird dann in der entsprechenden Achse gespiegelt."
    },
    "category": "graphics3d",
    "subCategory": "sprites",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "spriteviewmode": {
    "name": "SpriteViewMode",
    "description": {
      "en": "",
      "de": "Die Anweisung SpriteViewMode stellt den Darstellungsmodus eines Sprite-Objekts ein.  Ein Sprite ist unabh\u00e4ngig von der Kamera und hat keinerlei Verzerrungen an Bildschirmr\u00e4ndern, die technisch bedingt bei anderen 3D-Modellen auftreten. M\u00f6chte man diese Verzerrung einschalten, dann muss man diesen Befehl benutzen.   Bei Modus 1 ist ein Objekt unabh\u00e4ngig von der Kamera (Standard).  Bei Modus 2 wird ein Sprite genau wie andere 3D-Modelle dargestellt.  Bei Modus 3 zeigt es auf die Kamera: Alle Winkel werden ge\u00e4ndert.  Bei Modus 4 zeigt es auf die Kamera: Pitch-Winkel wird nicht ge\u00e4ndert. "
    },
    "category": "graphics3d",
    "subCategory": "sprites",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "countchildren": {
    "name": "CountChildren",
    "description": {
      "en": "",
      "de": "Die Funktion CountChildren ermittelt die Anzahl der hinzugef\u00fcgten Objekte.   Objekte k\u00f6nnen hierarchisch aufgebaut sein - das bedeutet, dass ein Objekt (z.B. Finger) zu einem anderen Objekt (z.B. Arm) hinzugef\u00fcgt werden kann. Dieser Arm kann wiederum zu einem K\u00f6rper hinzugef\u00fcgt werden. Wird nun dieser K\u00f6rper bewegt, dann werde alle hinzugef\u00fcgten Objekte automatisch mitverschoben."
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Anzahl der angehangenen Objekte" } },
    "code": ""
  },
  "deltapitch": {
    "name": "DeltaPitch",
    "description": {
      "en": "",
      "de": "Die Funktion DeltaPitch berechnet den Winkel, der f\u00fcr eine Drehung eines Objekts zu einem anderen notwendig ist. Dabei wird die Position und die drei Drehwinkel beachtet.   DeltaPitch liefert einen Drehwinkel f\u00fcr die X-Achse. Die zweite Funktion DeltaYaw berechnet einen Drehwinkel f\u00fcr die Y-Achse. Eine dritte Funktion f\u00fcr die Z-Achse ist nicht notwendig!   Gebe einfach die Identit\u00e4t eines Quell-Objekts und die Identit\u00e4t eines Ziel-Objekts ein."
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird ein Winkel in Grad zur\u00fcckgeliefert (X-Achse)" }
    },
    "code": ""
  },
  "deltayaw": {
    "name": "DeltaYaw",
    "description": {
      "en": "",
      "de": "Die Funktion DeltaYaw berechnet den Winkel, der f\u00fcr eine Drehung eines Objekts zu einem anderen notwendig ist. Dabei wird die Position und die drei Drehwinkel beachtet.   DeltaYaw liefert einen Drehwinkel f\u00fcr die Y-Achse. Die zweite Funktion DeltaPitch berechnet einen Drehwinkel f\u00fcr die X-Achse. Eine dritte Funktion f\u00fcr die Z-Achse ist nicht notwendig!   Gebe einfach die Identit\u00e4t eines Quell-Objekts und die Identit\u00e4t eines Ziel-Objekts ein"
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird ein Winkel in Grad zur\u00fcckgeliefert (Y-Achse)" }
    },
    "code": ""
  },
  "entityclass": {
    "name": "EntityClass",
    "description": {
      "en": "",
      "de": "Die Funktion EntityClass liefert die Art eines 3D-Objekts als String zur\u00fcck. Dies funktioniert nur mit Objekten f\u00fcr die 3D-Umgebung."
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird ein String zur\u00fcckgeliefert. Folgende Werte sind m\u00f6glich:   Pivot, Light, Camera, Mirror, Listener, Sprite, Terrain, Plane, Mesh, MD2, BSP"
      }
    },
    "code": ""
  },
  "entitydistance": {
    "name": "EntityDistance",
    "description": {
      "en": "",
      "de": "Die Funktion EntityDistance ermittelt die Entfernung zwischen zwei Entitys. Diese Funktion vereinfacht die Programmierung, da dadurch eine manuelle Berechnung entfallen kann."
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Entfernung zwischen zwei Objekten zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "entityinview": {
    "name": "EntityInView",
    "description": {
      "en": "",
      "de": "Die Funktion EntityInView liefert 1 zur\u00fcck, wenn ein Objekt in einer Kamera sichtbar ist, ansonsten wird 0 zur\u00fcckgeliefert.  Falls ein Gitterobjekt (Mesh) angegeben wurde, dann werden die \u00e4u\u00dfersten Objektpunkte \u00fcberpr\u00fcft. Bei allen anderen Objekten wird nur die Mitte gepr\u00fcft.  Da mehrere Kameras verwendet werden k\u00f6nnen, muss man zus\u00e4tzlich noch die Identit\u00e4t einer Kamera angeben."
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Falls ein Objekt sichtbar ist, dann wird 1 zur\u00fcckgeliefert, sonst 0." }
    },
    "code": ""
  },
  "entityname": {
    "name": "EntityName",
    "description": {
      "en": "",
      "de": "Die Funktion EntityName liefert den Namen eines Objekts zur\u00fcck.   In einem 3D Modelling Programm kann man jedem Objekt einen Namen geben und dann in BlitzBasic auslesen. Zus\u00e4tzlich gibt es noch den Befehl NameEntity. Damit kann man einem Objekt den Namen manuell zuweisen."
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Gibt den Namen des angegebenen Entitys zur\u00fcck." }
    },
    "code": ""
  },
  "entitypitch": {
    "name": "EntityPitch",
    "description": {
      "en": "",
      "de": "Die Funktion EntityPitch ermittelt den Drehwinkel eines Objekts (X-Achse).  Dazu muss man zuerst die Identit\u00e4t eines Entitys angeben. Der optionale Parameter \"Global\" gibt an, ob ein absoluter oder relativer Winkel ausgegeben werden soll. Ein absoluter Winkel ist immer auf das globale 3D-Koordinatensystem ausgerichtet. Ein relativer Winkel ist dagegen abh\u00e4ngig von den Drehwinkeln eines Parent-Objekts.  Siehe auch EntityRoll (Z-Achse) und EntityYaw (Y-Achse)."
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird ein Winkel (in Grad) zur X-Achse zur\u00fcckgeliefert (Nur Winkel -180 bis +180)."
      }
    },
    "code": ""
  },
  "entityroll": {
    "name": "EntityRoll",
    "description": {
      "en": "",
      "de": "Die Funktion EntityRoll ermittelt den Drehwinkel eines Objekts (Z-Achse).  Dazu muss man zuerst die Identit\u00e4t eines Entitys angeben. Der optionale Parameter \"Global\" gibt an, ob ein absoluter oder relativer Winkel ausgegeben werden soll. Ein absoluter Winkel ist immer auf das globale 3D-Koordinatensystem ausgerichtet. Ein relativer Winkel ist dagegen abh\u00e4ngig von den Drehwinkeln eines Parent-Objekts.  Siehe auch EntityPitch (X-Achse) und EntityYaw (Y-Achse)."
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird ein Winkel (in Grad) zur Z-Achse zur\u00fcckgeliefert (Nur Winkel -180 bis +180)."
      }
    },
    "code": ""
  },
  "entityvisible": {
    "name": "EntityVisible",
    "description": {
      "en": "",
      "de": "Die Funktion EntityVisible ermittelt, ob sich zwei Objekte \"sehen\" k\u00f6nnen. Wird 0 zur\u00fcckgeliefert, dann k\u00f6nnen die sich nicht sehen. Wird 1 zur\u00fcckgeliefert, dann k\u00f6nnen die sich sehen.   Gebe als Parameter einfach die Identit\u00e4ten der beiden Objekte an."
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Diese Funktion liefert 1 zur\u00fcck, wenn beide Objekte sich \"sehen\" k\u00f6nnen. Sonst wird aber nur eine 0 zur\u00fcckgeliefert."
      }
    },
    "code": ""
  },
  "entityx": {
    "name": "EntityX",
    "description": {
      "en": "",
      "de": "Die Funktion EntityX ermittelt die X-Koordinate eines Objekts.  Dazu muss man zuerst die Identit\u00e4t eines Entitys angeben. Der optionale Parameter \"Global\" gibt an, ob eine absolute oder relative Koordinate ausgegeben werden soll. Eine absolute Koordinate ist immer auf das globale 3D-Koordinatensystem ausgerichtet. Eine relative Koordinate ist dagegen abh\u00e4ngig von der Position eines Parent-Objekts.  Siehe auch EntityY und EntityZ."
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die X-Koordinate eines Objekts zur\u00fcckgeliefert. " }
    },
    "code": ""
  },
  "entityy": {
    "name": "EntityY",
    "description": {
      "en": "",
      "de": "Die Funktion EntityY ermittelt die Y-Koordinate eines Objekts.   Dazu muss man zuerst die Identit\u00e4t eines Entitys angeben. Der optionale Parameter \"Global\" gibt an, ob eine absolute oder relative Koordinate ausgegeben werden soll. Eine absolute Koordinate ist immer auf das globale 3D-Koordinatensystem ausgerichtet. Eine relative Koordinate ist dagegen abh\u00e4ngig von der Position eines Parent-Objekts. "
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Y-Koordinate eines Objekts zur\u00fcckgeliefert. " }
    },
    "code": ""
  },
  "entityyaw": {
    "name": "EntityYaw",
    "description": {
      "en": "",
      "de": "Die Funktion EntityYaw ermittelt den Drehwinkel eines Objekts (Y-Achse).   Dazu muss man zuerst die Identit\u00e4t eines Objekts (entity) angeben. Der optionale Parameter \"Global\" gibt an, ob ein absoluter oder relativer Winkel ausgegeben werden soll. Ein absoluter Winkel ist immer auf das globale 3D-Koordinatensystem ausgerichtet. Ein relativer Winkel ist dagegen abh\u00e4ngig von den Drehwinkeln eines Parent-Objekts. "
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird ein Winkel (in Grad) der Y-Achse zur\u00fcckgeliefert (Nur Winkel -180 bis +180)."
      }
    },
    "code": ""
  },
  "entityz": {
    "name": "EntityZ",
    "description": {
      "en": "",
      "de": "Die Funktion EntityZ ermittelt die Z-Koordinate eines Objekts.  Dazu muss man zuerst die Identit\u00e4t eines Entitys angeben. Der optionale Parameter \"Global\" gibt an, ob eine absolute oder relative Koordinate ausgegeben werden soll. Eine absolute Koordinate ist immer auf das globale 3D-Koordinatensystem ausgerichtet. Eine relative Koordinate ist dagegen abh\u00e4ngig von der Position eines Parent-Objekts. "
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Z-Koordinate eines Objekts zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "findchild": {
    "name": "FindChild",
    "description": {
      "en": "",
      "de": "Die Funktion FindChild sucht nach einem angef\u00fcgten Objekt.  Dazu muss man zuerst die Identit\u00e4t des Parent-Objekts angeben. Danach muss man den Namen eingeben, nach dem gesucht werden soll, und das einem angef\u00fcgten Objekt geh\u00f6rt.  BlitzBasic sucht nach dem ersten Namen und liefert sofort die Identit\u00e4t des angef\u00fcgten Objekts zur\u00fcck. Falls nichts gefunden wird, dann wird nur eine 0 zur\u00fcckgeliefert."
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird die Identit\u00e4t des gefundenen Objekts als Integerwert zur\u00fcckgeliefert."
      }
    },
    "code": ""
  },
  "getchild": {
    "name": "GetChild",
    "description": {
      "en": "",
      "de": "Die Funktion GetChild liefert die Identit\u00e4t eines Child-Objekts. Es lassen sich beliebig viele Objekte an Parent-Objekte anf\u00fcgen. Wenn nun ein Parent-Objekt verschoben wird, dann werden alle Child-Objekte automatisch verschoben.  Der Parameter \"Entity\" gibt die Identit\u00e4t eines Parent-Objekts an, welches weitere Child-Objekte enth\u00e4lt.  Der Parameter \"Index\" gibt die Nummer des angeh\u00e4ngtes Objekts an. Diese Nummer liegt zwischen 1 und CountChildren."
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t eines Child-Objekts zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "getparent": {
    "name": "GetParent",
    "description": {
      "en": "",
      "de": "Die Funktion GetParent ermittelt das Parent-Objekt eines Entitys. Es lassen sich beliebig viele Objekte an Parent-Objekte anf\u00fcgen. Wenn nun ein Parent-Objekt verschoben wird, dann werden alle Child-Objekte automatisch verschoben.  Wenn man die Identit\u00e4t eines Child-Objekts kennt, dann kann man mit dieser Funktion die Identit\u00e4t des Parent-Objekts ermitteln."
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Identit\u00e4t eines Parent-Objekts" } },
    "code": ""
  },
  "nameentity": {
    "name": "NameEntity",
    "description": {
      "en": "",
      "de": "Die Anweisung NameEntity weist einem Entity einen Name zu. Gib dazu die Identit\u00e4t eines Objekts als Integer und danach den Namen als String an.  Der Name eines Objekts kann mit EntityName wieder ausgelesen werden."
    },
    "category": "graphics3d",
    "subCategory": "status",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "addtriangle": {
    "name": "AddTriangle",
    "description": {
      "en": "",
      "de": "Die Funktion AddTriangle f\u00fcgt ein Dreieck (triangle) zu einer Oberfl\u00e4che (surface) hinzu. Dabei wird die Indexnummer des Dreiecks zur\u00fcckgeliefert (ab 0).   Die v0%-, v1%- und v2%-Parameter sind Indexnummern, die von AddVertex zur\u00fckgegeben werden.   Abh\u00e4ngig von der Anordnung der Ecken wird ein Dreieck nur von bestimmter Seite sichtbar. Ein Dreieck hat drei Punkte, die durch Vertex definiert werden. Die Vertexpunkte werden miteinander verbunden v0 bis v2. Ist die Reihenfolge der Punkte im Uhrzeigersinn (relativ zum Betrachter), so ist ein Dreieck sichtbar. Ist die Reihenfolge gegen den Uhrzeigersinn, so bleibt ein Dreieck unsichtbar. "
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird eine Indexnummer des Dreiecks zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "addvertex": {
    "name": "AddVertex",
    "description": {
      "en": "",
      "de": "Die Funktion AddVertex f\u00fcgt ein Vertex zu einer Oberfl\u00e4che (surface) hinzu. Dabei wird die Indexnummer des Vertex zur\u00fcckgeliefert (ab 0).   Ein Vertex ist ein Punkt in einem 3D-Raum. Dieser Vertex wird dazu benutzt, um aus Punkten Dreiecke zu erstellen. Ohne Vertexpunkte kann man keine Dreiecke erstellen. Dazu sind logischerweise min. drei Punkte notwendig.   Die optionalen Koordinaten u# und v# sind f\u00fcr die Verschiebung der Textur gedacht. Dies funktioniert so: Die untere|linke Texturecke hat die Koordinate 0|0. Die obere|rechte Texturecke hat die Koordinate 1|1. Die Koordinate 0.5|0.5 ist dabei folgerichtig mittig auf der Textur. "
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Indexnummer des Vertex zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "clearsurface": {
    "name": "ClearSurface",
    "description": {
      "en": "",
      "de": "Mit dem Befehl ClearSurace kann man alle Vertexpunkte und/oder Dreiecke in einer Gitteroberfl\u00e4che (surface) l\u00f6schen.   Dies ist dann sinnvoll, wenn Teile eines Meshs (Gitterobjekt) gel\u00f6scht werden sollen.   Nach dem L\u00f6schen kann man Vertexpunkte und Dreiecke wieder erstellen - mit etwas anderer Polygonanzahl (z.B. f\u00fcr dynamic level of detail LOD)."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "countsurfaces": {
    "name": "CountSurfaces",
    "description": {
      "en": "",
      "de": "Die Funktion CountSurfaces ermittelt die Anzahl der Oberfl\u00e4chen (surfaces), die ein Gitterobjekt (mesh) enth\u00e4lt.   Oberfl\u00e4chen sind Teile eines Gitterobjekts. Ein Mesh kann eine Oberfl\u00e4che haben, oder auch viel mehr. Es k\u00f6nnen beliebig viele Oberfl\u00e4chen zu einem Mesh hinzugef\u00fcgt werden."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Anzahl der Oberfl\u00e4chen (surfaces)" } },
    "code": ""
  },
  "counttriangles": {
    "name": "CountTriangles",
    "description": {
      "en": "",
      "de": "Die Funktion CountTriangles ermittelt die Anzahl der Dreiecke (triangles), die eine Oberfl\u00e4che (surface) enth\u00e4lt.   Dreiecke sind Teile einer Oberfl\u00e4che. Eine Oberfl\u00e4che ist dagegen Teil eines Gitterobjekts."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Anzahl der Dreiecke (triangles)" } },
    "code": ""
  },
  "countvertices": {
    "name": "CountVertices",
    "description": {
      "en": "",
      "de": "Die Funktion CountVertices ermittelt die Anzahl der Gitterpunkte (vertices), die eine Oberfl\u00e4che (surface) enth\u00e4lt.   Gitterpunkte sind Teile eines Dreiecks. Dreiecke sind Teile einer Oberfl\u00e4che. Eine Oberfl\u00e4che ist Teil eines Gitterobjekts."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Anzahl der Gitterpunkte (vertices) " } },
    "code": ""
  },
  "createsurface": {
    "name": "CreateSurface",
    "description": {
      "en": "",
      "de": "Der Befehl CreateSurface erstellt eine Oberfl\u00e4che (surface) und liefert danach die Identit\u00e4t der Oberfl\u00e4che zur\u00fcck.   Ein Gitterobjekt (mesh), das mit CreateMesh erstellt wird, hat zuerst noch keinen Inhalt. Es muss mindestens eine Oberfl\u00e4che zu einem Gitterobjekt hinzugef\u00fcgt werden. Es k\u00f6nnen aber auch beliebig viele andere Oberfl\u00e4chen hinzugef\u00fcgt werden (was manchmal sinnvoller sein kann). Diese Oberfl\u00e4chen m\u00fcssen mit CreateSurface erstellt werden.   Weiterhin besteht eine Oberfl\u00e4che aus Dreiecken, die durch Vertexpunkte definiert werden. Dazu muss man erst diese Punkte mit AddVertex definieren und mit AddTriangle verbinden.   Der Parameter \"mesh%\" muss unbedingt angegeben werden, wodurch diese Oberfl\u00e4che dann automatisch zum Mesh hinzugef\u00fcgt wird. Ein Mesh verbindet dadurch alle Oberfl\u00e4chen zu einer Einheit.   Der optionale Parameter \"brush%\" ist die Identit\u00e4t eines Pinsels, das mit CreateBrush erstellt wurde. Dadurch k\u00f6nnen viele Eigenschaften sofort zu einem Objekt zugewiesen werden."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t der Oberfl\u00e4che zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "findsurface": {
    "name": "FindSurface",
    "description": {
      "en": "",
      "de": "Die Funktion FindSurface sucht eine Gitteroberfl\u00e4che (surface) in einem Gitterobjekt (mesh).   Dazu wird zuerst die Identit\u00e4t eines Gitterobjekts (mesh) angegeben. Danach wird die Identit\u00e4t eines Pinsels angegeben.   BlitzBasic versucht nun eine Oberfl\u00e4che zu finden, die den beiden Suchangaben entspricht. Danach wird die Identit\u00e4t der Oberfl\u00e4che zur\u00fcckgeliefert. Wenn nichts gefunden wurde, dann wird nur eine 0 zur\u00fcckgeliefert."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t einer Oberfl\u00e4che zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "getsurface": {
    "name": "GetSurface",
    "description": {
      "en": "",
      "de": "Die Funktion GetSurface ermittelt die Identit\u00e4t einer Gitteroberfl\u00e4che (surface), welche zu einem Gitterobjekt (mesh) geh\u00f6rt.   Der Parameter \"mesh%\" gibt die Identit\u00e4t eines Gitterobjekts an, bei dem die Oberfl\u00e4che gesucht werden soll.   Der Parameter \"index%\" gibt die Nummer der Gitteroberfl\u00e4che an. Diese Nummer liegt zwischen 1 und CountSurfaces."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Identit\u00e4t einer Oberfl\u00e4che (surface)" } },
    "code": ""
  },
  "trianglevertex": {
    "name": "TriangleVertex",
    "description": {
      "en": "",
      "de": "Die Funktion TriangleVertex ermittelt die Indexnummer eines Vertexpunktes. Dazu sind folgende Angaben notwendig: Identit\u00e4t der Gitteroberfl\u00e4che (surface%), Nummer des Dreiecks und Nummer des Dreieckpunktes (0-2). BlitzBasic sucht danach den Vertexpunkt und liefert die Indexnummer zur\u00fcck."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Indexnummer des Vertexpunktes wird zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "updatenormals": {
    "name": "UpdateNormals",
    "description": {
      "en": "",
      "de": "Die Anweisung UpdateNormals berechnet alle \"normals\" eines Gitterobjekts (mesh) neu. Dies ist nur dann notwendig, wenn \"normals\" nicht mit VertexNormal gesetzt wurden. Erst durch diesen Befehl wird ein Gitterobjekt korrekt mit Licht beleuchtet."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "vertexalpha": {
    "name": "VertexAlpha",
    "description": {
      "en": "",
      "de": "Die Funktion VertexAlpha liefert den Alphawert von einem bestimmten Vertexpunkt zur\u00fcck. Jedem Punkt kann Farbe und Alphainformation zugeordnet werden. Schalte FX-Modus 32 ein, um diesen Effekt zu sehen.   Die Anweisung VertexColor kann dagegen Farbe und Alpha \u00e4ndern."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Alphawert des Vertexpunkts." } },
    "code": ""
  },
  "vertexblue": {
    "name": "VertexBlue",
    "description": {
      "en": "",
      "de": "Die Funktion VertexBlue liefert den Blauanteil der Farbe von einem bestimmten Vertexpunkt zur\u00fcck. Jedem Punkt kann eine Farbe zugeordnet werden. Damit man es sehen kann, muss man FX-Modus 2 einschalten.   Die Anweisung VertexColor kann dagegen die Farbe \u00e4ndern."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Blau-Anteil der Farbe eines Vertexpunkts." } },
    "code": ""
  },
  "vertexcolor": {
    "name": "VertexColor",
    "description": {
      "en": "",
      "de": "Die Anweisung VertexColor \u00e4ndert die Farbe eines Vertexpunktes in einer Gitteroberfl\u00e4che (surface).   Jedem Gitterpunkt kann eine Farbe zugewiesen werden. Damit man es sehen kann, muss allerdings FX-Modus 2 aktiviert sein!   Ab Blitz3D 1.82 gibt es Alpha-Parameter. M\u00f6gliche Werte sind 0 (durchsichtig) bis 1 (sichtbar). Damit lassen sich verschiedenste Effekte realisieren (z.B. Autoscheiben oder Cockpitscheiben in einem Modell durchsichtig machen). Hierzu muss allerdings FX-Modus 32 aktiviert sein!"
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "vertexcoords": {
    "name": "VertexCoords",
    "description": {
      "en": "",
      "de": "Die Anweisung VertexCoords \u00e4ndert die Koordinate eines Vertexpunkts.   VertexCoords wird \u00fcblicherweise f\u00fcr \"dynamische mesh deformationen\" benutzt. Dazu wird Vertexpunkt eines Gitterobjekts verschoben. Alle Dreiecke, die mit dem Punkt verbunden sind, werden automatisch ge\u00e4ndert. Dadurch entsteht der Eindruck, dass das Objekt deformiert wird.   Die Anweisung VertexNormal \u00e4ndert dagegen Normal-Koordinaten (f\u00fcr Lichtschattierungen)."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "vertexgreen": {
    "name": "VertexGreen",
    "description": {
      "en": "",
      "de": "Die Funktion VertexGreen liefert den Gr\u00fcnanteil der Farbe von einem bestimmten Vertexpunkt zur\u00fcck. Jedem Punkt kann eine Farbe zugeordnet werden. Damit man es sehen kann, muss man FX-Modus 2 einschalten.   Die Anweisung VertexColor kann dagegen die Farbe \u00e4ndern."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Gr\u00fcn-Anteil der Farbe eines Vertexpunkts." } },
    "code": ""
  },
  "vertexnormal": {
    "name": "VertexNormal",
    "description": {
      "en": "",
      "de": "Die Anweisung VertexNormal \u00e4ndert Normal-Koordinaten eines Vertexpunktes.   Die Funktionen VertexNX, VertexNY und VertexNZ funktionieren umgekehrt - sie liefern die Normal-Koordinaten zur\u00fcck.   Normals werden haupts\u00e4chlich f\u00fcr Lichtschattierungen ben\u00f6tigt."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "vertexnx": {
    "name": "VertexNX",
    "description": {
      "en": "",
      "de": "Die Funktion VertexNX liefert die X-Koordinate eines Normals zur\u00fcck. Mit VertexNormal kann man die Koordinate \u00e4ndern.   Normals werden haupts\u00e4chlich f\u00fcr Lichtschattierungen ben\u00f6tigt."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "X-Koordinate der Normale des Vertex." } },
    "code": ""
  },
  "vertexny": {
    "name": "VertexNY",
    "description": {
      "en": "",
      "de": "Die Funktion VertexNY liefert die Y-Koordinate eines Normals zur\u00fcck. Mit VertexNormal kann man die Koordinate \u00e4ndern.   Normals werden haupts\u00e4chlich f\u00fcr Lichtschattierungen ben\u00f6tigt."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Y-Koordinate der Normale des Vertex." } },
    "code": ""
  },
  "vertexnz": {
    "name": "VertexNZ",
    "description": {
      "en": "",
      "de": "Die Funktion VertexNZ liefert die Z-Koordinate eines Normals zur\u00fcck. Mit VertexNormal kann man die Koordinate \u00e4ndern.   Normals werden haupts\u00e4chlich f\u00fcr Lichtschattierungen ben\u00f6tigt."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Z-Koordinate der Normale des Vertex." } },
    "code": ""
  },
  "vertexred": {
    "name": "VertexRed",
    "description": {
      "en": "",
      "de": "Die Funktion VertexRed liefert den Rotanteil der Farbe von einem bestimmten Vertexpunkt zur\u00fcck. Jedem Punkt kann eine Farbe zugeordnet werden. Damit man es sehen kann, muss man FX-Modus 2 einschalten.   Die Anweisung VertexColor kann dagegen die Farbe \u00e4ndern."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Rot-Anteil der Farbe eines Vertexpunkts." } },
    "code": ""
  },
  "vertextexcoords": {
    "name": "VertexTexCoords",
    "description": {
      "en": "",
      "de": "Die Anweisung VertexTexCoords \u00e4ndert die Texturkoordinate eines Vertexpunktes.   Die Koordinate u# und v# k\u00f6nnen nur Werte 0 bis 1 sein. Koordinate w# ist f\u00fcr sp\u00e4ter reserviert. Parameter \"set%\" gibt den Koordinaten-Set an - sollte nur 0 oder 1 sein."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "vertexu": {
    "name": "VertexU",
    "description": {
      "en": "",
      "de": "Die Funktion VertexU liefert die U-Koordinate eines Vertexpunktes zur\u00fcck. Diese Koordinate entspricht der X-Koordinate einer Textur. Mit VertexTexCoords kann man U-, V- und W-Koordinaten setzten."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "U-Koordinate eines Vertexpunktes (entspricht X-Koordinate der Textur)" }
    },
    "code": ""
  },
  "vertexv": {
    "name": "VertexV",
    "description": {
      "en": "",
      "de": "Die Funktion VertexV liefert die V-Koordinate eines Vertexpunktes zur\u00fcck. Diese Koordinate entspricht der Y-Koordinate einer Textur. Mit VertexTexCoords kann man U-, V- und W-Koordinaten setzten."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "V-Koordinate eines Vertexpunktes (entspricht Y-Koordinate der Textur)" }
    },
    "code": ""
  },
  "vertexw": {
    "name": "VertexW",
    "description": {
      "en": "",
      "de": "Die Funktion VertexW liefert die W-Koordinate eines Vertexpunktes zur\u00fcck. Diese Koordinate entspricht der W-Koordinate einer Textur und ist f\u00fcr sp\u00e4ter reserviert. Normalerweise wird 1 zur\u00fcckgeliefert. Mit VertexTextCoords kann man U-, V- und W-Koordinaten setzten."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "W-Koordinate eines Vertexpunktes" } },
    "code": ""
  },
  "vertexx": {
    "name": "VertexX",
    "description": {
      "en": "",
      "de": "Die Funktion VertexX liefert die X-Koordinate eines Vertexpunktes zur\u00fcck. Diese Koordinate beschreibt die Position des Vertexpunktes von Objektmitte. Die Anweisung VertexCoords kann die Koordinaten eines Vertex \u00e4ndern."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "X-Koordinate des Vertexpunktes wird zur\u00fcckgeliefert (von Objektmitte)." }
    },
    "code": ""
  },
  "vertexy": {
    "name": "VertexY",
    "description": {
      "en": "",
      "de": "Die Funktion VertexY liefert die Y-Koordinate eines Vertexpunktes zur\u00fcck. Diese Koordinate beschreibt die Position des Vertexpunktes von Objektmitte. Die Anweisung VertexCoords kann die Koordinaten eines Vertex \u00e4ndern."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Y-Koordinate des Vertexpunktes wird zur\u00fcckgeliefert (von Objektmitte)." }
    },
    "code": ""
  },
  "vertexz": {
    "name": "VertexZ",
    "description": {
      "en": "",
      "de": "Die Funktion VertexZ liefert die Z-Koordinate eines Vertexpunktes zur\u00fcck. Diese Koordinate beschreibt die Position des Vertexpunktes von Objektmitte. Die Anweisung VertexCoords kann die Koordinaten eines Vertex \u00e4ndern."
    },
    "category": "graphics3d",
    "subCategory": "surfaces",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Z-Koordinate des Vertexpunktes wird zur\u00fcckgeliefert (von Objektmitte)." }
    },
    "code": ""
  },
  "createterrain": {
    "name": "CreateTerrain",
    "description": {
      "en": "",
      "de": "Der Befehl CreateTerrain erstellt ein Terrain und liefert die Identit\u00e4t des Terrains zur\u00fcck.   Das Terrain wird an der Koordinate 0, 0, 0 erstellt. Die Breite und H\u00f6he entsprechen der Teilung.   Ein Terrain ist ein spezielles Objekt, welches level-of-detail (LOD) benutzt. Dadurch sind theoretisch Terrains mit Millionen von Polygonen m\u00f6glich. Dabei werden nahe Terrainstellen sehr detailliert gezeichnet, weite Terrainstellen haben dagegen geringe Details.  Die st\u00e4ndige \"umordnung\" der Polygone ist jedoch deutlich erkennbar - dies ist ein bekannter Nebeneffekt, der dabei auftritt. Dieser \"pop-up\"-Effekt kann jedoch etwas reduziert werden (mit dem Befehl TerrainDetail).   Die Gr\u00f6\u00dfe des Terrains muss eingegeben werden. Dies kann immer nur ein Exponent von 2 sein (z.B. 2,4,8,16,32,64,128,256...).  Wurde der Parameter \"Parent\" angegeben, dann wird dieses Terrain zu einem Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.  Das Terrain wird normalerweise an der Position 0, 0, 0 erstellt. Wurde Parent angegeben, dann wird die an der Position des Parent - Objekts erstellt. "
    },
    "category": "graphics3d",
    "subCategory": "terrain",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t des Terrains zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "loadterrain": {
    "name": "LoadTerrain",
    "description": {
      "en": "",
      "de": "Dieser Befehl l\u00e4dt ein Terrain und liefert die Identit\u00e4t des Terrains zur\u00fcck. Die rote Farbe des Bildes bestimmt dabei die H\u00f6he des Terrains. Das erstellte Terrain hat danach die selbe Gr\u00f6\u00dfe wie das Bild. Die H\u00f6he des Terrains ist 1.  Tipps zur Erstellung eines guten Terrains:  -Gl\u00e4tte das Terrain (Weichzeichnen)  -Reduziere Y-Gr\u00f6\u00dfe des Terrains  -Erh\u00f6he X/Z-Gr\u00f6\u00dfe des Terrains  -Reduziere CameraRange   Wurde der Parameter \"Parent\" angegeben, dann wird dieses Terrain zu einem Objekt hinzugef\u00fcgt. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit.  Das geladene Terrain wird normalerweise an der Position 0,0,0 erstellt. Wurde Parent angegeben, dann wird es an der Position des Parent-Objekts erstellt. "
    },
    "category": "graphics3d",
    "subCategory": "terrain",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Die Identit\u00e4t des Terrains wird zur\u00fcckgeliefert. Wenn eine Null zur\u00fcckgeliefert wird, dann konnte die Grafikdatei nicht geladen werden."
      }
    },
    "code": ""
  },
  "modifyterrain": {
    "name": "ModifyTerrain",
    "description": {
      "en": "",
      "de": "Die Anweisung ModifyTerrain \u00e4ndert die H\u00f6he eines Terrain-Punktes.  Dazu muss man erst die Identit\u00e4t des Terrains angeben. Danach folgt die Koordinate des Punktes. Die H\u00f6he kann nur zwischen 0 (=tief) und 1 (=hoch) sein.  Wenn bei Realtime 1 angegeben wird, dann wird die \u00c4nderung sofort ausgef\u00fchrt. Normalerweise wird das Terrain erst bei RenderWorld aktualisiert (meistens sinnvoller)."
    },
    "category": "graphics3d",
    "subCategory": "terrain",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "terraindetail": {
    "name": "TerrainDetail",
    "description": {
      "en": "",
      "de": "Die Anweisung TerrainDetail setzt die Detailstufe eines Terrains. Ein Terrain ist ein spezielles Objekt, welches level-of-detail (LOD) benutzt. Dadurch sind theoretisch Terrains mit Millionen von Polygonen m\u00f6glich. Dabei werden nahe Terrainstellen sehr detailliert gezeichnet, weite Terrainstellen haben dagegen geringe Details.  Mit TerrainDetail und dem Parameter \"Detail\" kann man die Anzahl der Dreiecke einstellen. Normaler Wert ist 2000.  Der optionale Parameter \"Morph\" kann PopUp's reduzieren und ist absolut zu empfehlen. \u00dcbergebe dazu den Wert 1."
    },
    "category": "graphics3d",
    "subCategory": "terrain",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "terrainheight": {
    "name": "TerrainHeight",
    "description": {
      "en": "",
      "de": "Die Funktion TerrainHeight liefert die H\u00f6he eines Gitterpunktes auf der Koordinate X|Z des ausgew\u00e4hlten Terrains. Dabei kann nur ein Wert von 0 bis 1 zur\u00fcckgeliefert werden. Mit ModifyTerrain kann dieser Punkt dann ge\u00e4ndert werden. Die Funktion TerrainY ist meistens sinnvoller."
    },
    "category": "graphics3d",
    "subCategory": "terrain",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Der H\u00f6henpunkt auf einer Koordinate des Terrains wird zur\u00fcckgeliefert (Werte nur von 0 bis 1)."
      }
    },
    "code": ""
  },
  "terrainshading": {
    "name": "TerrainShading",
    "description": {
      "en": "",
      "de": "Die Anweisung TerrainShading schaltet Schattierungseffekt f\u00fcr ein Terrain ein oder aus. Normalerweise ist dieser Effekt deaktiviert.   Wird Shading angewendet, dann kann es vorkommen, dass die Grafik auf einigen Grafikkarten etwas langsamer berechnet wird und LOD-PopUp's st\u00e4rker wahrgenommen werden. Daf\u00fcr erscheint das Bild echter - und nicht so eben."
    },
    "category": "graphics3d",
    "subCategory": "terrain",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "terrainsize": {
    "name": "TerrainSize",
    "description": {
      "en": "",
      "de": "Die Funktion TerrainSize liefert die Gr\u00f6\u00dfe eines Terrains zur\u00fcck. Die Gr\u00f6\u00dfe ist dabei eine Seite des Quadrats. Dabei entspricht es exakt der Angabe in CreateTerrain oder der Bitmap, die mit LoadTerrain geladen wurde."
    },
    "category": "graphics3d",
    "subCategory": "terrain",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Diese Funktion liefert die Gr\u00f6\u00dfe eines Terrains zur\u00fcck." }
    },
    "code": ""
  },
  "terrainx": {
    "name": "TerrainX",
    "description": {
      "en": "",
      "de": "Die Funktion TerrainX liefert die interpolierte X-Koordinate auf einem Terrain. Dies ist meistens nur dann sinnvoll, wenn das Terrain gedreht ist."
    },
    "category": "graphics3d",
    "subCategory": "terrain",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die interpolierte X-Koordinate des Terrains zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "terrainy": {
    "name": "TerrainY",
    "description": {
      "en": "",
      "de": "Die Funktion TerrainY liefert die interpolierte Y-Koordinate auf einem Terrain.   Ein Terrain hat oft gro\u00dfe H\u00f6henunterschiede. Wenn man die H\u00f6he von einem bestimmten Punkt ermitteln will und ein Objekt entsprechend vertikal verschieben m\u00f6chte, dann muss man die Y-Koordinate mit diesem Befehl ermitteln."
    },
    "category": "graphics3d",
    "subCategory": "terrain",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die interpolierte Y-Koordinate des Terrains zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "terrainz": {
    "name": "TerrainZ",
    "description": {
      "en": "",
      "de": "Die Funktion TerrainZ liefert die interpolierte Z-Koordinate auf einem Terrain. Dies ist meistens nur dann sinnvoll, wenn das Terrain gedreht ist"
    },
    "category": "graphics3d",
    "subCategory": "terrain",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die interpolierte Z-Koordinate des Terrains zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "activetextures": {
    "name": "ActiveTextures",
    "description": {
      "en": "",
      "de": "Die Funktion ActiveTextures ermittelt die Anzahl der Texturen, die sich gerade im Speicher befinden. Es ist dann n\u00fctzlich, wenn ein Programm auf geringeren Speicherverbrauch optimiert werden soll."
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Anzahl an Texturen, die sich gerade im Speicher befinden." }
    },
    "code": ""
  },
  "cleartexturefilters": {
    "name": "ClearTextureFilters",
    "description": {
      "en": "",
      "de": "Die Anweisung ClearTextureFilters l\u00f6scht vorher eingestellte Texturfilter. Dies macht den Befehl TextureFilter r\u00fcckg\u00e4ngig. Mit dem Befehl kann man n\u00e4mlich verschiedene Eigenschaften zu einer Textur zuordnen."
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "createtexture": {
    "name": "CreateTexture",
    "description": {
      "en": "",
      "de": "Der Befehl CreateTexture erstellt eine Textur im Speicher und liefert die Identit\u00e4t der Textur zur\u00fcck.   Die Breite und H\u00f6he in Pixel beschreiben die Gr\u00f6\u00dfe der Textur. Beachte, dass die aktuelle Texturgr\u00f6\u00dfe anders sein kann als die ben\u00f6tigte Gr\u00f6\u00dfe, da Grafikkarten unterschiedliche Texturgr\u00f6\u00dfen verarbeiten k\u00f6nnen.   Der optionale Parameter \"modus%\" stellt Textureffekte ein. Mehrere Effekte k\u00f6nnen kombiniert werden, indem die Zahlen addiert werden. "
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t der Textur zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "freetexture": {
    "name": "FreeTexture",
    "description": {
      "en": "",
      "de": "Der Befehl FreeTexture l\u00f6scht eine Textur. Man kann danach einen neue laden/erstellen.   Das L\u00f6schen einer Textur \u00fcbernimmt BlitzBasic auch automatisch am Ende des Programms. Trotzdem ist es besser, wenn man es manuell macht. Zudem kann man w\u00e4hrend der Ausf\u00fchrung Texturen l\u00f6schen."
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "loadanimtexture": {
    "name": "LoadAnimTexture",
    "description": {
      "en": "",
      "de": "Diese Anweisung l\u00e4dt eine animierte Textur. Es funktioniert eigentlich wie LoadTexture, nur enth\u00e4lt dieses Bild gleich mehrere kleine Texturteile nebeneinander. Jede Textur hat die gleiche Breite und H\u00f6he. Es d\u00fcrfen auch keine L\u00fccken zwischen den Bildern vorkommen. Wenn man die Animation mit EntityTexture zuweist, dann muss man das Animation-Frame angeben.   BlitzBasic kann BMP-, JPG und PNG-Bilder laden.   Der optionale Parameter \"modus%\" stellt Textureffekte ein. Mehrere Effekte k\u00f6nnen kombiniert werden, indem die Zahlen addiert werden. "
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t der geladenen Textur. Wenn eine Null zur\u00fcckgeliefert wird, dann konnte die Grafikdatei nicht geladen werden."
      }
    },
    "code": ""
  },
  "loadtexture": {
    "name": "LoadTexture",
    "description": {
      "en": "",
      "de": "Diese Anweisung l\u00e4dt eine Textur und liefert danach die Identit\u00e4t zur\u00fcck. Diese Textur kann danach auf beliebige Objekte mit dem Befehl EntityTexture gezogen werden.   BlitzBasic kann BMP-, JPG- und PNG-Bilder laden. Au\u00dferdem k\u00f6nnen seit V 1.97 DDS-Texturen geladen werden.   Der optionale Parameter \"modus%\" stellt Textureffekte ein. Mehrere Effekte k\u00f6nnen kombiniert werden, indem die Zahlen addiert werden. "
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t der geladenen Textur. Wenn eine Null zur\u00fcckgeliefert wird, dann konnte die Grafikdatei nicht geladen werden."
      }
    },
    "code": ""
  },
  "positiontexture": {
    "name": "PositionTexture",
    "description": {
      "en": "",
      "de": "Die Anweisung PositionTexture verschiebt eine Textur.   Beachte: Alle Objekte, die diese Textur benutzen, werden danach eine verschobene Textur haben. Dies kann aber auch n\u00fctzlich sein z.B. f\u00fcr Wasserwellen...   F\u00fcr die Parameter u# und v# sollte m\u00f6glichst 0-1 angegeben werden. Sollte ein anderer Wert angegeben werden, dann wird es entsprechend interpoliert."
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "rotatetexture": {
    "name": "RotateTexture",
    "description": {
      "en": "",
      "de": "Die Anweisung RotateTexture dreht eine Textur auf einen bestimmten absoluten Winkel. Jede geladene/erstellte Textur wird zuerst auf den Winkel 0 gedreht. G\u00fcltige Winkel sind 0-360 Grad.   Beachte: Alle Objekte, die diese Textur benutzen, werden danach eine gedrehte Textur haben. Dies kann aber auch n\u00fctzlich sein z.B. f\u00fcr Raucheffekte..."
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "scaletexture": {
    "name": "ScaleTexture",
    "description": {
      "en": "",
      "de": "Die Anweisung ScaleTexture skaliert eine Textur auf eine bestimmte absolute Gr\u00f6\u00dfe.   Normalerweise wird jede Textur mit Skalierungsfaktor 1 erstellt/geladen. Gibt man nun eine kleine Zahl ein, dann wird diese Textur entsprechend verkleinert (0.5=50%). Gibt man dagegen gr\u00f6\u00dferen Wert ein, dann wird die Textur vergr\u00f6\u00dfert (2.0=200%).   Negative Skalierungsfaktoren sind aber auch m\u00f6glich. Diese Textur wird dann entsprechend gespiegelt."
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "setcubeface": {
    "name": "SetCubeFace",
    "description": {
      "en": "",
      "de": "Diese Funktion wird benutzt, um direkt in Cubemap zu zeichnen (f\u00fcr Echtzeitreflexionen). Ansonsten kann eine vorbearbeitete, statische Textur mit LoadTexture und Flag 128 geladen werden.   Funktionsweise: Cubemap besteht in BlitzBasic aus 6 Bildern - f\u00fcr jede W\u00fcrfelseite ein Bild. Die Gr\u00f6\u00dfe muss 32,64,128 usw. sein. Diese Grafiken werden von BlitzBasic automatisch verwaltet - mit einem Unterschied zu normalen Texturen: Man hat immer nur Zugriff auf eine W\u00fcrfelseite. Mit diesem Befehl kann man ganz einfach die W\u00fcrfelseite ausw\u00e4hlen. Nur auf diese Seite wirkt sich Grafik\u00e4nderung aus.   Textur, die mit LoadTexture geladen wird, muss 6 horizontal angeordnete Bilder enthalten - die dann autom. zu den Seiten 0-5 zugewiesen werden.   So kannst du Echtzeitspiegelung machen: Render 6 3D-Grafiken und kopiere diese jeweils auf eine W\u00fcrfelseite. Dies ist jedoch etwas langsam - deaktiviere darum Mip-Mapping oder rendere 1 W\u00fcrfelseite pro Frame. Zus\u00e4tzlich kann Texture-Flag 256 eingeschaltet werden. "
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "setcubemode": {
    "name": "SetCubeMode",
    "description": {
      "en": "",
      "de": "Der Befehl SetCubeMode schaltet Darstellungsmodus einer Cubemap-Textur um. Die Textur muss den Flag 128 haben!   modus% bietet 3 M\u00f6glichkeiten an:   1=Reflective (Standard)  Ein Objekt sieht somit aus, als w\u00fcrde es aus Chrom bestehen - es reflektiert die Umgebung.   2=Projective  Textur wird einfach auf Objekt projiziert. Unbewegte Objekte sehen normal texturiert aus. Bei Rotation wird die Textur nicht mitgedreht - die Textur ist zur 3D-Welt fixiert.   3=Keine Geometrie  Die Geometrie des 3D-Objekts wird ignoriert - w\u00fcrde wie Skybox aussehen (?)."
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "textureblend": {
    "name": "TextureBlend",
    "description": {
      "en": "",
      "de": "Die Anweisung TextureBlend setzt einen bestimmten Effekt f\u00fcr eine Textur.   Die Textur wird immer mit Bildern zusammengemischt, die sich unter der Textur befinden. So wird die Textur 0 mit Objektfarbe zusammengemischt. Textur 1 wird dann mit Textur 0 zusammengemischt usw.   Wenn Multitextur angewendet wird, dann sollte man den Alpha-Flag beim Laden m\u00f6glichst nicht aktivieren. Da solche Texturen unberechenbar sind und unterschiedlich ausgegeben werden!"
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "texturebuffer": {
    "name": "TextureBuffer",
    "description": {
      "en": "",
      "de": "Normalerweise wird die 2D-Grafik auf dem Bildschirm ausgegeben. Dieser Befehl, der zusammen mit SetBuffer verwendet wird, leitet die Grafik in eine Textur um, welche im Speicher abgelegt ist. Es ist sehr praktisch, wenn die Grafik programmiert und nicht geladen wird. "
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Wert, der die Identit\u00e4t der Textur f\u00fcr SetBuffer angibt." }
    },
    "code": ""
  },
  "texturecoords": {
    "name": "TextureCoords",
    "description": {
      "en": "",
      "de": "Die Anweisung TextureCoords \u00e4ndert den Modus f\u00fcr Texturkoordinate. Dies ist selten erforderlich. Modus 0 ist Standard und wird empfohlen... (siehe Beispiel f\u00fcr besseres Verst\u00e4ndnis)"
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "texturefilter": {
    "name": "TextureFilter",
    "description": {
      "en": "",
      "de": "Die Anweisung TextureFilter setzt einen Effektfilter, der nur dann angewendet wird, wenn ein Suchtext im Dateinamen einer zu ladenden Textur vorkommt.   Der optionale Parameter \"modus%\" stellt Textureffekte ein. Mehrere Effekte k\u00f6nnen kombiniert werden, indem die Zahlen addiert werden. "
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "textureheight": {
    "name": "TextureHeight",
    "description": {
      "en": "",
      "de": "Die Funktion TextureHeight liefert die H\u00f6he einer Textur zur\u00fcck. Beachte dabei, dass nur bestimmte Texturgr\u00f6\u00dfen erlaubt sind. Wenn eine Textur geladen/erstellt wird, dann wird die Gr\u00f6\u00dfe auf diese Standardgr\u00f6\u00dfe angepasst. Dadurch k\u00f6nnen unerw\u00fcnschte Streckungen auftreten. Der Speicherverbrauch kann auch steigen."
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "H\u00f6he der Textur in Pixel." } },
    "code": ""
  },
  "texturename": {
    "name": "TextureName",
    "description": {
      "en": "",
      "de": "Die Funktion TextureName liefert den Dateipfad einer Textur, die zuvor geladen wurde.   Um nur den Dateinamen zu erhalten, muss einfach der hintere Teil des Strings bis \"/\" oder bis \"\\\" ausgeschnitten werden."
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Texturname wird zur\u00fcckgeliefert" } },
    "code": ""
  },
  "texturewidth": {
    "name": "TextureWidth",
    "description": {
      "en": "",
      "de": "Die Funktion TextureWidth liefert die Breite einer Textur zur\u00fcck. Beachte dabei, dass nur bestimmte Texturgr\u00f6\u00dfen erlaubt sind. Wenn eine Textur geladen/erstellt wird, dann wird die Gr\u00f6\u00dfe auf diese Standardgr\u00f6\u00dfe angepasst. Dadurch k\u00f6nnen unerw\u00fcnschte Streckungen auftreten. Der Speicherverbrauch kann auch steigen."
    },
    "category": "graphics3d",
    "subCategory": "textures",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Breite der Textur in Pixel." } },
    "code": ""
  },
  "tformedx": {
    "name": "TFormedX",
    "description": {
      "en": "",
      "de": "Die Funktion TFormedX liefert die X-Koordinate der letzten Berechnung, die mit TFormNormal, TFormPoint oder TFormVector ausgef\u00fchrt wurde."
    },
    "category": "graphics3d",
    "subCategory": "coordinates",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "X-Koordinate wird ausgegeben" } },
    "code": ""
  },
  "tformedy": {
    "name": "TFormedY",
    "description": {
      "en": "",
      "de": "Die Funktion TFormedY liefert die Y-Koordinate der letzten Berechnung, die mit TFormNormal, TFormPoint oder TFormVector ausgef\u00fchrt wurde."
    },
    "category": "graphics3d",
    "subCategory": "coordinates",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Y-Koordinate wird ausgegeben" } },
    "code": ""
  },
  "tformedz": {
    "name": "TFormedZ",
    "description": {
      "en": "",
      "de": "Die Funktion TFormedZ liefert die Z-Koordinate der letzten Berechnung, die mit TFormNormal, TFormPoint oder TFormVector ausgef\u00fchrt wurde."
    },
    "category": "graphics3d",
    "subCategory": "coordinates",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Z-Koordinate wird ausgegeben" } },
    "code": ""
  },
  "tformnormal": {
    "name": "TFormNormal",
    "description": {
      "en": "",
      "de": "Die Anweisung TFormNormal wandelt \"Normal\"-Koordinate eines Quell-Objekts zur Ziel-Koordinate um.   Wenn Quelle oder Ziel 0 sind, dann wird die globale Weltkoordinate benutzt.   Das Ergebnis dieser Transformation kann mit TFormedX, TFormedY und TFormedZ ermittelt werden.   Dies funktioniert genau wie TFormVector, nur wird der Vektor zus\u00e4tzlich normalisiert (auf eine L\u00e4nge von 1 gebracht). Z.B. gibt es einen Vektor von (1,2,2). Dieser Vektor hat eine L\u00e4nge von 3 (Wurzel aus 1*1+2*2+2*2). Beim Normalisieren wird darum jede Komponente durch 3 geteilt."
    },
    "category": "graphics3d",
    "subCategory": "coordinates",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "tformpoint": {
    "name": "TFormPoint",
    "description": {
      "en": "",
      "de": "Die Anweisung TFormPoint wandelt \"Punkt\"-Koordinate eines Quell-Objekts zur Ziel-Koordinate um.   Wenn Quelle oder Ziel 0 sind, dann wird die globale Weltkoordinate benutzt.   Das Ergebnis dieser Transformation kann mit TFormedX, TFormedY und TFormedZ ermittelt werden.   Beispiel: Stell dir vor, es wird eine Kugel mit CreateSphere erstellt. \"Nordpol\" ist dann Koordinate 0,1,0. Globale und lokale Koordinaten sind darum zuerst gleich. Wenn nun dieses Objekt verschoben, gedreht oder skaliert wird, dann \u00e4ndert sich die globale Koordinate von diesem Punkt - lokale Koordinate 0,1,0 bleibt jedoch immer unver\u00e4ndert."
    },
    "category": "graphics3d",
    "subCategory": "coordinates",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "tformvector": {
    "name": "TFormVector",
    "description": {
      "en": "",
      "de": "Die Anweisung TFormVector wandelt \"Vector\"-Koordinate eines Quell-Objekts zur Ziel-Koordinate um (\u00e4hlich TFormPoint - nur als Vektor).   Wenn Quelle oder Ziel 0 sind, dann wird die globale Weltkoordinate benutzt.   Das Ergebnis dieser Transformation kann mit TFormedX, TFormedY und TFormedZ ermittelt werden.   Beispiel: Du m\u00f6chtest ein Objekt 1 Schritt nach vorne bewegen (0,0,1). Das kann man so machen: MoveEntity obj,0,0,1. Wie w\u00fcrde das aber als globale Version aussehen, da der Vektor von Objektwinkel abh\u00e4ngig ist. Den Vektor kann man mit diesen Befehlen transformieren (siehe Beispiel). Dann kann ein Objekt auch mit TranslateEntity obj,x,y,z bewegt werden."
    },
    "category": "graphics3d",
    "subCategory": "coordinates",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "changedir": {
    "name": "ChangeDir",
    "description": {
      "en": "",
      "de": "Diese Anweisung wechselt das aktuelle Verzeichnis. Sollte dieses Verzeichnis nicht existieren, so passiert gar nichts. ChangeDir funktioniert somit genau wie der alte DOS-Befehl CD. Um das aktuelle Verzeichnis zu ermitteln, sollte CurrentDir verwendet werden. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "closedir": {
    "name": "CloseDir",
    "description": {
      "en": "",
      "de": "Diese Anweisung schlie\u00dft den Zugriff auf ein Verzeichnis, welches mit ReadDir ge\u00f6ffnet wurde. Das \u00d6ffnen eines Verzeichnisses ist zum Auslesen von Dateinamen gedacht. Benutze NextFile, um die Dateinamen auszulesen. Mit FileSize und FileType k\u00f6nnen weitere Informationen ermittelt werden. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "closefile": {
    "name": "CloseFile",
    "description": {
      "en": "",
      "de": "Diese Anweisung schlie\u00dft den Zugriff auf eine Datei, welche mit OPENFILE, READFILE oder WRITEFILE ge\u00f6ffnet wurde. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "copyfile": {
    "name": "CopyFile",
    "description": {
      "en": "",
      "de": "Kopiert eine beliebige Datei von einem Verzeichnis zum anderen. Beide Angaben m\u00fcssen die Dateinamen enthalten. Eine Pfadangabe ist optional. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "createdir": {
    "name": "CreateDir",
    "description": {
      "en": "",
      "de": "Erstellt ein ganz neues Verzeichnis. Benutze FILETYPE, um festzustellen, ob ein Verzeichnis bereits existiert. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "currentdir": {
    "name": "CurrentDir",
    "description": {
      "en": "",
      "de": "Diese Funktion liefert einen String mit dem aktuellen Pfad zur\u00fcck. Dabei wird der komplette Pfad mit Laufwerkbezeichnung zur\u00fcckgegeben. Ist der String l\u00e4nger als drei Zeichen, so befindet sich kein \"\\\"-Zeichen am Ende. Benutze CHANGEDIR, um in ein anderes Verzeichnis zu wechseln. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Pfad des aktuellen Verzeichnisses (z.B. \"C:\\Programme\\Blitz3d\")" }
    },
    "code": ""
  },
  "deletedir": {
    "name": "DeleteDir",
    "description": {
      "en": "",
      "de": "Dieser Befehl l\u00f6scht ein Verzeichnis. Es funktioniert nur mit leeren Verzeichnissen - also mit den Verzeichnissen, die keine weiteren Dateien mehr enthalten. Wenn sich noch irgendwelche Dateien im Verzeichnis befinden, dann passiert nichts - es erscheint auch keine Fehlermeldung. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "deletefile": {
    "name": "DeleteFile",
    "description": {
      "en": "",
      "de": "Dieser Befehl l\u00f6scht eine Datei. Beachte, dass die Datei bereits existieren muss (\u00fcberpr\u00fcfen mit FILETYPE) und gerade nicht verwendet wird. Sollte das nicht der Fall sein, so passiert gar nichts."
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "eof": {
    "name": "Eof",
    "description": {
      "en": "",
      "de": "Dieser Befehl \u00fcberpr\u00fcft, ob das Ende einer Datei oder eines Datenstreams (das z.B. mit OpenTCPStream ge\u00f6ffnet wurde) bereits erreicht wurde. Dies ist f\u00fcr Daten mit unbekannter Gr\u00f6\u00dfe sehr n\u00fctzlich. Dadurch werden Programmfehler beim Einlesen vermieden. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "-1 = Beim Auslesen kam es zu einem Fehler (wichtig bei Internetverbindungen mit OpenTCPStream)  0 = Dateiende noch nicht erreicht  1 = Dateiende erreicht"
      }
    },
    "code": ""
  },
  "execfile": {
    "name": "ExecFile",
    "description": {
      "en": "",
      "de": "Startet ein anderes, externes Programm. Es k\u00f6nnen beliebige Programme gestartet werden (z.B. Browser, Mediaplayer usw...). Die Ausf\u00fchrung des BlitzBasic-Programms wird solange angehalten, bis das andere Programm wieder beendet wird. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "0=Datei nicht gefunden  1=Datei gefunden " } },
    "code": ""
  },
  "filepos": {
    "name": "FilePos",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die aktuelle Dateiposition von Anfang einer Datei, die mit OpenFile, ReadFile oder WriteFile ge\u00f6ffnet wurde. Dies kann man f\u00fcrs Speichern und Laden verwenden, denn ab dieser Position erfolgt der n\u00e4chste Schreib-/Lesevorgang. Mit SeekFile kann die Dateiposition dagegen verschoben werden.   Dieser Befehl ist besonders f\u00fcr gro\u00dfe Dateien gut geeignet, da sich die Position eines Datensatzes speichern l\u00e4sst. Dadurch k\u00f6nnen die Datens\u00e4tze bequem aktualisiert werden, ohne, dass man die ganze Datei einlesen oder kopieren muss."
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Dateiposition von Anfang der Datei in Byte. Null bedeutet: Anfang der Datei (also Byte 1) usw."
      }
    },
    "code": ""
  },
  "filesize": {
    "name": "FileSize",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die Dateigr\u00f6\u00dfe beliebiger Datei. Es ist f\u00fcr das Kopieren, Speichern und Laden manchmal notwendig zu wissen, wie gro\u00df die Datei eigentlich ist.   Mit den Befehlen FileType und NextFile k\u00f6nnen weitere Informationen ausgelesen werden."
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Dateigr\u00f6\u00dfe in Byte" } },
    "code": ""
  },
  "filetype": {
    "name": "FileType",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt, ob eine bestimmte Datei existiert. Zus\u00e4tzlich kann man auch erfahren, ob es sich um eine Datei oder um ein Verzeichnis handelt. Bei einer Datei wird 1 zur\u00fcckgeliefert. Wenn es aber ein Verzeichnis ist, dann wird 2 zur\u00fcckgeliefert."
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0 = Datei existiert nicht  1 = Datei existiert  2 = Verzeichnis existiert" }
    },
    "code": ""
  },
  "morefiles": {
    "name": "MoreFiles",
    "description": {
      "en": "",
      "de": "Die Funktion MoreFiles ermittelt, ob weitere Dateien mit NextFile ausgelesen werden k\u00f6nnen. Bevor man diesen Befehl anwenden kann, muss man zuerst ReadDir ausf\u00fchren. ReadDir liefert dann eine Identit\u00e4t, die mit diesem Befehl verwendet werden kann. Der Befehl MoreFiles verlangsamt das Auslesen der Daten minimal."
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0 = es folgen keine weitere Dateien  1 = weitere Dateien folgen" }
    },
    "code": ""
  },
  "nextfile": {
    "name": "NextFile",
    "description": {
      "en": "",
      "de": "Diese Dateifunktion ermittelt den n\u00e4chsten Dateieintrag aus einem Verzeichnis. Bevor man diesen Befehl anwenden kann, muss man zuerst ReadDir ausf\u00fchren. ReadDir liefert dann eine Identit\u00e4t, die mit diesem Befehl verwendet werden kann. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "String mit einem Verzeichniseintrag" } },
    "code": ""
  },
  "openfile": {
    "name": "OpenFile",
    "description": {
      "en": "",
      "de": "Dieser Befehl \u00f6ffnet eine Datei f\u00fcr einen Lese- und Schreibzugriff gleichzeitig. Somit kann man eine Datei sehr bequem aktualisieren (z.B. Score-Liste oder Datenbank), ohne, dass eine Kopie davon erstellt werden muss.  Diese Funktion liefert einen Wert, der f\u00fcr weitere Read- und Write-Befehle unbedingt notwendig ist. Wird Null zur\u00fcckgeliefert, dann wurde die Datei nicht gefunden "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t, die f\u00fcr weitere Dateibefehle unbedingt notwendig ist. Wird Null zur\u00fcckgeliefert, dann wurde die Datei nicht gefunden."
      }
    },
    "code": ""
  },
  "readavail": {
    "name": "ReadAvail",
    "description": {
      "en": "",
      "de": "Diese Funktion kann f\u00fcr Datei- und Netzwerkzugriffe benutzt werden. ReadAvail ermittelt dabei die Anzahl der Bytes, die garantiert ausgelesen werden k\u00f6nnen. Wurde eine Datei ge\u00f6ffnet, so liefert diese Funktion die Anzahl der Bytes, die in den Speicher abgelegt wurden. Wenn diese Funktion mit einer Internetverbindung benutzt wird, dann liefert es die Anzahl der Bytes, die \u00fcber das Internet angekommen sind.   Benutze auch Eof. Diese Funktion ermittelt, ob das Ende einer Datei erreicht ist. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Anzahl der Bytes, die garantiert ausgelesen werden k\u00f6nnen" }
    },
    "code": ""
  },
  "readbyte": {
    "name": "ReadByte",
    "description": {
      "en": "",
      "de": "Diese Dateifunktion liest ein Byte (= 8 Bit) aus einer Datei aus. Diese Datei muss vorher mit OpenFile oder ReadFile ge\u00f6ffnet werden. Die m\u00f6glichen Werte liegen nur im Bereich von 0 bis 255. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Byte Wert im Bereich von 0 bis 255" } },
    "code": ""
  },
  "readdir": {
    "name": "ReadDir",
    "description": {
      "en": "",
      "de": "Diese Dateifunktion \u00f6ffnet ein Verzeichnis. Mit dem Befehl NextFile k\u00f6nnen dann Verzeichniseintr\u00e4ge aus diesem Verzeichnis ausgelesen werden. Benutze FileType, um zu bestimmen, ob es sich um eine Datei bzw. ein Verzeichnis handelt. Der Zugriff sollte danach mit dem Befehl CloseDir geschlossen werden.   ReadDir liefert einen Integer-Wert, der f\u00fcr CloseDir und NextFile ben\u00f6tigt wird. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Verzeichnisidentit\u00e4t, die f\u00fcr CloseDir und NextFile ben\u00f6tigt wird. Bei Null wurde dieses Verzeichnis nicht gefunden."
      }
    },
    "code": ""
  },
  "readfile": {
    "name": "ReadFile",
    "description": {
      "en": "",
      "de": "Dieser Befehl \u00f6ffnet eine Datei f\u00fcr einen Lesezugriff. Somit kann man dann Daten (Spielst\u00e4nde, HighScore, Leveldaten) aus einer Datei bequem auslesen.  Diese Funktion liefert einen Wert, der f\u00fcr weitere Read- und Write-Befehle unbedingt notwendig ist. Wird Null zur\u00fcckgeliefert, dann wurde die Datei nicht gefunden. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t, die f\u00fcr weitere Dateibefehle unbedingt notwendig ist. Wird Null zur\u00fcckgeliefert, dann wurde die Datei nicht gefunden."
      }
    },
    "code": ""
  },
  "readfloat": {
    "name": "ReadFloat",
    "description": {
      "en": "",
      "de": "Diese Dateifunktion liest einen Float Wert (= 4 Byte) aus einer Datei aus. Diese Datei muss vorher mit OpenFile oder ReadFile ge\u00f6ffnet werden. Die m\u00f6glichen Werte liegen nur im Bereich von -2 Mrd. bis +2 Mrd."
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Float Wert im Bereich von -2 Mrd. bis +2 Mrd." } },
    "code": ""
  },
  "readint": {
    "name": "ReadInt",
    "description": {
      "en": "",
      "de": "Diese Dateifunktion liest einen Integer Wert (= 4 Byte) aus einer Datei aus. Diese Datei muss vorher mit OpenFile oder ReadFile ge\u00f6ffnet werden. Die m\u00f6glichen Werte liegen nur im Bereich von -2147483648 bis +2147483647. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Integer Wert im Bereich von -2147483648 bis +2147483647" }
    },
    "code": ""
  },
  "readline": {
    "name": "ReadLine",
    "description": {
      "en": "",
      "de": "Diese Dateifunktion liest eine ganze Zeile aus einer Datei aus. Diese Datei muss vorher mit OpenFile oder ReadFile ge\u00f6ffnet werden. Die L\u00e4nge kann unterschiedlich sein. BlitzBasic liest eine Textzeile nur bis zum Return-Zeichen (0Dh) oder dem LineFeed-Zeichen (0Ah) und setzt dann den Cursor auf die n\u00e4chste Zeile."
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Ein String mit unterschiedlich vielen Zeichen." } },
    "code": ""
  },
  "readshort": {
    "name": "ReadShort",
    "description": {
      "en": "",
      "de": "Diese Dateifunktion liest einen Short Wert (= 2 Byte) aus einer Datei aus. Diese Datei muss vorher mit OpenFile oder ReadFile ge\u00f6ffnet werden. Die m\u00f6glichen Werte liegen nur im Bereich von 0 bis 65535."
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Short Wert im Bereich von 0 bis 65535" } },
    "code": ""
  },
  "readstring": {
    "name": "ReadString",
    "description": {
      "en": "",
      "de": "Diese Dateifunktion liest einen \"Datensatz\" aus einer mit OpenFile oder ReadFile ge\u00f6ffneten Datei.   Jeder Datensatz muss eine Integer Kennung (= 4 Byte) haben, die die L\u00e4nge des Textes in Zeichen angibt. Diese Kennung wird vor jedem Text gespeichert. Danach folgt ein String mit dieser L\u00e4nge. Diese Funktion kann nicht auf eine einfache Textdatei angewendet werden, sondern kann nur in Verbindung mit WriteString benutzt werden. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Ein String mit unterschiedlich vielen Zeichen." } },
    "code": ""
  },
  "seekfile": {
    "name": "SeekFile",
    "description": {
      "en": "",
      "de": "Dieser Befehl verschiebt die aktuelle Dateiposition einer Datei. Diese Datei sollte vorher mit OpenFile, ReadFile oder WriteFile ge\u00f6ffnet werden. Diese Befehle liefern dann eine Identit\u00e4t, die f\u00fcr diesen Befehl notwendig ist.  Parameter \"Pos\" gibt die Position ab Anfang der Datei in Byte an. Alle nachfolgende Dateibefehle wie ReadByte oder WriteByte erfolgen ab dieser Position.  Benutze FilePos, um die aktuelle Dateiposition auszulesen. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Position vom Anfang der Datei zur\u00fcckgeliefert (ab 0)." }
    },
    "code": ""
  },
  "writebyte": {
    "name": "WriteByte",
    "description": {
      "en": "",
      "de": "Dieser Dateibefehl speichert ein Byte (= 8 Bit) in eine Datei. Diese Datei muss vorher mit OpenFile oder WriteFile ge\u00f6ffnet werden. Die m\u00f6glichen Werte liegen nur im Bereich von 0 bis 255."
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "writefile": {
    "name": "WriteFile",
    "description": {
      "en": "",
      "de": "Dieser Befehl \u00f6ffnet eine Datei f\u00fcr einen Schreibzugriff. Somit kann man dann beliebige Daten (Spielst\u00e4nde, HighScore, Leveldaten) in eine Datei speichern.   Diese Funktion liefert einen Wert, der f\u00fcr weitere WRITE-Befehle unbedingt notwendig ist. Wird Null zur\u00fcckgeliefert, dann konnte die Datei nicht erstellt werden. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t, die f\u00fcr weitere Dateibefehle unbedingt notwendig ist." }
    },
    "code": ""
  },
  "writefloat": {
    "name": "WriteFloat",
    "description": {
      "en": "",
      "de": "Dieser Dateibefehl speichert einen Floatwert (= 4 Byte) in eine Datei. Diese Datei muss vorher mit OpenFile oder WriteFile ge\u00f6ffnet werden. Die m\u00f6glichen Werte liegen nur im Bereich von -2 Mrd. bis +2 Mrd."
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "writeint": {
    "name": "WriteInt",
    "description": {
      "en": "",
      "de": "Dieser Dateibefehl speichert einen Integerwert (= 4 Byte) in eine Datei. Diese Datei muss vorher mit OpenFile oder WriteFile ge\u00f6ffnet werden. Die m\u00f6glichen Werte liegen nur im Bereich von -2147483648 bis +2147483647."
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "writeline": {
    "name": "WriteLine",
    "description": {
      "en": "",
      "de": "Diese Dateifunktion speichert eine ganze Zeile in eine Datei. Diese Datei muss vorher mit OpenFile oder WriteFile ge\u00f6ffnet werden. Die L\u00e4nge kann unterschiedlich sein. BlitzBasic f\u00fcgt am Ende ein Return-Zeichen (0Dh) ein. Wird diese Zeile ausgelesen, so nur bis zum Return-Zeichen (0Dh) oder dem LineFeed Zeichen (0Ah)."
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "writeshort": {
    "name": "WriteShort",
    "description": {
      "en": "",
      "de": "Dieser Dateibefehl speichert einen Shortwert (= 2 Byte) in eine Datei. Diese Datei muss vorher mit OpenFile oder WriteFile ge\u00f6ffnet werden. Die m\u00f6glichen Werte liegen nur im Bereich von 0 bis 65535."
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "writestring": {
    "name": "WriteString",
    "description": {
      "en": "",
      "de": "Dieser Dateibefehl schreibt einen \"Datensatz\" in eine mit OpenFile oder WriteFile ge\u00f6ffnete Datei.   Jeder Datensatz muss eine Integer Kennung (= 4 Byte) haben, die die L\u00e4nge des Textes in Zeichen angibt. Diese Kennung wird vor jedem Text gespeichert. Danach folgt ein String mit dieser L\u00e4nge. Dieser Befehl kann nur in Verbindung mit ReadString benutzt werden. "
    },
    "category": "data",
    "subCategory": "file-system",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "getjoy": {
    "name": "GetJoy",
    "description": {
      "en": "",
      "de": "Diese Funktion \u00fcberpr\u00fcft, ob ein Joystickknopf gedr\u00fcckt wurde. Es wird dann die Nummer des Knopfs zur\u00fcckgegeben. Wenn 0 zur\u00fcckgegeben wird, wurde kein Knopf gedr\u00fcckt.  Diese Funktion hat den Vorteil gegen\u00fcber JoyHit, dass es alle drei Tasten abfragen kann. "
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Nummer des Joystickknopfs. Wird 0 zur\u00fcckgegeben, wurde kein Knopf gedr\u00fcckt."
      }
    },
    "code": ""
  },
  "flushjoy": {
    "name": "FlushJoy",
    "description": {
      "en": "",
      "de": "Diese Funktion l\u00f6scht alle Tastenbet\u00e4tigungen des Joysticks aus dem internen Puffer."
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "banksize": {
    "name": "BankSize",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die Gr\u00f6\u00dfe eines Speicherfeldes in Byte. Da ein Speicherfeld beliebig gro\u00df sein kann, ist dies eine M\u00f6glichkeit die Gr\u00f6\u00dfe zu ermitteln und evtl. mit ResizeBank zu ver\u00e4ndern."
    },
    "category": "data",
    "subCategory": "bank",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Gr\u00f6\u00dfe des Speicherfeldes in Byte" } },
    "code": ""
  },
  "copybank": {
    "name": "CopyBank",
    "description": {
      "en": "",
      "de": "Dieser Befehl kopiert Daten aus einem Speicherfeld in ein anderes. Ein oder mehrere Felder m\u00fcssen vorher mit CreateBank erstellt werden. CreateBank liefert eine Nummer, die dann mit diesem Befehl benutzt wird. "
    },
    "category": "data",
    "subCategory": "bank",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "createbank": {
    "name": "CreateBank",
    "description": {
      "en": "",
      "de": "Definiert ein neues Speicherfeld. Es funktioniert so \u00e4hnlich wie DIM, muss aber \u00fcber spezielle Peek/Poke-Befehle angesprochen werden. Diese Funktion liefert einen Integerwert, der f\u00fcr weitere Befehle notwendig ist. Mit FreeBank kann dieses Speicherfeld wieder gel\u00f6scht werden. "
    },
    "category": "data",
    "subCategory": "bank",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t der Speicherbank. Wenn eine Null zur\u00fcckgeliefert wird, dann konnte dieses Speicherfeld nicht erstellt werden."
      }
    },
    "code": ""
  },
  "freebank": {
    "name": "FreeBank",
    "description": {
      "en": "",
      "de": "Diese Anweisung l\u00f6scht ein Speicherfeld, welches mit CreateBank erstellt wurde. Dadurch wird mehr Speicher frei. Dies sollte m\u00f6glichst angewendet werden, um den Speicher zu schonen - besonders bei \u00e4lteren Rechnern wird es da kritisch. "
    },
    "category": "data",
    "subCategory": "bank",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "peekbyte": {
    "name": "PeekByte",
    "description": {
      "en": "",
      "de": "Diese Funktion liest ein Byte aus einem Speicherfeld. Ein Speicherfeld wird mit CreateBank erstellt und funktioniert so \u00e4hnlich wie ein Dim-Feld, nur sind die Daten direkt hintereinander gespeichert."
    },
    "category": "data",
    "subCategory": "bank",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird ein Wert zwischen 0 und 255 zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "peekfloat": {
    "name": "PeekFloat",
    "description": {
      "en": "",
      "de": "Diese Funktion liest einen Float-Wert aus einem Speicherfeld aus. Ein Speicherfeld wird mit CreateBank erstellt und funktioniert so \u00e4hnlich wie ein Dim-Feld, nur sind die Daten direkt hintereinander gespeichert."
    },
    "category": "data",
    "subCategory": "bank",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird ein Wert zwischen -2 Mrd. bis +2 Mrd. zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "peekint": {
    "name": "PeekInt",
    "description": {
      "en": "",
      "de": "Diese Funktion liest einen Integer-Wert aus einem Speicherfeld aus. Ein Speicherfeld wird mit CreateBank erstellt und funktioniert so \u00e4hnlich wie ein Dim-Feld, nur sind die Daten direkt hintereinander gespeichert."
    },
    "category": "data",
    "subCategory": "bank",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird ein Wert zwischen -2147483648 bis +2147483647 zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "peekshort": {
    "name": "PeekShort",
    "description": {
      "en": "",
      "de": "Diese Funktion liest einen Short-Wert aus einem Speicherfeld aus. Ein Speicherfeld wird mit CreateBank erstellt und funktioniert so \u00e4hnlich wie ein Dim-Feld, nur sind die Daten direkt hintereinander gespeichert."
    },
    "category": "data",
    "subCategory": "bank",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird ein Wert zwischen 0 bis 65535 zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "pokebyte": {
    "name": "PokeByte",
    "description": {
      "en": "",
      "de": "Dieser Befehl schreibt ein Byte in ein Speicherfeld. Ein Speicherfeld wird mit CreateBank erstellt und funktioniert so \u00e4hnlich wie ein Dim-Feld, nur sind die Daten direkt hintereinander gespeichert."
    },
    "category": "data",
    "subCategory": "bank",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "pokefloat": {
    "name": "PokeFloat",
    "description": {
      "en": "",
      "de": "Dieser Befehl schreibt einen Float-Wert in ein Speicherfeld. Ein Speicherfeld wird mit CreateBank erstellt und funktioniert so \u00e4hnlich wie ein Dim-Feld, nur sind die Daten direkt hintereinander gespeichert."
    },
    "category": "data",
    "subCategory": "bank",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "pokeint": {
    "name": "PokeInt",
    "description": {
      "en": "",
      "de": "Dieser Befehl schreibt einen Integer-Wert in ein Speicherfeld. Ein Speicherfeld wird mit CreateBank erstellt und funktioniert so \u00e4hnlich wie ein Dim-Feld, nur sind die Daten direkt hintereinander gespeichert."
    },
    "category": "data",
    "subCategory": "bank",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "pokeshort": {
    "name": "PokeShort",
    "description": {
      "en": "",
      "de": "Dieser Befehl schreibt einen Short-Wert in ein Speicherfeld. Ein Speicherfeld wird mit CreateBank erstellt und funktioniert so \u00e4hnlich wie ein Dim-Feld, nur sind die Daten direkt hintereinander gespeichert."
    },
    "category": "data",
    "subCategory": "bank",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "readbytes": {
    "name": "ReadBytes",
    "description": {
      "en": "",
      "de": "Dieser Befehl liest Daten aus einer Datei in ein Speicherfeld ein. Die Datei muss vorher mit OpenFile/ReadFile ge\u00f6ffnet, bzw. der Stream mit OpenTCPStream erstellt worden sein. Zudem muss auch ein Speicherfeld mit CreateBank definiert werden. \"Start\" gibt die Startposition in Byte an. Es k\u00f6nnen beliebig viele Bytes eingelesen werden.   Diese Methode wird z.B. f\u00fcr das Einlesen von Levels benutzt. Mit WriteBytes k\u00f6nnen die Daten abgespeichert werden. Benutze Peek/Poke-Befehle, um Daten zu lesen/speichern. "
    },
    "category": "data",
    "subCategory": "bank",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Die Funktion liefert die Anzahl der erfolgreich eingelesenen Bytes zur\u00fcck.  Zus\u00e4tzlich wird die Speicherbank mit den gelesenen Werten gef\u00fcllt."
      }
    },
    "code": ""
  },
  "resizebank": {
    "name": "ResizeBank",
    "description": {
      "en": "",
      "de": "Dieser Befehl \u00e4ndert die Gr\u00f6\u00dfe eines Speicherfeldes. Dieses Speicherfeld muss bereits vorher mit CreateBank erstellt worden sein. CreateBank liefert dann eine Nummer, die mit diesem Befehl benutzt wird.   Die Daten bleiben nach der \u00c4nderung erhalten. Allerdings wird die Speicherbank im Speicher verschoben (was allerdings keine gro\u00dfe Bedeutung hat). Sollte ein kleinerer Wert als vorher angegeben worden sein, so werden die Daten, die hinter der neuen Gr\u00f6\u00dfe liegen, einfach abgeschnitten."
    },
    "category": "data",
    "subCategory": "bank",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "writebytes": {
    "name": "WriteBytes",
    "description": {
      "en": "",
      "de": "Dieser Befehl speichert Daten aus einem Speicherfeld in eine Datei oder sendet sie an einen TCP-Stream. Die Datei muss vorher mit OpenFile/ReadFile ge\u00f6ffnet werden bzw. der TCP-Stream mit OpenTCPStream erstellt worden sein. Zudem muss auch ein Speicherfeld mit CreateBank definiert werden. \"Start\" gibt die Startposition in Byte an. Es k\u00f6nnen beliebig viele Bytes gespeichert werden.   Diese Methode wird z.B. f\u00fcr das Speichern von Levels benutzt. Mit ReadBytes k\u00f6nnen die Daten ausgelesen werden. Benutze Peek/Poke-Befehle, um Daten zu lesen/speichern."
    },
    "category": "data",
    "subCategory": "bank",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Anzahl der Bytes, die erfolgreich geschrieben wurden." }
    },
    "code": ""
  },
  "joydown": {
    "name": "JoyDown",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt, ob ein bestimmter Joystickknopf gedr\u00fcckt wird."
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0 - Der Knopf wird nicht gedr\u00fcckt.  1 - Der Knopf wird gedr\u00fcckt." }
    },
    "code": ""
  },
  "joyhat": {
    "name": "JoyHat",
    "description": { "en": "", "de": "Diese Funktion ermittelt die Stellung des Hats, auch als Cooliehat bekannt." },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird ein Winkel (0-360) zur\u00fcckgegeben, der die Stellung des Hats repr\u00e4sentiert. Ist der Hat nicht vorhanden oder in Grundstellung wird -1 zur\u00fcckgegeben."
      }
    },
    "code": ""
  },
  "joyhit": {
    "name": "JoyHit",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt, wie oft ein Joystickknopf seit dem letzten Aufruf gedr\u00fcckt wurde.   Wenn es darum geht zu ermitteln, ob ein Joystickknopf gedr\u00fcckt wird, benutze JoyDown."
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Die Anzahl der Knopfbet\u00e4tigungen seit dem letzten Aufruf." }
    },
    "code": ""
  },
  "joypitch": {
    "name": "JoyPitch",
    "description": {
      "en": "",
      "de": "JoyPitch ermittelt den Drehwinkel des Joysticks um die X-Achse. Um die anderen Achsen herauszufinden benutze JoyRoll und JoyYaw. "
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Gibt den Winkel (-180 bis 180) zur\u00fcck. Ist die Funktion nicht verf\u00fcgbar, wird -180 zur\u00fcckgegeben."
      }
    },
    "code": ""
  },
  "joyroll": {
    "name": "JoyRoll",
    "description": {
      "en": "",
      "de": "JoyPitch ermittelt den Drehwinkel des Joysticks um die Z-Achse. Um die anderen Achsen herauszufinden benutze JoyPitch und JoyYaw. "
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Gibt den Winkel (-180 bis 180) zur\u00fcck. Ist die Funktion nicht verf\u00fcgbar, wird -180 zur\u00fcckgegeben."
      }
    },
    "code": ""
  },
  "joytype": {
    "name": "JoyType",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die Art des Joysticks, der am Computer angeschlossen ist. Es gibt zwei Typen: digital und analog.  Ein digitaler Joystick kann nur sagen, dass in eine Richtung gelenkt wird, bei einem analogen Joystick kann zus\u00e4tzlich die St\u00e4rke ermittelt werden. So ist es etwa m\u00f6glich nur 50% nach vorne zu dr\u00fccken und dadurch die Spielfigur langsamer laufen zu lassen."
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0 - kein Joystick vorhanden  1 - digitaler Joystick  2 - analoger Joystick" }
    },
    "code": ""
  },
  "joyu": {
    "name": "JoyU",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die U-Koordinate des Joysticks. Der Wert liegt dabei zwischen -1 und +1.  Zus\u00e4tzlich gibt es noch eine Funktion JoyUDir. Damit kann man aber lediglich eine Richtung bestimmen (also -1, 0 oder +1)."
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Gibt die U-Koordinate des Joysticks zur\u00fcck. Ist die Funktion nicht vorhanden wird immer -1 zur\u00fcckgegeben."
      }
    },
    "code": ""
  },
  "joyudir": {
    "name": "JoyUDir",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die U-Koordinate des Joysticks. Der Wert ist dabei -1, 0 oder 1. Zus\u00e4tzlich gibt es noch die Funktion JoyU. Damit kann man eine Richtung feiner ablesen (Kommawerte zwischen -1 und 1)."
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Gibt die U-Koordinate (-1, 0, 1) zur\u00fcck, oder -1 wenn die Funktion nicht unterst\u00fctzt wird."
      }
    },
    "code": ""
  },
  "joyv": {
    "name": "JoyV",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die V-Koordinate des Joysticks. Der Wert liegt dabei zwischen -1 und +1.  Zus\u00e4tzlich gibt es noch eine Funktion JoyVDir. Damit kann man aber lediglich eine Richtung bestimmen (also -1, 0 oder +1)."
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Gibt die V-Koordinate des Joysticks zur\u00fcck. Ist die Funktion nicht vorhanden wird immer -1 zur\u00fcckgegeben."
      }
    },
    "code": ""
  },
  "joyvdir": {
    "name": "JoyVDir",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die V-Koordinate des Joysticks. Der Wert ist dabei -1, 0 oder 1. Zus\u00e4tzlich gibt es noch die Funktion JoyV. Damit kann man eine Richtung feiner ablesen (Kommawerte zwischen -1 und 1)."
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Gibt die V-Koordinate (-1, 0, 1) zur\u00fcck, oder -1 wenn die Funktion nicht unterst\u00fctzt wird."
      }
    },
    "code": ""
  },
  "joywait": {
    "name": "JoyWait",
    "description": {
      "en": "",
      "de": "Diese Funktion stoppt das ganze Programm und wartet so lange, bis ein Joystick-Knopf gedr\u00fcckt wird.  Um w\u00e4hrend der Wartezeit Grafikausgaben oder \u00e4hnliches machen zu k\u00f6nnen. Sollte man deshalb auf eine Alternative (JoyHit) ausweichen. "
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Joystickknopf, der bet\u00e4tigt wurde. Wird 0 zur\u00fcckgeliefert, so gibt es keinen korrekt angeschlossenen Joystick im System."
      }
    },
    "code": ""
  },
  "joyx": {
    "name": "JoyX",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die horizontale Joystick-Koordinate. Der Wert liegt dabei zwischen -1 und +1. Beachte, dass diese Funktion f\u00fcr analoge Joysticks entwickelt wurde, da digitale Joysticks keine Zwischenwerte liefern. Um nur die Richtung zu bestimmen, kann JoyXDir verwendet werden. JoyY und JoyZ erg\u00e4nzen diese Funktion.   Zusatzinformationen"
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Horizontale Joystick-Koordinate, die zwischen -1 (links) und 1 (rechts) liegt."
      }
    },
    "code": ""
  },
  "joyxdir": {
    "name": "JoyXDir",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die horizontale Joystickkoordinate. Der Wert kann nur -1, 0 oder +1 sein. Diese Funktion ist f\u00fcr analoge und digitale Joysticks geeignet. F\u00fcr analoge Joysticks kann auch JoyX benutzt werden. JoyYDir und JoyZDir erg\u00e4nzen diese Funktion."
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Horizontale Joystick-Koordinate (-1=links, 0=mitte, 1=rechts)." }
    },
    "code": ""
  },
  "joyy": {
    "name": "JoyY",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die vertikale Joystick-Koordinate. Der Wert liegt dabei zwischen -1 und +1. Beachte, dass diese Funktion f\u00fcr analoge Joysticks entwickelt wurde, da digitale Joysticks keine Zwischenwerte liefern. Um nur die Richtung zu bestimmen, kann JoyYDir verwendet werden. JoyX und JoyZ erg\u00e4nzen diese Funktion."
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Vertikale Joystick-Koordinate, die zwischen -1 (oben) und 1 (unten) liegt." }
    },
    "code": ""
  },
  "joyyaw": {
    "name": "JoyYaw",
    "description": {
      "en": "",
      "de": "JoyYaw ermittelt den Drehwinkel des Joysticks um die Y-Achse. Um die anderen Achsen herauszufinden benutze JoyPitch und JoyRoll. "
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Gibt den Winkel (-180 bis 180) zur\u00fcck. Ist die Funktion nicht verf\u00fcgbar, wird -180 zur\u00fcckgegeben."
      }
    },
    "code": ""
  },
  "joyydir": {
    "name": "JoyYDir",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die vertikale Joystickkoordinate. Der Wert kann nur -1, 0 oder +1 sein. Diese Funktion ist f\u00fcr analoge und digitale Joysticks geeignet. F\u00fcr analoge Joysticks kann auch JoyY benutzt werden. JoyXDir und JoyZDir erg\u00e4nzen diese Funktion."
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Vertikale Joystick-Koordinate (-1=oben, 0=mitte, 1=unten)." }
    },
    "code": ""
  },
  "joyz": {
    "name": "JoyZ",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die Z-Koordinate des Joysticks. Der Wert liegt dabei zwischen -1 und +1. Beachte, dass diese Funktion f\u00fcr analoge Joysticks entwickelt wurde, da digitale Joysticks keine Zwischenwerte liefern. Um nur die Richtung zu bestimmen, kann JoyZDir verwendet werden. JoyY und JoyY erg\u00e4nzen diese Funktion."
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Z-Koordinate, die zwischen -1 (links) und 1 (rechts) liegt." }
    },
    "code": ""
  },
  "joyzdir": {
    "name": "JoyZDir",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die Z-Koordinate des Joysticks. Der Wert kann nur -1, 0 oder +1 sein. Diese Funktion ist f\u00fcr analoge und digitale Joysticks geeignet. F\u00fcr analoge Joysticks kann auch JoyZ benutzt werden. JoyXDir und JoyYDir erg\u00e4nzen diese Funktion."
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Z-Koordinate des Joysticks (-1 oder 1)." } },
    "code": ""
  },
  "waitjoy": {
    "name": "WaitJoy",
    "description": {
      "en": "",
      "de": "Diese Funktion stoppt das ganze Programm und wartet so lange, bis ein Joystick-Knopf gedr\u00fcckt wird.  Um w\u00e4hrend der Wartezeit Grafikausgaben oder \u00e4hnliches machen zu k\u00f6nnen. Sollte man deshalb auf eine Alternative (JoyHit) ausweichen. "
    },
    "category": "io",
    "subCategory": "gamepad",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Joystickknopf, der bet\u00e4tigt wurde. Wird 0 zur\u00fcckgeliefert, so gibt es keinen korrekt angeschlossenen Joystick im System."
      }
    },
    "code": ""
  },
  "flushmouse": {
    "name": "FlushMouse",
    "description": {
      "en": "",
      "de": "Diese Funktion l\u00f6scht alle noch im internen Puffer vorhandenen Mausklicks."
    },
    "category": "io",
    "subCategory": "mouse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "getmouse": {
    "name": "GetMouse",
    "description": {
      "en": "",
      "de": "Diese Funktion \u00fcberpr\u00fcft, ob eine Maustaste gedr\u00fcckt wurde. Es wird dann die Nummer der Maustaste zur\u00fcckgegeben. Wenn 0 zur\u00fcckgegeben wird, wurde keine Taste gedr\u00fcckt.  Diese Funktion hat den Vorteil gegen\u00fcber MouseHit, dass es alle drei Tasten abfragen kann. "
    },
    "category": "io",
    "subCategory": "mouse",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Die Nummer der Maustaste, die gedr\u00fcckt wurde, oder 0, falls keine Taste gedr\u00fcckt wurde."
      }
    },
    "code": ""
  },
  "hidepointer": {
    "name": "HidePointer",
    "description": {
      "en": "",
      "de": "Wird ein Programm im Fenstermodus gestartet, so erscheint immer der Windows-Mauszeiger, auch wenn man einen eigenen Mauszeiger in sein Programm eingebaut hat. Mit HidePointer kann der Windows-Mauszeiger ausgeschaltet werden. Ist der Zeiger \u00fcber dem Programmfenster, so wird er automatisch ausgeblendet, sonst erscheint er wieder."
    },
    "category": "io",
    "subCategory": "mouse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "mousedown": {
    "name": "MouseDown",
    "description": {
      "en": "",
      "de": "Diese Funktion \u00fcberpr\u00fcft, ob eine Maustaste gedr\u00fcckt wird. Sie gibt True oder False zur\u00fcck."
    },
    "category": "io",
    "subCategory": "mouse",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0 - Die Taste wird nicht gedr\u00fcckt.  1 - Die Taste wird gedr\u00fcckt." }
    },
    "code": ""
  },
  "mousehit": {
    "name": "MouseHit",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt, wie oft eine bestimmte Maustaste seit dem letzten Aufruf gedr\u00fcckt wurde. Dies k\u00f6nnte f\u00fcr manche Spiele bedeutend sein, wo es auf die H\u00e4ufigkeit der Bet\u00e4tigungen ankommt.   Mit MouseDown kann dagegen ermittelt werden, ob eine bestimmte Taste gerade gedr\u00fcckt wird."
    },
    "category": "io",
    "subCategory": "mouse",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Die Anzahl der Tastenbet\u00e4tigungen seit dem letzten Aufruf." }
    },
    "code": ""
  },
  "mousewait": {
    "name": "MouseWait",
    "description": {
      "en": "",
      "de": "Diese Funktion stoppt das ganze Programm und wartet so lange, bis eine Maustaste gedr\u00fcckt wird.  Um w\u00e4hrend der Wartezeit Grafikausgaben oder \u00e4hnliches machen zu k\u00f6nnen. Sollte man deshalb auf eine Alternative mit GetMouse ausweichen. "
    },
    "category": "io",
    "subCategory": "mouse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Die Maustaste, welche bet\u00e4tigt wurde." } },
    "code": ""
  },
  "mousex": {
    "name": "MouseX",
    "description": {
      "en": "",
      "de": "Diese Funktion gibt die X-Koordinate des Mauszeigers zur\u00fcck. Dies wird oft ben\u00f6tigt, da der Standard-Mauszeiger im Vollbildmodus nicht angezeigt wird und man selber einen Mauszeiger malen muss.   F\u00fcr die Y-Koordinate benutze MouseY. "
    },
    "category": "io",
    "subCategory": "mouse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Die X-Koordinate des Mauszeigers." } },
    "code": ""
  },
  "mousexspeed": {
    "name": "MouseXSpeed",
    "description": {
      "en": "",
      "de": "Diese Funktion gibt die Anzahl an Pixeln zur\u00fcck, um die die Maus seit dem letzten Aufruf verschoben wurde.  F\u00fcr die vertikale Bewegung muss MouseYSpeed benutzt werden. "
    },
    "category": "io",
    "subCategory": "mouse",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Die horizontale Verschiebung der Maus in Pixel:  negativ - Bewegung nach links  positiv - Bewegung nach rechts"
      }
    },
    "code": ""
  },
  "mousey": {
    "name": "MouseY",
    "description": {
      "en": "",
      "de": "Diese Funktion gibt die Y-Koordinate des Mauszeigers zur\u00fcck. Dies wird oft ben\u00f6tigt, da der Standard-Mauszeiger im Vollbildmodus nicht angezeigt wird und man selber einen Mauszeiger malen muss.   F\u00fcr die X-Koordinate benutze MouseX. "
    },
    "category": "io",
    "subCategory": "mouse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Die Y-Koordinate des Mauszeigers." } },
    "code": ""
  },
  "mouseyspeed": {
    "name": "MouseYSpeed",
    "description": {
      "en": "",
      "de": "Diese Funktion gibt die Anzahl an Pixeln zur\u00fcck, um die die Maus seit dem letzten Aufruf verschoben wurde.  F\u00fcr die horizontale Bewegung muss MouseXSpeed benutzt werden. "
    },
    "category": "io",
    "subCategory": "mouse",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Die vertikale Verschiebung der Maus in Pixel:  negativ - Bewegung nach oben  positiv - Bewegung nach unten"
      }
    },
    "code": ""
  },
  "mousez": {
    "name": "MouseZ",
    "description": {
      "en": "",
      "de": "Diese Funktion gibt die Position des Maus-Scrollrades zur\u00fcck. Aus diesem Grund funktioniert die Funktion nur mit M\u00e4usen, die auch ein Scrollrad haben. Es ist nicht m\u00f6glich, automatisch herauszufinden, ob ein Scrollrad vorhanden ist.   Mit den Funktionen MouseHit, MouseDown und GetMouse kannst du auch herausfinden, ob das Scrollrad gedr\u00fcckt wurde. Mittels MouseZSpeed kann man den Unterschied zum letzten Aufruf feststellen."
    },
    "category": "io",
    "subCategory": "mouse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Die Position des Maus-Scrollrades" } },
    "code": ""
  },
  "mousezspeed": {
    "name": "MouseZSpeed",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die Positions\u00e4nderung des Scrollrades.  Um die absolute Position des Scrollrades zu ermitteln benutze MouseZ.   Um den Status des Scrollrades zu ermitteln (gedr\u00fcckt oder nicht gedr\u00fcckt) kannst du GetMouse, MouseDown und MouseHit benutzen."
    },
    "category": "io",
    "subCategory": "mouse",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Gibt die Bewegung des Scrollrades seit dem letzten Aufruf zur\u00fcck.  negativ - Bewegung nach unten  positiv - Bewegung nach oben"
      }
    },
    "code": ""
  },
  "movemouse": {
    "name": "MoveMouse",
    "description": { "en": "", "de": "Dieser Befehl verschiebt den Mauszeiger an eine neue Position. " },
    "category": "io",
    "subCategory": "mouse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "showpointer": {
    "name": "ShowPointer",
    "description": {
      "en": "",
      "de": "Die Funktion zeigt einen mit HidePointer versteckten Windows-Mauszeiger wieder an. "
    },
    "category": "io",
    "subCategory": "mouse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "waitmouse": {
    "name": "WaitMouse",
    "description": {
      "en": "",
      "de": "Diese Funktion stoppt das ganze Programm und wartet so lange, bis eine Maustaste gedr\u00fcckt wird.  Um w\u00e4hrend der Wartezeit Grafikausgaben oder \u00e4hnliches machen zu k\u00f6nnen. Sollte man deshalb auf eine Alternative mit GetMouse ausweichen. "
    },
    "category": "io",
    "subCategory": "mouse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Die Maustaste, welche bet\u00e4tigt wurde." } },
    "code": ""
  },
  "flushkeys": {
    "name": "FlushKeys",
    "description": {
      "en": "",
      "de": "Diese Anweisung l\u00f6scht alle Tastaturbet\u00e4tigungen aus dem Speicher. Bei einem Ballerspiel k\u00f6nnte es passieren, dass man sehr oft die Tasten dr\u00fcckt. Wenn man das Spiel verliert, dann bleiben noch einige \"Impulse\" im Speicher gespeichert und man k\u00f6nnte so z.B. ein Men\u00fc ungewollt wegklicken.   Benutze diese Anweisung, vor einer \u00dcberpr\u00fcfung auf Bet\u00e4tigung z.B. vor einem Men\u00fc oder vor dem Start des neuen Levels."
    },
    "category": "io",
    "subCategory": "keyboard",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "getkey": {
    "name": "GetKey",
    "description": {
      "en": "",
      "de": "Diese Funktion liefert den ASCII-Code einer gedr\u00fcckten Taste. Wenn keine Taste gedr\u00fcckt wurde, dann wird nur eine Null zur\u00fcckgeliefert. GetKey funktioniert nicht mit allen Tasten. So werden Alttasten, Shifttasten sowie Strgtasten nicht ber\u00fccksichtigt - f\u00fcr diese Tasten muss man KeyDown/KeyHit verwenden. "
    },
    "category": "io",
    "subCategory": "keyboard",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird ein ASCII-Code der gedr\u00fcckten Taste zur\u00fcckgeliefert. Wenn keine Taste gedr\u00fcckt wurde, dann liefert GetKey nur eine Null zur\u00fcck."
      }
    },
    "code": ""
  },
  "input": {
    "name": "Input",
    "description": {
      "en": "",
      "de": "Dieser Befehl stellt eine einfache Eingaberoutine zur Verf\u00fcgung. Der Benutzer kann dann einen Text, so \u00e4hnlich wie in der DOS-Box, eingeben. Dieser Text wird dann an eine beliebige Variable \u00fcbergeben. Die Eingabe muss mit Return-Taste beendet werden. "
    },
    "category": "io",
    "subCategory": "keyboard",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Ein Stringwert mit dem eingegebenen Text." } },
    "code": ""
  },
  "keydown": {
    "name": "KeyDown",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt, ob eine bestimmte Taste gedr\u00fcckt wird. Dabei wird entweder TRUE=1 f\u00fcr gedr\u00fcckt oder FALSE=0 f\u00fcr nicht gedr\u00fcckt zur\u00fcckgeliefert. Es k\u00f6nnen auch mehrere Tasten bet\u00e4tigt werden. KeyDown arbeitet aber nicht mit den ASCII-Codes, sondern mit speziellen Tastatur-Scancodes.   Mit KeyHit kann man dagegen die Anzahl der Bet\u00e4tigungen einer Taste ermitteln."
    },
    "category": "io",
    "subCategory": "keyboard",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "0 = diese Taste wird nicht gedr\u00fcckt  1 = diese Taste wird gedr\u00fcckt"
      }
    },
    "code": ""
  },
  "keyhit": {
    "name": "KeyHit",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt, wie oft eine bestimmte Taste seit dem letzten Aufruf gedr\u00fcckt wurde. Dies k\u00f6nnte f\u00fcr manche Spiele bedeutend sein, wo es auf die H\u00e4ufigkeit der Bet\u00e4tigungen ankommt. KeyHit arbeitet aber nicht mit den ASCII-Codes, sondern mit speziellen Tastatur-Scancodes.   Mit KeyDown kann dagegen ermittelt werden, ob eine bestimmte Taste gerade gedr\u00fcckt wird. "
    },
    "category": "io",
    "subCategory": "keyboard",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Anzahl der Bet\u00e4tigungen seit dem letzten Aufruf" }
    },
    "code": ""
  },
  "keywait": {
    "name": "KeyWait",
    "description": {
      "en": "",
      "de": "Diese Funktion wartet solange, bis eine Taste bet\u00e4tigt wird. Das ist besonders f\u00fcr einfache Stopps mit der Meldung: \"Hit Any Key\" sinnvoll. Allerdings wird das Programm auch komplett gestoppt - man kann also w\u00e4hrend dieser Zeit keine Grafiken ausgeben (benutze daf\u00fcr GetKey). "
    },
    "category": "io",
    "subCategory": "keyboard",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "ASCII-Code der gedr\u00fcckten Taste" } },
    "code": ""
  },
  "waitkey": {
    "name": "WaitKey",
    "description": {
      "en": "",
      "de": "Diese Funktion wartet solange, bis eine Taste bet\u00e4tigt wird. Das ist besonders f\u00fcr einfache Stopps mit der Meldung: \"Hit Any Key\" sinnvoll. Allerdings wird das Programm auch komplett gestoppt - man kann also w\u00e4hrend dieser Zeit keine Grafiken ausgeben (benutze daf\u00fcr GetKey). "
    },
    "category": "io",
    "subCategory": "keyboard",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "ASCII-Code der gedr\u00fcckten Taste." } },
    "code": ""
  },
  "abs": {
    "name": "Abs",
    "description": {
      "en": "",
      "de": "Diese Funktion wandelt eine negative Zahl zu einer positiven (absoluten). Es wird somit nur das Minuszeichen entfernt. Positive Zahlen bleiben dagegen unver\u00e4ndert."
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Positive Zahl" } },
    "code": ""
  },
  "acos": {
    "name": "ACos",
    "description": {
      "en": "",
      "de": "Diese Funktion berechnet den Winkel aus einem Cosinuswert. Es ist somit die Umkehrfunktion f\u00fcr Cosinus. Mathematiker nennen es ArcusCosinus.   Man kann den Cosinuswert ausrechnen, indem man die Ankathete eines rechtwinkligen Dreiecks durch die Hypotenuse teilt. Aus diesem Wert wird danach der Winkel berechnet.   Zur Erkl\u00e4rung: Ankathete ist die Seite des Dreiecks, die neben dem gesuchten Winkel liegt. Hypotenuse ist die Seite mit der gr\u00f6\u00dften L\u00e4nge. "
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Kleinster Winkel in Grad. " } },
    "code": ""
  },
  "asin": {
    "name": "ASin",
    "description": {
      "en": "",
      "de": "Diese Funktion berechnet den Winkel aus einem Sinuswert. Es ist somit die Umkehrfunktion f\u00fcr Sinus. Mathematiker nennen es Arcussinus.   Man kann den Sinuswert ausrechnen, indem man die Gegenkathete eines rechtwinkligen Dreiecks durch die Hypotenuse teilt. Aus diesem Wert wird danach der Winkel berechnet. "
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Kleinster Winkel in Grad. Die Grafik zeigt den Zusammenhang zwischen Winkel und Sinuswert. "
      }
    },
    "code": ""
  },
  "atan": {
    "name": "ATan",
    "description": {
      "en": "",
      "de": "Diese Funktion berechnet den Winkel aus einem Tangenswert. Es ist somit die Umkehrfunktion f\u00fcr Tangens. Mathematiker nennen es Arcustangens.   Man kann den Tangenswert ausrechnen, indem man die Gegenkathete eines rechtwinkligen Dreiecks durch die Ankathete teilt. Kotangens rechnet man aus, indem man die Ankathete durch die Gegenkathete teil. Aus diesem Wert wird danach der Winkel berechnet.   Zur Erkl\u00e4rung: Gegenkathete ist die Seite des Dreiecks, die gegen\u00fcber dem gesuchten Winkel liegt. Ankathete ist dagegen neben dem Winkel. "
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Winkel eines Tangenswertes in Grad. Die Grafik zeigt den Zusammenhang zwischen Winkel und Tangens-Wert. "
      }
    },
    "code": ""
  },
  "atan2": {
    "name": "ATan2",
    "description": {
      "en": "",
      "de": "Diese Funktion berechnet den Winkel aus X- und Y-L\u00e4ngen. Es ist somit die erweiterte Tangensfunktion. Beachte, dass diese Funktion etwas anders als ATAN funktioniert, und keine Arcustangens-Funktion ist.   Der Winkel wird nicht aus einem Tangenswert ermittelt, sondern aus den zwei Katheten eines rechtwinkligen Dreiecks. "
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird ein Winkel in Grad zur\u00fcckgeliefert. Es sind alle Winkel im Berech von 0 bis 360\u00b0 m\u00f6glich (bzw. -180\u00b0 bis 180\u00b0). Die Grafik zeigt den Zusammenhang zwischen Winkel und Tangenswert. "
      }
    },
    "code": ""
  },
  "bin": {
    "name": "Bin",
    "description": {
      "en": "",
      "de": "Diese Funktion konvertiert einen beliebigen dezimalen Integerwert zu einem bin\u00e4ren Wert. Lese auch die Zusatzinfos f\u00fcr mehr Informationen.   Umgekehrt, also die \u00dcbergabe eines bin\u00e4ren Wertes an eine Variable erfolgt mit einem Prozentzeichen vor dem Wert. Beispiel:  Wert=%1011011000"
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "String mit bin\u00e4rer Zahl" } },
    "code": ""
  },
  "ceil": {
    "name": "Ceil",
    "description": {
      "en": "",
      "de": "Diese Funktion ist zum Aufrunden einer Kommazahl gedacht. Es wird also immer eine ganze Zahl (ohne Nachkommastellen) zur\u00fcckgeliefert. Dabei wird immer die gr\u00f6\u00dfte Zahl ermittelt. Aus einer Zahl wie 2.1 wird 3.0000 und aus -2.9 wird -2.0000 ermittelt.   Die Funktion Floor funktioniert genau umgekehrt."
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Aufgerundete Ganzzahl aber als Float" } },
    "code": ""
  },
  "cos": {
    "name": "Cos",
    "description": {
      "en": "",
      "de": "Diese Funktion berechnet den Cosinuswert aus einem Winkel. Dies ist eine der wichtigsten mathematischen Funktionen f\u00fcr Spiele. Damit kann man z.B. die horizontale Bewegungsrichtung aus einem Winkel ermitteln.   Hat man die L\u00e4ngen eines Dreiecks, so kann man den Cosinuswert ausrechnen, indem man die Ankathete eines rechtwinkligen Dreiecks durch die Hypotenuse teilt. Wenn man aber nur einen Winkel hat, so kann man den Cosinuswert auch mit der Cos-Funktion berechnen. Somit ergibt sich folgende Formel:   Cos alpha = Ankathete : Hypotenuse "
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Liefert den Cosinuswert, der zwischen -1 und 1 liegt (siehe Grafik) " }
    },
    "code": ""
  },
  "exp": {
    "name": "Exp",
    "description": {
      "en": "",
      "de": "Dies ist eine exponentiale Funktion. Sie berechnet die Basis des nat\u00fcrlichen Logarithmus - Exponenten von e (=2.718). Exp ist die Umkehrfunktion f\u00fcr Log-Funktion. "
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Exponent von e (2.7183)" } },
    "code": ""
  },
  "float": {
    "name": "Float",
    "description": {
      "en": "",
      "de": "Diese Funktion wandelt eine beliebige Zahl (Integer, Float oder String) nach Float um. Der Wert wird also einem neuen Variablentyp zugewiesen. Dies ist dann notwendig, wenn bei sp\u00e4teren Berechnungen eine Kommazahl zur\u00fcckgegeben werden soll. Eine Floatvariable verbraucht 4 Byte an Speicher. "
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Ein Floatwert wird an eine Variable \u00fcbergeben." }
    },
    "code": ""
  },
  "floor": {
    "name": "Floor",
    "description": {
      "en": "",
      "de": "Diese Funktion ist zum Abrunden einer Kommazahl gedacht. Es wird also immer eine ganze Zahl (ohne Nachkommastellen) aber als Floatzahl zur\u00fcckgeliefert. Dabei wird immer die kleinste Zahl ermittelt. Aus einer Zahl wie 2.9 wird 2.0000 und aus -2.1 wird -3.0000 ermittelt.   Die Funktion Ceil funktioniert genau umgekehrt."
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Abgerundete Zahl, ohne Kommastellen aber als Float." }
    },
    "code": ""
  },
  "hex": {
    "name": "Hex",
    "description": {
      "en": "",
      "de": "Diese Funktion konvertiert einen beliebigen dezimalen Integerwert zu einem hexadezimalen Wert. Lese auch die Zusatzinfos f\u00fcr mehr Informationen.   Umgekehrt, also die \u00dcbergabe eines hexadezimalen Wertes an eine Variable erfolgt mit einem Dollarzeichen vor dem Wert. Beispiel: Wert=$ABCD"
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "String mit hexadezimaler Zahl" } },
    "code": ""
  },
  "int": {
    "name": "Int",
    "description": {
      "en": "",
      "de": "Diese Funktion wandelt eine beliebige Kommazahl aus Float oder String zu einem Integerwert. Die Zahl wird dadurch immer gerundet. So wird z.B. aus der Zahl 3.14 die Zahl 3 und aus der Zahl 3.999 die Zahl 4 ermittelt. "
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Gerundete Zahl ohne Kommastellen." } },
    "code": ""
  },
  "log": {
    "name": "Log",
    "description": {
      "en": "",
      "de": "Diese Funktion berechnet den nat\u00fcrlichen Logarithmus. Logarithmen benutzen die Basis e (=2,718) f\u00fcr die Berechnungen. Exp ist die Umkehrfunktion. "
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Ein Floatwert, mit dem nat\u00fcrlichen Logarithmus." }
    },
    "code": ""
  },
  "log10": {
    "name": "Log10",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt einen Logarithmus. Log10 benutzt die Basis 10 f\u00fcr die Berechnungen. Es ist die Umkehrfunktion f\u00fcr 10^x. "
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Ein Floatwert, mit dem Logarithmus." } },
    "code": ""
  },
  "sgn": {
    "name": "Sgn",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt, ob ein Wert positiv oder negativ ist. Wird ein positiver Wert angegeben, so liefert diese Funktion 1, bei einem negativen Wert wird -1 zur\u00fcckgeliefert"
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "-1 = negative Zahl  0 = Null  1 = positive Zahl " } },
    "code": ""
  },
  "sin": {
    "name": "Sin",
    "description": {
      "en": "",
      "de": "Diese Funktion berechnet den Sinuswert aus einem Winkel. Dies ist eine der wichtigsten mathematischen Funktionen f\u00fcr Spiele. Damit kann man die vertikale Bewegungsrichtung aus einem Winkel ermitteln.   Hat man die L\u00e4ngen eines Dreiecks, so kann man den Sinuswert ausrechnen, indem man die Gegenkathete eines rechtwinkligen Dreiecks durch die Hypotenuse teilt. Wenn man aber nur einen Winkel hat, so kann man den Sinuswert auch mit der Sin-Funktion berechnen."
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Sinuswert, der zwischen -1 und 1 liegt." } },
    "code": ""
  },
  "sqr": {
    "name": "Sqr",
    "description": {
      "en": "",
      "de": "Diese mathematische Funktion zieht die Quadratwurzel aus einer Zahl. Wird das Ergebnis mit sich selbst multipliziert, so erh\u00e4lt man wieder die alte Zahl. "
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Liefert die Wurzel der eingegebenen Zahl" } },
    "code": ""
  },
  "tan": {
    "name": "Tan",
    "description": {
      "en": "",
      "de": "Diese Funktion berechnet den Tangenswert aus einem Winkel. Es ist somit die Umkehrfunktion f\u00fcr Arcustangens. Der Winkel wird in Grad angegeben.   Mit Hilfe dieser Funktion kann man die L\u00e4nge der Katheten eines rechtwinkligen Dreiecks berechnen. Dazu muss man den Winkel und eine Kathetenl\u00e4nge wissen. Diese Werte muss man nur in die Formel einsetzten:   TanAlpha = Gegenkathete : Ankathete   So l\u00e4sst sich die Gegenkathete berechnen:  Gegenkathete = Tan(Winkel)*Ankathete   So l\u00e4sst sich die Ankathete berechnen:  Ankathete = Tan(Winkel)/Gegenkathete "
    },
    "category": "basics",
    "subCategory": "maths",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird ein Tangenswert zur\u00fcckgeliefert. Die Grafik zeigt den Zusammenhang zwischen Winkel und Tangenswert. "
      }
    },
    "code": ""
  },
  "apptitle": {
    "name": "AppTitle",
    "description": {
      "en": "",
      "de": "Diese Anweisung \u00e4ndert den Fenstertiteltext. Dieser Text erscheint nur, wenn das Programm im Fenstermodus l\u00e4uft oder in der normalen Konsole. Fenstermodus kann mit dem Befehl Graphics eingeschaltet werden. Standardm\u00e4\u00dfig steht im Fenster ein anderer Text. "
    },
    "category": "basics",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "calldll": {
    "name": "CallDLL",
    "description": {
      "en": "",
      "de": "Die Funktion CallDLL f\u00fchrt eine bestimmte Prozedur in einer bestimmter DLL Datei aus. Die DLL Prozeduren sind wie BB Funktionen und k\u00f6nnen nicht nur Daten verarbeiten, sondern auch Aktionen ausf\u00fchren (z.B. Windows Neustart).   Gebe einfach den Dateinamen einer DLL Datei an. Der Prozedur Name muss in der DLL Datei enthalten sein (Gro\u00df-/Kleinschreibung beachten!).   Die optionalen Parameter \"Eingabe\" und \"Ausgabe\" sind die Identit\u00e4ten von 2 Speicherfeldern (banks). Diese k\u00f6nnen Daten f\u00fcr die Ein-/Ausgabe enthalten. "
    },
    "category": "basics",
    "subCategory": "diverse",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Ausgabewert wird zur\u00fcckgeliefert (Integer). Zus\u00e4tzlich werden Werte in der Ausgabebank gespeichert. "
      }
    },
    "code": ""
  },
  "commandline": {
    "name": "CommandLine",
    "description": { "en": "", "de": "String mit den \u00fcbergebenen Parametern " },
    "category": "basics",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "debuglog": {
    "name": "DebugLog",
    "description": {
      "en": "",
      "de": "Dieser Befehl sendet beliebige Debug Meldungen in ein spezielles DebugLog Fenster. Diese Meldungen werden vom Programm nicht angezeigt. Nur im Editor bzw. Debugger kann dieser Text eingesehen werden.   Das DebugLog Fenster kann man sich wie ein privates Notepad vorstellen, wo bestimmte Meldungen ausgegeben werden, die nur der Programmierer ansehen kann.   Das DebugLog Fenster kann auch w\u00e4hrend der Ausf\u00fchrung eines Programms angesehen werden, wof\u00fcr ein Programm allerdings in einem Fenster laufen muss. "
    },
    "category": "basics",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Nachricht im DebugLog Fenster" } },
    "code": ""
  },
  "directinputenabled": {
    "name": "DirectInputEnabled",
    "description": {
      "en": "",
      "de": "Die Funktion DirectInputEnabled ermittelt, ob DX Input eingeschaltet oder ausgeschaltet ist. Vor einiger Zeit wurden alle Inputbefehle von DX Input auf Standard Input umgestellt. Dadurch ist es minimal langsamer als vorher. Jedoch gab es einige Probleme mit DX Input. "
    },
    "category": "basics",
    "subCategory": "diverse",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Falls DX Input aktiv ist, dann wird 1 zur\u00fcckgeliefert, sonst 0." }
    },
    "code": ""
  },
  "enabledirectinput": {
    "name": "EnableDirectInput",
    "description": {
      "en": "",
      "de": "Die Anweisung EnableDirectInput schaltet DX Input ein oder aus. Seit einiger Zeit wurden alle Inputbefehle von DX Input auf Standard Input umgestellt. Dadurch ist es minimal langsamer als vorher. Jedoch gab es einige Probleme mit DX Input."
    },
    "category": "basics",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "getenv": {
    "name": "GetEnv",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt den Wert einer Systemvariable. Diese Systemvariablen gab es bereits zu DOS Zeiten. Wegen der Kompatibilit\u00e4t sind diese Variablen bis heute geblieben."
    },
    "category": "basics",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "String mit dem Wert einer Systemvariable." } },
    "code": ""
  },
  "runtimeerror": {
    "name": "RuntimeError",
    "description": {
      "en": "",
      "de": "Dieser Befehl kann eine beliebige Textnachricht auf dem Bildschirm anzeigen. Diese Nachricht erscheint in einem Windows-Fenster. Sollte das Programm im Vollbildmodus laufen, so wird es minimiert und diese Meldung angezeigt. "
    },
    "category": "basics",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "runtimestats": {
    "name": "RuntimeStats",
    "description": {
      "en": "",
      "de": "Dieser Befehl geh\u00f6rt nicht offiziell zum Befehlssatz. Es ist nur eine kleine Hilfe, die zeigen soll wieviele Objekte gerade verwendet werden. Wenn RuntimeStats ausgef\u00fchrt wurde, dann wird im DebugLog eine Meldung ausgegeben. Diese besteht aus:   Active strings gibt die Anzahl der gerade verwendeten Strings zur\u00fcck.   Active objects gibt die Anzahl der gerade verwendeten TYPE-Objekte zur\u00fcck.   Unreleased Objs gibt die Anzahl der Objekte an, die nicht freigegeben wurden (Container-Variablen). "
    },
    "category": "basics",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Ausgabe in DebugLog" } },
    "code": ""
  },
  "setenv": {
    "name": "SetEnv",
    "description": {
      "en": "",
      "de": "Diese Funktion setzt/\u00e4ndert den Wert einer Systemvariable. Diese Systemvariablen gab es bereits zu DOS-Zeiten. Wegen der Kompatibilit\u00e4t sind diese Variablen bis heute geblieben. "
    },
    "category": "basics",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "systemproperty": {
    "name": "SystemProperty",
    "description": {
      "en": "",
      "de": "Diese Funktion liefert bestimmte Systeminformationen zur\u00fcck. Zur Auswahl stehen noch nicht sehr viele M\u00f6glichkeiten. Vorteil: Der Entwickler der Programmiersprache BlitzBasic kann es problemlos erweitern."
    },
    "category": "basics",
    "subCategory": "diverse",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Liefert einen String zur\u00fcck, der dann vorher ausgew\u00e4hlte Informationen enth\u00e4lt."
      }
    },
    "code": ""
  },
  "asc": {
    "name": "Asc",
    "description": {
      "en": "",
      "de": "Eine Funktion zur Zeichenkettenverarbeitung, die einen numerischen Wert zur\u00fcckgibt. Dieser Wert ist der ASCII-Code des ersten Zeichens in einem Zeichenkettenausdruck. ASCII-Code kann nur ein Wert von 0 bis 255 sein. Der umgekehrte Befehl lautet Chr. "
    },
    "category": "basics",
    "subCategory": "strings",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "numerischer ASCII-Zeichencode (0-255)" } },
    "code": ""
  },
  "chr": {
    "name": "Chr",
    "description": {
      "en": "",
      "de": "Diese Funktion konvertiert einen ASCII-Code zu einem Zeichen. Manche Zeichen k\u00f6nnen in Basic nicht dargestellt werden (z.B. Anf\u00fchrungszeichen) - die k\u00f6nnen dann mit diesem Befehl doch noch dargestellt werden. Chr ist die Umkehrfunktion f\u00fcr ASC.   Beachte, dass ein ASCII-Code nicht der Tastatur-Scancode ist. Das sind zwei verschiedene Sachen. Je nach Schriftart k\u00f6nnen auch unterschiedliche Zeichen ausgegeben werden."
    },
    "category": "basics",
    "subCategory": "strings",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "das ASCII-Zeichen als String" } },
    "code": ""
  },
  "instr": {
    "name": "Instr",
    "description": {
      "en": "",
      "de": "Diese Funktion durchsucht den ersten Text nach einem String. Wird exakt der selbe String im Text gefunden, so wird die Zeichenposition zur\u00fcckgeliefert. Es kann auch die Startposition angegeben werden."
    },
    "category": "basics",
    "subCategory": "strings",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird die Zeichenposition des ersten Vorkommens zur\u00fcckgegeben. Wurde in dem Text keine \u00dcbereinstimmung gefunden, so wird eine Null zur\u00fcckgeliefert."
      }
    },
    "code": ""
  },
  "left": {
    "name": "Left",
    "description": {
      "en": "",
      "de": "Diese Funktion kopiert aus einem beliebigen Text bestimmte Anzahl von Zeichen. Die Zeichen werden immer von der linken Seite kopiert. Enth\u00e4lt ein Text zu wenig Zeichen, so wird dann einfach der gesamte Text 1:1 kopiert."
    },
    "category": "basics",
    "subCategory": "strings",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Kopierter Text mit \u00fcbergebener Anzahl von Zeichen" }
    },
    "code": ""
  },
  "len": {
    "name": "Len",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die Anzahl der Zeichen in einem Text. Es werden dabei wirklich alle Zeichen (auch Leerzeichen) mitgez\u00e4hlt. Diese Funktion ist dann sinnvoll, wenn nur bestimmte Anzahl von Zeichen erlaubt werden sollen (z.B. bei Namenseingaben mit max. drei Zeichen f\u00fcr eine HighScore)."
    },
    "category": "basics",
    "subCategory": "strings",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Anzahl der Zeichen" } },
    "code": ""
  },
  "lower": {
    "name": "Lower",
    "description": {
      "en": "",
      "de": "Diese Stringfunktion wandelt alle Buchstaben des angegebenen Textes in Kleinbuchstaben um. Die UPPER-Funktion funktioniert genau umgekehrt. "
    },
    "category": "basics",
    "subCategory": "strings",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "String mit umgewandeltem Text" } },
    "code": ""
  },
  "lset": {
    "name": "LSet",
    "description": {
      "en": "",
      "de": "Diese Stringfunktion \u00e4ndert die Zeichenanzahl eines Textes. Hat ein Text zu wenig Zeichen, so werden einfach hinter dem Text einige Leerzeichen hinzugef\u00fcgt - somit hat ein Text dann genau die voreingestellte Zeichenanzahl. Ist ein Text dagegen zu lang, so wird der linksb\u00fcndig zurechtgeschnitten. Beachte, dass der Text immer linksb\u00fcndig zur\u00fcckgeliefert wird!"
    },
    "category": "basics",
    "subCategory": "strings",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Neuer Text mit \u00fcbergebener Zeichenanzahl" } },
    "code": ""
  },
  "mid": {
    "name": "Mid",
    "description": {
      "en": "",
      "de": "Diese Stringfunktion kopiert einige Zeichen aus einem Text. Dabei muss man die Startposition angeben und die Anzahl der zu kopierenden Zeichen. Sollte der Text zu wenige Zeichen enthalten, so wird einfach nur bis zum Ende des Textes kopiert. Wird eine Startposition au\u00dferhalb der maximalen Textl\u00e4nge angegeben, so wird gar kein Text kopiert. "
    },
    "category": "basics",
    "subCategory": "strings",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Kopierter Text mit maximal \"anzahl\" Zeichen" } },
    "code": ""
  },
  "replace": {
    "name": "Replace",
    "description": {
      "en": "",
      "de": "Diese Stringfunktion sucht in einem Text nach einer bestimmter Zeichenfolge. Die gefundenen Zeichen werden gegen einen anderen Text ersetzt. Da die Funktionen LOWER und UPPER keine deutschen Umlaute konvertieren k\u00f6nnen, ist dies eine hervorragende Erweiterung zu den Befehlen. "
    },
    "category": "basics",
    "subCategory": "strings",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "String mit ersetzten Zeichen" } },
    "code": ""
  },
  "right": {
    "name": "Right",
    "description": {
      "en": "",
      "de": "Diese Funktion kopiert aus einem beliebigen Text bestimmte Anzahl von Zeichen. Die Zeichen werden immer von der rechten Seite kopiert. Enth\u00e4lt ein Text zu wenig Zeichen, so wird dann einfach der gesamte Text 1:1 kopiert."
    },
    "category": "basics",
    "subCategory": "strings",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Kopierter Text mit \u00fcbergebener Anzahl von Zeichen" }
    },
    "code": ""
  },
  "rset": {
    "name": "RSet",
    "description": {
      "en": "",
      "de": "Diese Stringfunktion \u00e4ndert die Zeichenanzahl eines Textes. Hat ein Text zu wenig Zeichen, so werden einfach vor dem Text einige Leerzeichen hinzugef\u00fcgt - somit hat ein Text dann genau die voreingestellte Zeichenanzahl. Ist ein Text dagegen zu lang, so wird der rechtsb\u00fcndig zurechtgeschnitten. Beachte, dass der Text immer rechtsb\u00fcndig zur\u00fcckgeliefert wird!   Beispiel"
    },
    "category": "basics",
    "subCategory": "strings",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "String mit \u00fcbergebener Anzahl von Zeichen" } },
    "code": ""
  },
  "str": {
    "name": "Str",
    "description": {
      "en": "",
      "de": "Diese Stringfunktion wandelt einen beliebigen numerischen Wert in eine Zeichenkette um. Dabei kann entweder ein Integer-, Float- oder sogar ein Stringwert \u00fcbergeben werden. Dies wird f\u00fcr weitere Stringfunktionen gebraucht.   Sogar Types k\u00f6nnen \u00fcbergeben werden. Dabei werden die Werte der einzelnen Felder des Types in einen String umgewandelt und in der Form \"[Wert1,Wert2,Wert3,...]\" zur\u00fcckgeliefert. "
    },
    "category": "basics",
    "subCategory": "strings",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "ein String mit dem Zahlenwert" } },
    "code": ""
  },
  "string": {
    "name": "String",
    "description": {
      "en": "",
      "de": "Diese Stringfunktion kann einen Text beliebig oft in einen anderen Text kopieren. Somit steht in der neuen Zeichenkette x-mal hintereinander der \u00fcbergebene Text."
    },
    "category": "basics",
    "subCategory": "strings",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Zeichenkette mit sich wiederholendem Text" } },
    "code": ""
  },
  "trim": {
    "name": "Trim",
    "description": {
      "en": "",
      "de": "Diese Stringfunktion entfernt alle Leerzeichen und Umlaute vor und hinter einem Text. Bei falschen Eingaben durch den Benutzer, wird so ein Stringwert dadurch \"bereinigt\".   Sollen andere Zeichen entfernt werden, so muss man die Stringfunktion Replace verwenden. LSet und RSet f\u00fcgen dagegen Leerzeichen hinzu."
    },
    "category": "basics",
    "subCategory": "strings",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "String ohne Leerzeichen und Umlaute vor/hinter dem Text." }
    },
    "code": ""
  },
  "upper": {
    "name": "Upper",
    "description": {
      "en": "",
      "de": "Diese Stringfunktion wandelt alle Buchstaben des angegebenen Textes in Gro\u00dfbuchstaben um. Die Lower-Funktion funktioniert genau umgekehrt. "
    },
    "category": "basics",
    "subCategory": "strings",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Ein String mit umgewandelten Text." } },
    "code": ""
  },
  "createtimer": {
    "name": "CreateTimer",
    "description": {
      "en": "",
      "de": "Diese Funktion definiert einen Zeitgeber. Der Computer z\u00e4hlt dann intern mit dieser Frequenz. Das Programm kann danach mit WaitTimer angehalten werden, solange kein weiterer \"Z\u00e4hlimpuls\" ankommt. Mit FreeTimer kann dieser Timer wieder deaktiviert werden.   Diese Befehle sind besonders f\u00fcr die Grafikausgabe n\u00fctzlich. Damit kann man die Grafikausgabe auf bestimmte Bilderanzahl pro Sekunde drosseln. Somit wird das Spiel genau so schnell auch auf anderen Rechnern erscheinen."
    },
    "category": "basics",
    "subCategory": "time-random",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t des Timers. Falls eine Null zur\u00fcckgeliefert wird, dann konnte dieser Timer nicht erstellt werden."
      }
    },
    "code": ""
  },
  "currentdate": {
    "name": "CurrentDate",
    "description": {
      "en": "",
      "de": "Diese Funktion liefert das aktuelle Datum zur\u00fcck. Der Monat in dem R\u00fcckgabewert ist abgek\u00fcrzt und auf englisch. BlitzBasic kann nur Datum auslesen aber nicht setzen. "
    },
    "category": "basics",
    "subCategory": "time-random",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Das aktuelle Datum im Format: TT MMM JJJJ (z.B. \"17 Apr 2006\")  Monat besteht aus englischen Abk\u00fcrzungen! Hier alle aufgelistet:  Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec"
      }
    },
    "code": ""
  },
  "currenttime": {
    "name": "CurrentTime",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die aktuelle Uhrzeit in dem Format HH:MM:SS. BlitzBasic kann nur Zeit auslesen aber nicht setzten. "
    },
    "category": "basics",
    "subCategory": "time-random",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Die aktuelle Uhrzeit im Format: HH:MM:SS." } },
    "code": ""
  },
  "delay": {
    "name": "Delay",
    "description": {
      "en": "",
      "de": "Dieser Befehl stoppt die Programmausf\u00fchrung f\u00fcr die angegebene Anzahl von Millisekunden. Dadurch wird die Programmausf\u00fchrung auf jeden Fall verlangsamt. Dies kann f\u00fcr die Ausgabe von Meldungen benutzt werden. "
    },
    "category": "basics",
    "subCategory": "time-random",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "freetimer": {
    "name": "FreeTimer",
    "description": {
      "en": "",
      "de": "Diese Anweisung entfernt einen Timer, der mit CreateTimer definiert wurde. Dies sollte dann geschehen, wenn ein Timer nicht mehr l\u00e4nger gebraucht wird. "
    },
    "category": "basics",
    "subCategory": "time-random",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "millisecs": {
    "name": "MilliSecs",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die Zeit nach dem letzten Windowsstart in Millisekunden. Eine Sekunde hat 1000, eine Minute hat 60000, eine Stunde hat 3600000 und ein Tag hat 86400000 Millisekunden.   Diese Funktion ist besonders in Verbindung mit SeedRnd sehr n\u00fctzlich."
    },
    "category": "basics",
    "subCategory": "time-random",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Windows-Laufzeit in Millisekunden" } },
    "code": ""
  },
  "pausetimer": {
    "name": "PauseTimer",
    "description": {
      "en": "",
      "de": "Die Anweisung PauseTimer h\u00e4lt einen Zeitgeber an, der mit CreateTimer definiert wurde. Wenn ein Zeitgeber so angehalten wird, dann werden keine Timer-Events mehr gesendet. Erst mit ResumeTimer wird die Ausf\u00fchrung fortgesetzt."
    },
    "category": "basics",
    "subCategory": "time-random",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "rand": {
    "name": "Rand",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt eine Zufallszahl. Der minimale und maximale Wert kann eingestellt werden. Es wird immer nur eine Ganzzahl zur\u00fcckgeliefert. Die Funktion Rnd funktioniert \u00e4hnlich, liefert aber Kommazahlen. "
    },
    "category": "basics",
    "subCategory": "time-random",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Eine zuf\u00e4llige Ganzzahl, die zwischen den eingestellten Werten liegt." }
    },
    "code": ""
  },
  "resettimer": {
    "name": "ResetTimer",
    "description": {
      "en": "",
      "de": "Die Anweisung ResetTimer setzt einen Zeitgeber zur\u00fcck. Nach Definition eines Timers mit CreateTimer wird jedes Mal ein Event gesendet. Diese Timer-Ticks werden gez\u00e4hlt - die Anzahl kann mit TimerTicks ermittelt werden. ResetTimer setzt diesen Wert wieder auf 0. "
    },
    "category": "basics",
    "subCategory": "time-random",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "resumetimer": {
    "name": "ResumeTimer",
    "description": {
      "en": "",
      "de": "Die Anweisung ResumeTimer setzt die Ausf\u00fchrung eines Zeitgebers fort. Ein Zeitgeber kann mit CreateTimer definiert werden. Es kann, falls notwendig, mit PauseTimer angehalten werden - dann werden keine Timer-Events mehr gesendet."
    },
    "category": "basics",
    "subCategory": "time-random",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "rnd": {
    "name": "Rnd",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt eine Zufallszahl. Der minimale und maximale Wert kann eingestellt werden. An eine Float-Variable wird eine Kommazahl \u00fcbergeben. An eine Integer-Variable wird dagegen eine Ganzzahl \u00fcbergeben. Die Funktion Rand funktioniert \u00e4hnlich, liefert aber immer Ganzzahlen. "
    },
    "category": "basics",
    "subCategory": "time-random",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Eine zuf\u00e4llige Kommazahl, die zwischen den eingestellten Werten liegt." }
    },
    "code": ""
  },
  "rndseed": {
    "name": "RndSeed",
    "description": {
      "en": "",
      "de": "Die Funktion RndSeed liefert einen Wert zur\u00fcck, der vorher mit SeedRnd gesetzt wurde. Dieser Wert ist f\u00fcr weitere Zufallswerte entscheidend. Man stellt mit diesem Wert einen Zufallsmuster ein. Normalerweise kann man diesen gesetzten Wert manuell speichern und dann abfragen - oder halt diese Funktion benutzen."
    },
    "category": "basics",
    "subCategory": "time-random",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird ein Wert zur\u00fcckgeliefert, der vorher mit SeedRnd gesetzt wurde."
      }
    },
    "code": ""
  },
  "seedrnd": {
    "name": "SeedRnd",
    "description": {
      "en": "",
      "de": "Dieser Befehl stellt einen Wert f\u00fcr Zufallszahlen ein. Die Zufallszahlen sind nicht wirklich zuf\u00e4llig. Startet man ein Programm, das Rand oder Rnd verwendet, so liefert es st\u00e4ndig die selben Zahlen. Mit SeedRnd kann auf andere Zufallsmuster umgestellt werden. "
    },
    "category": "basics",
    "subCategory": "time-random",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "timerticks": {
    "name": "TimerTicks",
    "description": {
      "en": "",
      "de": "Die Funktion TimerTicks liefert Anzahl der \"Ticks\", die ein Zeitgeber produziert hat. Bei jedem Tick wird ein Event gesendet. Mit PauseTimer kann ein Zeitgeber angehalten und sp\u00e4ter mit ResumeTimer fortgesetzt werden. ResetTimer setzt diesen Timer zur\u00fcck."
    },
    "category": "basics",
    "subCategory": "time-random",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Anzahl der \"Ticks\", die ein Zeitgeber produziert hat." }
    },
    "code": ""
  },
  "waittimer": {
    "name": "WaitTimer",
    "description": {
      "en": "",
      "de": "Dieser Befehl wartet solange, bis ein \"Zeitimpuls\" ankommt. Mit CreateTimer kann die H\u00e4ufigkeit der Impulse pro Sekunde eingestellt werden. Dieser Befehl ist besonders f\u00fcr die Grafikausgabe n\u00fctzlich. Damit kann man die Grafikausgabe auf bestimmte Anzahl Bilder pro Sekunde drosseln. Somit wird das Spiel genau so schnell auch auf anderen Rechnern erscheinen. "
    },
    "category": "basics",
    "subCategory": "time-random",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Anzahl der Zeitimpulse seit der letzten Ausf\u00fchrung. Normalerweise sollte 1 zur\u00fcckgeliefert werden. Sollte der Wert gr\u00f6\u00dfer sein, so konnte das Programm die Geschwindigkeit nicht halten (d.h. das Programm l\u00e4uft viel zu langsam, so dass der Timer einige Warteperioden \u00fcberspringen musste)."
      }
    },
    "code": ""
  },
  "buttonstate": {
    "name": "ButtonState",
    "description": {
      "en": "",
      "de": "Die Funktion ButtonState ermittelt, ob ein Button gerade ein oder aus ist. Mit Button wird hier aber nicht der Button selbst gemeint, sondern eher Checkbox oder Radiobutton. Diese zwei Objekte werden ebenfalls mit CreateButton erzeugt (Style 2 oder 3). Mit SetButtonState kann der Status auch umgeschaltet werden. "
    },
    "category": "gui",
    "subCategory": "button",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0 = Button hat keinen Haken/Punkt  1 = Button hat einen Haken/Punkt" }
    },
    "code": ""
  },
  "createbutton": {
    "name": "CreateButton",
    "description": {
      "en": "",
      "de": "Die Funktion CreateButton erstellt einen Button mit einem Text. Gib dazu die Startkoordinate X/Y und Breite/H\u00f6he an. Gruppe ist die Identit\u00e4t von Window, Panel, Tabber oder Canvas. Mit dieser Funktion lassen sich normale Buttons (Style 1) aber auch Checkboxen (Style 2) oder Radiobuttons (Style 3) erstellen. Wird der Style auf 4 oder 5 gesetzt sendet der Button immer ein Event, sobald innerhalb des Parents (empfehlenswert ist ein Panel) die ENTER bzw. ESC-Taste gedr\u00fcckt wird. Dies ist besonders hilfreich, da bei GUI-Anwendungen KeyHit-Abfragen wirkungslos sind.   Der Status kann mit ButtonState abgefragt und mit SetButtonState gesetzt werden (f\u00fcr Style 2 oder 3). Mit SetGadgetText kann man sp\u00e4ter den Text \u00e4ndern. "
    },
    "category": "gui",
    "subCategory": "button",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t des Button-Objekts wird zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "setbuttonstate": {
    "name": "SetButtonState",
    "description": {
      "en": "",
      "de": "Die Anweisung SetButtonState schaltet den Status eines Buttons um. Mit Button wird hier aber nicht der Button selbst gemeint, sondern eher eine Checkbox oder Radiobutton. Diese zwei Objekte werden ebenfalls mit CreateButton erzeugt (Style 2 oder 3). Mit ButtonState kann der aktuelle Status ermittelt werden. "
    },
    "category": "gui",
    "subCategory": "button",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "canvasbuffer": {
    "name": "CanvasBuffer",
    "description": {
      "en": "",
      "de": "Der ermittelte Wert kann mit vielen weiteren Befehlen verwendet werden. Wird es z.B. mit SetBuffer verwendet, so wird die Grafikausgabe auf diese Leinwand umgeleiteter. Der Befehl FlipCanvas muss ausgef\u00fchrt werden, damit die Grafik aktualisiert wird. "
    },
    "category": "gui",
    "subCategory": "canvas",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Nummer(Handle), die die Identit\u00e4t angibt" } },
    "code": ""
  },
  "createcanvas": {
    "name": "CreateCanvas",
    "description": {
      "en": "",
      "de": "Die Funktion CreateCanvas erstellt ein Canvas-Objekt. Gib dazu die Startkoordinate X/Y und Breite/H\u00f6he an. Gruppe ist die Identit\u00e4t von Window, Panel oder Tabber.   Ein Canvas (=Leinwand) ist eine rechteckige Fl\u00e4che in einem Fenster. Die Grafik kann somit direkt in ein Fenster eingezeichnet werden. Benutze SetBuffer, um die Grafikausgabe auf diese Leinwand umzulenken. Der Befehl FlipCanvas muss ausgef\u00fchrt werden, damit die Grafik aktualisiert wird. "
    },
    "category": "gui",
    "subCategory": "canvas",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t des Canvas-Objekts wird zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "flipcanvas": {
    "name": "FlipCanvas",
    "description": {
      "en": "",
      "de": "Die Anweisung FlipCanvas ist ein Ersatz f\u00fcr Flip, wenn Grafik statt in ein Graphics-Fenster nun in ein Canvas-Objekt eingezeichnet wird.   Canvas (=Leinwand) ist eine rechteckige Fl\u00e4che in einem Fenster. Die Grafik kann somit direkt in ein Fenster eingezeichnet werden. Benutze SetBuffer, um die Grafikausgabe auf diese Leinwand umzulenken. "
    },
    "category": "gui",
    "subCategory": "canvas",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "desktop": {
    "name": "Desktop",
    "description": {
      "en": "",
      "de": "Die Funktion Desktop liefert die Identit\u00e4t des Desktops zur\u00fcck. Desktop ist auch wie ein Gadget-Objekt - so k\u00f6nnen einige Befehle auch auf Desktop angewendet werden.   1. Desktop wird als Objekt zum Gruppieren von Fenstern verwendet.  2. ClientWidth/ClientHeight liefert die Gr\u00f6\u00dfe des Desktops."
    },
    "category": "gui",
    "subCategory": "desktop",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "liefert die Identit\u00e4t des Desktops zur\u00fcck" }
    },
    "code": ""
  },
  "desktopbuffer": {
    "name": "DesktopBuffer",
    "description": {
      "en": "",
      "de": "Die Funktion DesktopBuffer liefert die Identit\u00e4t des Grafikbuffers \"Desktop\" zur\u00fcck. Die Grafik kann somit direkt auf den Desktop eingezeichnet werden.   Der ermittelte Wert kann mit vielen weiteren Befehlen verwendet werden. Wird es z.B. mit SetBuffer verwendet, so wird die Grafikausgabe auf diesen Buffer umgeleitet. "
    },
    "category": "gui",
    "subCategory": "desktop",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Liefert die Identit\u00e4t des Grafikbuffers \"Desktop\" zur\u00fcck" }
    },
    "code": ""
  },
  "activeobjects": {
    "name": "ActiveObjects",
    "description": {
      "en": "",
      "de": "Die Funktion ActiveObjects gibt die Anzahl verwendeter Objekte aus. Es ist nur eine Funktion f\u00fcr BB-Entwickler. "
    },
    "category": "gui",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "die Anzahl verwendeter Objekte" } },
    "code": ""
  },
  "autosuspend": {
    "name": "AutoSuspend",
    "description": {
      "en": "",
      "de": "Fr\u00fcher oder sp\u00e4ter wird jeder auf ein kleines Problem sto\u00dfen. Wenn man ein anderes Programmfenster ausw\u00e4hlt, dann l\u00e4uft das BB-Programm weiterhin. Dies l\u00e4sst sich mit einigen Tricks verhindern (Event $2001). Doch viel einfacher ist es mit diesem Befehl. Normalerweise ist diese Funktion deaktiviert. Wird es aktiviert, dann wird das Programm automatisch angehalten, bis das BB-Fenster wieder aktiviert wird. "
    },
    "category": "gui",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "createprocess": {
    "name": "CreateProcess",
    "description": {
      "en": "",
      "de": "Die Funktion CreateProcess f\u00fchrt eine EXE-Datei aus. Das funktioniert genau wie ExecFile. CreateProcess liefert jedoch Stream-Handle zur\u00fcck. \u00dcber diesen Stream werden Informationen ausgelesen, die das gestartete Programm sendet. Z.B. zeigt ein Konsolen-Programm alle Informationen nicht mehr auf dem Bildschirm, sondern sendet alles an ein BB-Programm. "
    },
    "category": "gui",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Stream-Identit\u00e4t wird zur\u00fcckgeliefert" } },
    "code": ""
  },
  "debugobjects": {
    "name": "DebugObjects",
    "description": {
      "en": "",
      "de": "Die Anweisung DebugObjects gibt Texte in DebugLog aus und listet alle verwendete Objekte auf. Es ist nur eine Funktion f\u00fcr BB-Entwickler. "
    },
    "category": "gui",
    "subCategory": "diverse",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "eventdata": {
    "name": "EventData",
    "description": {
      "en": "",
      "de": "Die Funktion EventData liefert mehr Informationen zu einem erfolgten Event. Weitere Anweisungen wie EventSource (liefert Handle des Objekts) und EventX/EventY (liefern Koordinaten) vervollst\u00e4ndigen diese Funktion. "
    },
    "category": "gui",
    "subCategory": "event",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Ein spezifischer Wert wird je nach Event zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "eventid": {
    "name": "EventID",
    "description": {
      "en": "",
      "de": "Die Funktion EventID liefert den letzte Event-Code zur\u00fcck, der mit WaitEventermittelt wurde. Weitere Funktionen wie EventData, EventSource, EventX oder EventY erweitern diese Funktion. "
    },
    "category": "gui",
    "subCategory": "event",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Liefert den letzten Event-Code zur\u00fcck" } },
    "code": ""
  },
  "eventsource": {
    "name": "EventSource",
    "description": {
      "en": "",
      "de": "Die Funktion EventSource liefert Handle eines Objekts zur\u00fcck, von wo ein Event erfolgt ist. Weitere Anweisungen wie EventData (liefert weitere Event-Informationen) und EventX/EventY (liefern Koordinaten) vervollst\u00e4ndigen diese Funktion."
    },
    "category": "gui",
    "subCategory": "event",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Liefert Handle eines Objekts zur\u00fcck" } },
    "code": ""
  },
  "eventx": {
    "name": "EventX",
    "description": {
      "en": "",
      "de": "Die Funktion EventX liefert die X-Koordinate nach dem Event $203, $801 oder $802. Weitere Anweisungen wie EventData (liefert weitere Event-Informationen) und EventSource (liefert Handle des Objekts) vervollst\u00e4ndigen diese Funktion."
    },
    "category": "gui",
    "subCategory": "event",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "X-Koordinate wird zur\u00fcckgeliefert" } },
    "code": ""
  },
  "eventy": {
    "name": "EventY",
    "description": {
      "en": "",
      "de": "Die Funktion EventY liefert die Y-Koordinate nach dem Event $203, $801 oder $802. Weitere Anweisungen wie EventData (liefert weitere Event-Informationen) und EventSource (liefert Handle des Objekts) vervollst\u00e4ndigen diese Funktion."
    },
    "category": "gui",
    "subCategory": "event",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Y-Koordinate wird zur\u00fcckgeliefert" } },
    "code": ""
  },
  "eventz": {
    "name": "EventZ",
    "description": {
      "en": "",
      "de": "Die Funktion EventZ liefert die Z-Koordinate nach dem Event $203, $801 oder $802. Weitere Anweisungen wie EventData (liefert weitere Event-Informationen) und EventSource (liefert Handle des Objekts) vervollst\u00e4ndigen diese Funktion."
    },
    "category": "gui",
    "subCategory": "event",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Z-Koordinate wird zur\u00fcckgeliefert" } },
    "code": ""
  },
  "flushevents": {
    "name": "FlushEvents",
    "description": {
      "en": "",
      "de": "Die Anweisung FlushEvents l\u00f6scht alle Events eines Types. EventID gibt dabei die zu l\u00f6schende Event-Types an (siehe auch untere Tabelle). Dies kann n\u00fctzlich sein, wenn vorherige Aktionen gel\u00f6scht werden sollen."
    },
    "category": "gui",
    "subCategory": "event",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "hotkeyevent": {
    "name": "HotKeyEvent",
    "description": {
      "en": "",
      "de": "Die Anweisung HotKeyEvent generiert ein Event, wenn eine bestimmte Tastenkombination gedr\u00fcckt wird. Notwendige Parameter sind Scancode, Steuerung (Sondertasten) und ID (EventID). Optionale Parameter k\u00f6nnen angegeben werden - diese k\u00f6nnen dann mit EventData, EventSource, EventX, EventY, EventZ ausgelesen werden. "
    },
    "category": "gui",
    "subCategory": "event",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "peekevent": {
    "name": "PeekEvent",
    "description": {
      "en": "",
      "de": "Die Funktion PeekEvent pr\u00fcft, ob ein Event verf\u00fcgbar ist. Falls ein Event in der Warteschleife liegt, dann wird Codenummer des Events zur\u00fcckgeliefert. Wenn kein Event verf\u00fcgbar ist, dann wird 0 zur\u00fcckgeliefert. "
    },
    "category": "gui",
    "subCategory": "event",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Codenummer des Events wird zur\u00fcckgeliefert (0=kein Event verf\u00fcgbar)"
      }
    },
    "code": ""
  },
  "waitevent": {
    "name": "WaitEvent",
    "description": {
      "en": "",
      "de": "Die Funktion WaitEvent wartet auf ein Event und liefert danach die Identit\u00e4t des Events zur\u00fcck (Eventart). Mit dem Parameter \"Timeout\" kann man die maximale Zeit einstellen, die das Programm abwarten soll. Gebe -1 oder lass den Parameter weg, dann wartet das Programm unbegrenzt (oder bis ein Event eintritt). Sollte die Zeit ablaufen und kein Event eintreten, dann wird 0 zur\u00fcckgeliefert. Nach einem Event k\u00f6nnen weitere Daten mit EventData, EventID, EventSource, EventX oder EventY ermittelt werden. "
    },
    "category": "gui",
    "subCategory": "event",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "liefert die ID des Events zur\u00fcck" } },
    "code": ""
  },
  "activategadget": {
    "name": "ActivateGadget",
    "description": {
      "en": "",
      "de": "ActivateGadget fokussiert ein Objekt. Einige Objekte wie z.B. Button/TextField/TextArea usw. lassen sich so markieren. Danach k\u00f6nnen solche Objekte direkt mit der Tastatur gesteuert werden. "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "clientheight": {
    "name": "ClientHeight",
    "description": {
      "en": "",
      "de": "Funktion ClientHeight liefert die H\u00f6he einer Gruppe zur\u00fcck. Gruppe ist die Identit\u00e4t eines Objekt, zu dem weitere Objekte hinzugef\u00fcgt werden k\u00f6nnen (z.B. Desktop, Window, Tabber oder Canvas). Andere Objekte k\u00f6nnen ung\u00fcltige Werte zur\u00fcckliefern!   Clienth\u00f6he ist nicht die H\u00f6he eines Objekts, sondern nutzbare H\u00f6he ohne Rand! "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "clientwidth": {
    "name": "ClientWidth",
    "description": {
      "en": "",
      "de": "Funktion ClientWidth liefert die Breite einer Gruppe zur\u00fcck. Gruppe ist die Identit\u00e4t eines Objekt, zu dem weitere Objekte hinzugef\u00fcgt werden k\u00f6nnen (z.B. Desktop, Window, Tabber oder Canvas). Andere Objekte k\u00f6nnen ung\u00fcltige Werte zur\u00fcckliefern!   Clientbreite ist nicht die Breite eines Objekts, sondern nutzbare Breite ohne Rand! "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Breite der Gruppe" } },
    "code": ""
  },
  "disablegadget": {
    "name": "DisableGadget",
    "description": {
      "en": "",
      "de": "Die Anweisung DisableGadget schaltet ein Gadget-Objekt aus. Dadurch werden alle Eingaben ignoriert und zus\u00e4tzlich werden keine Events mehr zur\u00fcckgeliefert. EnableGadget ist eine Umkehrung zu diesem Befehl. "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "enablegadget": {
    "name": "EnableGadget",
    "description": {
      "en": "",
      "de": "Die Anweisung EnableGadget schaltet ein Gadget-Objekt ein. Dadurch werden alle Eingaben wieder zugelassen und zus\u00e4tzlich werden Events zur\u00fcckgeliefert. DisableGadget ist eine Umkehrung zu diesem Befehl. "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "freegadget": {
    "name": "FreeGadget",
    "description": {
      "en": "",
      "de": "Die Anweisung FreeGadget l\u00f6scht ein Gadget-Objekt und gibt alle verwendete Ressourcen frei. Oft k\u00f6nnen Objekte jedoch mit HideGadget versteckt und sp\u00e4ter mit ShowGadget wieder angezeigt werden. FreeGadget soll dagegen zum endg\u00fcltigen L\u00f6schen benutzt werden. "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "gadgetfont": {
    "name": "GadgetFont",
    "description": {
      "en": "",
      "de": "Die Funktion GadgetFont ermittelt die Identit\u00e4t einer Schrift aus einem Gadget-Objekt. Schrift kann mit SetGadgetFont ge\u00e4ndert werden. "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Identit\u00e4t einer Schrift" } },
    "code": ""
  },
  "gadgetgroup": {
    "name": "GadgetGroup",
    "description": {
      "en": "",
      "de": "Die Funktion GadgetGroup liefert die Identit\u00e4t des Parents (Gruppe) von einem Gadget-Objekt. "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Parent-Identit\u00e4t wird zur\u00fcckgeliefert." } },
    "code": ""
  },
  "gadgetheight": {
    "name": "GadgetHeight",
    "description": {
      "en": "",
      "de": "Die Funktion GadgetHeight ermittelt H\u00f6he eines Gadget-Objekts. Einige Objekte haben einen Rand, der aber nur mit ClientHeight ber\u00fccksichtigt werden kann. Siehe auch GadgetWidth. "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "H\u00f6he des Objekts mit Rand" } },
    "code": ""
  },
  "gadgettext": {
    "name": "GadgetText",
    "description": {
      "en": "",
      "de": "Die Funktion GadgetText liefert die Bezeichnung bzw. den Textwert eines Gadget-Objekts zur\u00fcck. Umgekehrt kann mit SetGadgetText ein Text zu einem Gadget-Objekt zugewiesen werden. Nicht alle Gadget-Objekte k\u00f6nnen Texte enthalten!"
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Die Bezeichnung bzw. der Wert eines Gadget-Objekts wird zur\u00fcckgeliefert."
      }
    },
    "code": ""
  },
  "gadgetwidth": {
    "name": "GadgetWidth",
    "description": {
      "en": "",
      "de": "Die Funktion GadgetWidth ermittelt Breite eines Gadget-Objekts. Einige Objekte haben einen Rand, der aber nur mit ClientWidth ber\u00fccksichtigt werden kann. Siehe auch GadgetHeight. "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Breite des Objekts mit Rand" } },
    "code": ""
  },
  "gadgetx": {
    "name": "GadgetX",
    "description": {
      "en": "",
      "de": "Die Funktion GadgetX liefert die X-Koordinate eines Gadget-Objekts - diese Position entspricht den relativen Koordinaten abh\u00e4ngig von Position des Parentobjekts. Die Funktion GadgetY erg\u00e4nzt diese Funktion. "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "X-Koordinate eines Gadget-Objekts" } },
    "code": ""
  },
  "gadgety": {
    "name": "GadgetY",
    "description": {
      "en": "",
      "de": "Die Funktion GadgetY liefert die Y-Koordinate eines Gadget-Objekts - diese Position entspricht den relativen Koordinaten abh\u00e4ngig von Position des Parentobjekts. Die Funktion GadgetX erg\u00e4nzt diese Funktion. "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Y-Koordinate eines Gadget-Objekts" } },
    "code": ""
  },
  "hidegadget": {
    "name": "HideGadget",
    "description": {
      "en": "",
      "de": "Die Anweisung HideGadget versteckt ein Gadget-Objekt. Erst mit ShowGadget wird es wieder sichtbar. Dies ist oft schneller als Objekte dauernd zu erstellen und wieder zu l\u00f6schen. Zudem werden alle angeh\u00e4ngte Objekte (childs) ebenfalls versteckt!"
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "queryobject": {
    "name": "QueryObject",
    "description": {
      "en": "",
      "de": "Die Funktion QueryObject liefert Windows-Handle (platformspezifisch) eines Objekts zur\u00fcck. Handle-Nummer wird aus Objekt-Handle (platformneutral) und Art-Nummer ermittelt. Windows-Handle wird oft f\u00fcr WinApi-Funktionen ben\u00f6tigt (bei Benutzung von Userlibs). "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Liefert Windows-Handle zur\u00fcck" } },
    "code": ""
  },
  "setgadgetfont": {
    "name": "SetGadgetFont",
    "description": {
      "en": "",
      "de": "Die Anweisung SetGadgetFont \u00e4ndert Schriftart eines Gadget-Objekts. Normalerweise wird Standardschrift verwendet. Andere Schriftart kann mit LoadFont geladen und zu einem Gadget zugewiesen werden. "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "setgadgetlayout": {
    "name": "SetGadgetLayout",
    "description": {
      "en": "",
      "de": "Die Anweisung SetGadgetLayout definiert Objektverankerung innerhalb einer Gruppe (parent). Wenn z.B. ein Fenster skaliert wird, dann l\u00e4sst sich die Gr\u00f6\u00dfe eines Objekts automatisch anpassen. Dies geschieht \u00fcber die vier Positionsanker Links, Rechts, Oben und Unten. Jedem Parameter kann dabei 0,1 oder 2 zugewiesen werden.   0=frei (Abstand zum Rand ver\u00e4ndert sich)  1=gesperrt (Abstand zum Rand wird beibehalten)  2=proportional (Gr\u00f6\u00dfe wird proportional ver\u00e4ndert)   Der Befehl SetGadgetShape \u00e4ndert die Gr\u00f6\u00dfe eines Objekts, falls dieses Feature nicht ausreicht. "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "setgadgetshape": {
    "name": "SetGadgetShape",
    "description": {
      "en": "",
      "de": "Die Anweisung SetGadgetShape ver\u00e4ndert die Gr\u00f6\u00dfe eines Gadget-Objekts. Gib dazu die Identit\u00e4t eines Objekts und dann X, Y, Breite und H\u00f6he ein. Ein Objekt kann auch automatisch skaliert werden - siehe dazu SetGadgetLayout. Die Funktionen GadgetX, GadgetY, GadgetWidth und GadgetHeight geben Position bzw. Gr\u00f6\u00dfe des Objekts zur\u00fcck. "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "setgadgettext": {
    "name": "SetGadgetText",
    "description": {
      "en": "",
      "de": "Die Anweisung SetGadgetText \u00e4ndert die Bezeichnung eines Objekts. Diese Funktion kann jedoch nicht auf alle Objekte angewendet werden. Nur Objekte, die Text enthalten, werden akzeptiert. Einige Objekte wie Textarea oder Textfield haben ihre eigene Funktionen!"
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "showgadget": {
    "name": "ShowGadget",
    "description": {
      "en": "",
      "de": "Die Anweisung ShowGadget zeigt ein Gadget-Objekt wieder an, das mit HideGadget zuvor versteckt wurde. Dies ist oft schneller als Objekte dauernd zu erstellen und wieder zu l\u00f6schen. Zudem werden alle angeh\u00e4ngte Objekte (childs) ebenfalls versteckt bzw. angezeigt! "
    },
    "category": "gui",
    "subCategory": "gadget",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "createhtmlview": {
    "name": "CreateHtmlView",
    "description": {
      "en": "",
      "de": "Diese erstellt ein Htmlview-Objekt. Gib dazu die Startkoordinate x/y und breite/h\u00f6he an. Gruppe ist die Identit\u00e4t eines Windows, Panels, Tabbers oder Canvas.   Htmlview ist ein Objekt zum Anzeigen von HTML-Seiten. Besonders n\u00fctzlich f\u00fcr Hilfe/Info oder zur Darstellung von Internetseiten. Mit HtmlViewBack, HtmlViewForward oder HtmlViewGo kann navigiert werden. "
    },
    "category": "gui",
    "subCategory": "html",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Identit\u00e4t eines Htmlview-Objekts" } },
    "code": ""
  },
  "htmlviewback": {
    "name": "HtmlViewBack",
    "description": {
      "en": "",
      "de": "Diese Anweisung zeigt die vorige Seite in einem Htmlview-Objekt. Sie l\u00f6st also das aus, was passieren w\u00fcrde, wenn der Benutzer in einem Browser auf \"Zur\u00fcck\" klicken w\u00fcrde."
    },
    "category": "gui",
    "subCategory": "html",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "htmlviewcurrenturl": {
    "name": "HtmlViewCurrentURL",
    "description": {
      "en": "",
      "de": "Diese Funktion gibt die Adresse der Seite zur\u00fcck, die das Htmlview-Objekt aktuell anzeigt."
    },
    "category": "gui",
    "subCategory": "html",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "String mit der aktuellen URL" } },
    "code": ""
  },
  "htmlvieweventurl": {
    "name": "HtmlViewEventURL",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt die Adresse, welche angeklickt wurde. WaitEvent h\u00e4lt dieses Event jedoch auf! Damit es funktioniert, muss bei CreateHtmlView der Style-Parameter \"NoNavigate\" gesetzt sein."
    },
    "category": "gui",
    "subCategory": "html",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "String mit URL" } },
    "code": ""
  },
  "htmlviewforward": {
    "name": "HtmlViewForward",
    "description": {
      "en": "",
      "de": "Diese Anweisung l\u00e4dt die nachfolgende Seite in ein Htmlview-Objekt. Sie macht damit das, was passiert, wenn ein Benutzer in einem Browser auf \"Vor\" klickt."
    },
    "category": "gui",
    "subCategory": "html",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "htmlviewgo": {
    "name": "HtmlViewGo",
    "description": {
      "en": "",
      "de": "Diese Funktion setzt eine Adresse, welche in einem Htmlview-Objekt angezeigt werden soll. \"about:blank\" zeigt beispielsweise eine leere Seite an."
    },
    "category": "gui",
    "subCategory": "html",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "htmlviewrun": {
    "name": "HtmlViewRun",
    "description": {
      "en": "",
      "de": "Diese Funktion f\u00fchrt Javascript-Code innerhalb eines Htmlview-Objekts aus. So k\u00f6nnen zum Beispiel JS-Funktionen aufgerufen werden oder Formulardaten ge\u00e4ndert werden."
    },
    "category": "gui",
    "subCategory": "html",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "htmlviewstatus": {
    "name": "HtmlViewStatus",
    "description": {
      "en": "",
      "de": "Diese Funktion liefert den Lade-Status einer Seite in einem Htmlview-Objekt zur\u00fcck. Bei 0 wurde die Seite komplett geladen und bei 1 ist der Ladevorgang noch nicht beendet."
    },
    "category": "gui",
    "subCategory": "html",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "0 = Seite geladen  1 = Seite wird geladen (busy)" } },
    "code": ""
  },
  "freeiconstrip": {
    "name": "FreeIconStrip",
    "description": {
      "en": "",
      "de": "Die Anweisung FreeIconStrip l\u00f6scht ein Icon-Set aus dem Speicher, das vorher mit LoadIconStrip geladen wurde. FreeIconStrip ist dann wichtig, wenn Icons w\u00e4hrend der Laufzeit dauernd geladen und gel\u00f6scht werden. BlitzBasic kann automatisch beim Beenden den Speicher freigeben. "
    },
    "category": "gui",
    "subCategory": "icon-strip",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "loadiconstrip": {
    "name": "LoadIconStrip",
    "description": {
      "en": "",
      "de": "Die Funktion LoadIconStrip l\u00e4dt eine Grafikdatei. Diese Grafikdatei enth\u00e4lt Icons die alle nebeneinander angeordnet sind. Diese Icons k\u00f6nnen sp\u00e4ter f\u00fcr Listen und Tabber verwendet werden (siehe auch SetGadgetIconStrip). "
    },
    "category": "gui",
    "subCategory": "icon-strip",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Identit\u00e4t der Icons wird zur\u00fcckgeliefert" } },
    "code": ""
  },
  "setgadgeticonstrip": {
    "name": "SetGadgetIconStrip",
    "description": {
      "en": "",
      "de": "Die Anweisung SetGadgetIconStrip weist Combobox, Listbox oder Tabber ein Icon-Set zu. Diese Icons m\u00fcssen aber zuerst mit LoadIconStrip geladen werden. Nach der Zuweisung k\u00f6nnen Icons beim Hinzuf\u00fcgen/\u00c4ndern mit AddGadgetItem, InsertGadgetItem oder ModifyGadgetItem ausgew\u00e4hlt werden. "
    },
    "category": "gui",
    "subCategory": "icon-strip",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "addgadgetitem": {
    "name": "AddGadgetItem",
    "description": {
      "en": "",
      "de": "Diese Anweisung f\u00fcgt einen Eintrag zu einem Objekt (gadget) hinzu. Das funktioniert nur mit wenigen Objekten - nur dort, wo es sinnvoll ist. So kann diese Anweisung auf ListBox, ComboBox und Tabber angewendet werden. Mit InsertGadgetItem k\u00f6nnen Eintr\u00e4ge an eine beliebige Position eingef\u00fcgt werden."
    },
    "category": "gui",
    "subCategory": "list-tabber",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "cleargadgetitems": {
    "name": "ClearGadgetItems",
    "description": {
      "en": "",
      "de": "Diese Anweisung l\u00f6scht komplett alle Eintr\u00e4ge eines Gadget-Objekts. Das funktioniert nur mit wenigen Objekten - nur dort, wo es sinnvoll ist. So kann diese Anweisung auf ListBox, ComboBox und Tabber angewendet werden. Mit RemoveGadgetItem kann ein einzelner Eintrag gel\u00f6scht werden. Mit FreeGadget kann ein Objekt komplett gel\u00f6scht werden."
    },
    "category": "gui",
    "subCategory": "list-tabber",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "countgadgetitems": {
    "name": "CountGadgetItems",
    "description": {
      "en": "",
      "de": "Diese Funktion liefert die Anzahl der Eintr\u00e4ge einer ListBox, ComboBox oder eines Tabbers zur\u00fcck. Solche Eintr\u00e4ge k\u00f6nnen mit AddGadgetItem / InsertGadgetItem hinzugef\u00fcgt und mit RemoveGadgetItemgel\u00f6scht werden."
    },
    "category": "gui",
    "subCategory": "list-tabber",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Anzahl der Eintr\u00e4ge des Objekts" } },
    "code": ""
  },
  "createcombobox": {
    "name": "CreateComboBox",
    "description": {
      "en": "",
      "de": "Diese Funktion erstellt ein Combobox-Objekt. Gebe dazu die Startkoordinate x/y und breite/h\u00f6he an. Gruppe ist die Identit\u00e4t eines Windows, Panels, Tabbers oder Canvas.   Mit AddGadgetItem / InsertGadgetItem k\u00f6nnen Eintr\u00e4ge hinzugef\u00fcgt und mit RemoveGadgetItem entfernt werden. SelectGadgetItem w\u00e4hlt einen Eintrag aus und SelectedGadgetItem gibt zur\u00fcck, welcher Eintrag (vom Benutzer) ausgew\u00e4hlt wurde. "
    },
    "category": "gui",
    "subCategory": "list-tabber",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Identit\u00e4t des Combobox-Objekts" } },
    "code": ""
  },
  "createlistbox": {
    "name": "CreateListBox",
    "description": {
      "en": "",
      "de": "Diese Funktion erstellt ein Listbox-Objekt (=einfache Liste). Gib dazu die Startkoordinate x/y und breite/h\u00f6he an. Gruppe ist die Identit\u00e4t eines Windows, Panels, Tabbers oder Canvas.   Mit AddGadgetItem / InsertGadgetItem k\u00f6nnen Eintr\u00e4ge hinzugef\u00fcgt und mit RemoveGadgetItem entfernt werden. SelectGadgetItem w\u00e4hlt einen Eintrag aus und SelectedGadgetItem gibt zur\u00fcck, welcher Eintrag (vom Benutzer) ausgew\u00e4hlt wurde. "
    },
    "category": "gui",
    "subCategory": "list-tabber",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Identit\u00e4t des Listbox-Objekts" } },
    "code": ""
  },
  "createtabber": {
    "name": "CreateTabber",
    "description": {
      "en": "",
      "de": "Diese Funktion erstellt ein Tabber-Objekt (f\u00fcr Registerkarten). Gebe dazu die Startkoordinate X/Y und Breite/H\u00f6he an. Gruppe ist die Identit\u00e4t eines Windows, Panels oder Canvas.   Mit AddGadgetItem / InsertGadgetItem k\u00f6nnen Eintr\u00e4ge (Registerkarten oder \"Tabs\" genannt) hinzugef\u00fcgt und mit RemoveGadgetItem entfernt werden. SelectGadgetItem w\u00e4hlt eine Registerkarte aus und SelectedGadgetItem gibt zur\u00fcck, welche Registerkarte (vom Benutzer) ausgew\u00e4hlt wurde."
    },
    "category": "gui",
    "subCategory": "list-tabber",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Identit\u00e4t eines Tabber-Objekts" } },
    "code": ""
  },
  "gadgetitemtext": {
    "name": "GadgetItemText",
    "description": {
      "en": "",
      "de": "Diese Funktion liefert die Bezeichnung eines Elements aus einem Gadget-Objekt. Das funktioniert nur mit wenigen Objekten - nur dort, wo es sinnvoll ist. So kann diese Anweisung auf ListBox, ComboBox und Tabber angewendet werden. Mit ModifyGadgetItem kann die Bezeichnung ge\u00e4ndert werden."
    },
    "category": "gui",
    "subCategory": "list-tabber",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Bezeichnung des Elements" } },
    "code": ""
  },
  "insertgadgetitem": {
    "name": "InsertGadgetItem",
    "description": {
      "en": "",
      "de": "Diese Anweisung f\u00fcgt einen Eintrag an beliebige Position zu einem Objekt (gadget) hinzu. Das funktioniert nur mit wenigen Objekten - nur dort, wo es sinnvoll ist. So kann diese Anweisung auf ListBox, ComboBox und Tabber angewendet werden. Mit AddGadgetItem k\u00f6nnen Eintr\u00e4ge hinten an einem Objekt angeh\u00e4ngt werden."
    },
    "category": "gui",
    "subCategory": "list-tabber",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "modifygadgetitem": {
    "name": "ModifyGadgetItem",
    "description": {
      "en": "",
      "de": "Diese Anweisung \u00e4ndert die Bezeichnung eines Eintrages. Das funktioniert nur mit wenigen Objekten - nur dort, wo es sinnvoll ist. So kann diese Anweisung auf ListBox, ComboBox und Tabber angewendet werden. Die Funktion GadgetItemText liefert die aktuelle Bezeichnung eines Eintrags."
    },
    "category": "gui",
    "subCategory": "list-tabber",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "removegadgetitem": {
    "name": "RemoveGadgetItem",
    "description": {
      "en": "",
      "de": "Diese Anweisung entfernt einen Eintrag aus einem Gadget-Objekt. Das funktioniert nur mit wenigen Objekten - nur dort, wo es sinnvoll ist. So kann diese Anweisung auf ListBox, ComboBox und Tabber angewendet werden. Mit AddGadgetItem oder InsertGadgetItem k\u00f6nnen Eintr\u00e4ge (wieder) eingef\u00fcgt werden."
    },
    "category": "gui",
    "subCategory": "list-tabber",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "selectedgadgetitem": {
    "name": "SelectedGadgetItem",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt ausgew\u00e4hlten Eintrag eines Gadget-Objekts. Das funktioniert nur mit wenigen Objekten - nur dort, wo es sinnvoll ist. So kann diese Anweisung auf ListBox, ComboBox und Tabber angewendet werden. Mit SelectGadgetItem k\u00f6nnen Eintr\u00e4ge manuell ausgew\u00e4hlt werden."
    },
    "category": "gui",
    "subCategory": "list-tabber",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Indexnummer des ausgew\u00e4hlten Eintrags. Wurde bisher kein Eintrag ausgew\u00e4hlt, wird -1 zur\u00fcckgegeben."
      }
    },
    "code": ""
  },
  "selectgadgetitem": {
    "name": "SelectGadgetItem",
    "description": {
      "en": "",
      "de": "Diese Anweisung w\u00e4hlt einen Eintrag in einem Gadget-Objekt aus. Das funktioniert nur mit wenigen Objekten - nur dort, wo es sinnvoll ist. So kann diese Anweisung auf ListBox, ComboBox und Tabber angewendet werden. Mit SelectedGadgetItem kann man den (eventuell vom Benutzer) ausgew\u00e4hlten Eintrag ermitteln.   Der Startwert von Index liegt bei 0. Null entspricht also dem ersten Eintrag. Wird -1 angegeben, dann wird die Auswahl aufgehoben."
    },
    "category": "gui",
    "subCategory": "list-tabber",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "checkmenu": {
    "name": "CheckMenu",
    "description": {
      "en": "",
      "de": "Die Anweisung CheckMenu setzt einen Hacken vor einem Men\u00fcpunkt. Hierzu wird die Identit\u00e4t des Men\u00fcs ben\u00f6tigt (ermittelt mit CreateMenu). Mit UncheckMenu kann dieser Hacken ausgeschaltet werden. Mit MenuChecked l\u00e4sst sich ermitteln, ob ein Hacken gesetzt ist. Zu einem Hauptmen\u00fc kann kein Hacken hinzugef\u00fcgt werden. "
    },
    "category": "gui",
    "subCategory": "menu",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "createmenu": {
    "name": "CreateMenu",
    "description": {
      "en": "",
      "de": "Die Funktion CreateMenu erstellt ein Men\u00fc oder Men\u00fcpunkt. Parameter \"nummer\" muss eine einzigartige Nummer f\u00fcr Men\u00fc oder Men\u00fcpunkt sein. Diese Nummer wird nur f\u00fcr Windows und f\u00fcr Event-Handling ben\u00f6tigt. \"parent\" ist die Identit\u00e4t eines Men\u00fcs, zu dem dieses Men\u00fc hinzugef\u00fcgt werden soll. F\u00fcr Men\u00fcs wie Datei, Bearbeiten oder Ansicht muss WindowMenu angegeben werden. Danach k\u00f6nnen weitere Men\u00fcpunkte zu diesen Men\u00fcs hinzugef\u00fcgt werden. Verschachtelte Men\u00fcs sind ebenfalls m\u00f6glich (siehe Beispiel).   Eine Trennlinie wird erzeugt, indem einfach ein leerer Text angegeben wird. Men\u00fcpunkte lassen sich mit EnableMenu / DisableMenu ein- oder ausschalten. Mit CheckMenu / UncheckMenu kann man einen Haken setzten oder l\u00f6schen. Ein Men\u00fc muss auf jeden Fall nach einer \u00c4nderung mit UpdateWindowMenu aktualisiert werden. "
    },
    "category": "gui",
    "subCategory": "menu",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t des Men\u00fc-Objekts wird zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "disablemenu": {
    "name": "DisableMenu",
    "description": {
      "en": "",
      "de": "Die Anweisung DisableMenu schaltet ein Men\u00fc aus. Dadurch werden alle Eingaben ignoriert und zus\u00e4tzlich werden keine Events mehr zur\u00fcckgeliefert. EnableMenu ist eine Umkehrung zu diesem Befehl. "
    },
    "category": "gui",
    "subCategory": "menu",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "enablemenu": {
    "name": "EnableMenu",
    "description": {
      "en": "",
      "de": "Die Anweisung EnableMenu schaltet ein Men\u00fc ein. Dadurch werden alle Eingaben wieder zugelassen und zus\u00e4tzlich werden Events zur\u00fcckgeliefert. DisableMenu ist eine Umkehrung zu diesem Befehl. "
    },
    "category": "gui",
    "subCategory": "menu",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "menuchecked": {
    "name": "MenuChecked",
    "description": {
      "en": "",
      "de": "Die Funktion MenuChecked ermittelt, ob ein Haken vor einem Men\u00fc gesetzt wurde. Dieser Haken kann mit CheckMenu gesetzt und mit UncheckMenu entfernt werden. Nachdem ein Men\u00fc ge\u00e4ndert wurde, muss UpdateWindowMenu auf jeden Fall aufgerufen werden - da das Men\u00fc sonst nicht ge\u00e4ndert wird. "
    },
    "category": "gui",
    "subCategory": "menu",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "0 = Haken ausgeschaltet  1 = Haken eingeschaltet" } },
    "code": ""
  },
  "menuenabled": {
    "name": "MenuEnabled",
    "description": {
      "en": "",
      "de": "Die Funktion MenuEnabled ermittelt, ob ein Men\u00fc ausgeschaltet ist. Men\u00fc kann mit DisableMenu ausgeschaltet und mit EnableMenu eingeschaltet werden. Nachdem ein Men\u00fc ge\u00e4ndert wurde, muss UpdateWindowMenu auf jeden Fall aufgerufen werden - da das Men\u00fc sonst nicht ge\u00e4ndert wird. "
    },
    "category": "gui",
    "subCategory": "menu",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0 = Men\u00fc ausgeschaltet  1 = Men\u00fc eingeschaltet" }
    },
    "code": ""
  },
  "menutext": {
    "name": "MenuText",
    "description": {
      "en": "",
      "de": "Die Funktion MenuText liefert die Bezeichnung eines Men\u00fcs zur\u00fcck. Umgekehrt kann mit SetMenuText auch Men\u00fcText ge\u00e4ndert werden. "
    },
    "category": "gui",
    "subCategory": "menu",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Die Bezeichnung des Men\u00fcs wird zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "setmenutext": {
    "name": "SetMenuText",
    "description": {
      "en": "",
      "de": "Die Anweisung SetMenuText \u00e4ndert die Bezeichnung eines Men\u00fcs. Der Text kann nur ge\u00e4ndert, jedoch nicht wieder ausgelesen werden! "
    },
    "category": "gui",
    "subCategory": "menu",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "uncheckmenu": {
    "name": "UncheckMenu",
    "description": {
      "en": "",
      "de": "Die Anweisung UncheckMenu entfernt einen Haken vor einem Men\u00fcpunkt. Hierzu wird die Identit\u00e4t des Men\u00fcs ben\u00f6tigt (ermittelt mit CreateMenu). Mit CheckMenu kann dieser Haken eingeschaltet werden. Mit MenuChecked l\u00e4sst sich ermitteln, ob ein Haken gesetzt ist. Zu einem Hauptmen\u00fc kann kein Haken hinzugef\u00fcgt werden. "
    },
    "category": "gui",
    "subCategory": "menu",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "updatewindowmenu": {
    "name": "UpdateWindowMenu",
    "description": {
      "en": "",
      "de": "Die Anweisung UpdateWindowMenu aktualisiert das Men\u00fc in einem Fenster. Dies ist nur dann erforderlich, wenn eins dieser Befehle ausgef\u00fchrt wird: CheckMenu, CreateMenu, DisableMenu, EnableMenu, SetMenuText, UncheckMenu. "
    },
    "category": "gui",
    "subCategory": "window",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "windowmenu": {
    "name": "WindowMenu",
    "description": {
      "en": "",
      "de": "Die Funktion WindowMenu ermittelt die Identit\u00e4t eines Root-Men\u00fcs, das zu einem Fenster zugeordnet ist. Wenn ein Fenster mit CreateWindow erstellt wird, dann enth\u00e4lt dieses Fenster noch kein Men\u00fc. Darum kann mit WindowMenu ein imagin\u00e4res Men\u00fc ermittelt werden. Dieses Men\u00fc stellt die h\u00f6chste Ebene dar und neue Men\u00fcs m\u00fcssen zu diesem Root-Men\u00fc hinzugef\u00fcgt werden. "
    },
    "category": "gui",
    "subCategory": "window",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t des \"h\u00f6chsten\" Men\u00fcs (Root-Menu bzw. Window-Menu)"
      }
    },
    "code": ""
  },
  "createpanel": {
    "name": "CreatePanel",
    "description": {
      "en": "",
      "de": "Die Funktion CreatePanel erstellt ein Panel-Objekt. Gib dazu die Startkoordinate x/y und breite/h\u00f6he an. gruppe ist die Identit\u00e4t von Window, Tabber, Canvas oder Panel. style 1 schaltet einen Rahmen ein. "
    },
    "category": "gui",
    "subCategory": "panel",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t eines Panel-Objekts wird zur\u00fcck geliefert" }
    },
    "code": ""
  },
  "setpanelcolor": {
    "name": "SetPanelColor",
    "description": {
      "en": "",
      "de": "Die Anweisung SetPanelColor \u00e4ndert die Hintergrundfarbe von Panel-Objekt. Somit kann man einen gef\u00fcllten Rechteck zeichnen. SetPanelImage l\u00e4dt dagegen ein Hintergrundbild und zeichnet es ein.   Panel ist einfach ein Objekt zum Gruppieren von anderen Objekten. Man kann somit weitere Objekte zu diesem Objekt hinzuf\u00fcgen. "
    },
    "category": "gui",
    "subCategory": "panel",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "setpanelimage": {
    "name": "SetPanelImage",
    "description": {
      "en": "",
      "de": "Die Anweisung SetPanelImage weist einem Panel-Objekt eine Hintergrundgrafik zu. Diese Grafik wird aus einer Datei geladen und sofort dargestellt. Sollte Panel-Objekt gr\u00f6\u00dfer als das Bild sein, dann wird das Bild gekachelt dargestellt. SetPanelColor setzt dagegen eine Hintergrundfarbe fest.   Panel ist einfach ein Objekt zum Gruppieren von anderen Objekten. Man kann somit weitere Objekte zu diesem Objekt hinzuf\u00fcgen. "
    },
    "category": "gui",
    "subCategory": "panel",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "createprogbar": {
    "name": "CreateProgBar",
    "description": {
      "en": "",
      "de": "Die Anweisung UpdateProgBar \u00e4ndert einen Fortschrittsbalken, der mit CreateProgBar erstellt wurde. Dabei werden Werte 0 bis 1 akzeptiert. 0 bedeutet 0%, 0.5 bedeutet 50% und 1 bedeutet 100% (beliebige Zwischenschritte m\u00f6glich).   Progbar wird meistens bei komplexen Berechnungen eingeblendet, um den Fortschritt des Prozesses zu zeigen. Die Funktion CreateProgBar erstellt ein Progbar-Objekt. Gib dazu die Startkoordinate x/y und breite/h\u00f6he an. Gruppe ist die Identit\u00e4t von Window, Panel, Tabber oder Canvas.   Progbar ist ein einfacher Prozess-Balken. Es wird meistens bei komplexen Berechnungen eingeblendet, um den Fortschritt des Prozesses zu zeigen. "
    },
    "category": "gui",
    "subCategory": "progress-bar",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t eines Progbar-Objekts wird zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "updateprogbar": {
    "name": "UpdateProgBar",
    "description": {
      "en": "",
      "de": "Die Anweisung UpdateProgBar \u00e4ndert einen Fortschrittsbalken, der mit CreateProgBar erstellt wurde. Dabei werden Werte 0 bis 1 akzeptiert. 0 bedeutet 0%, 0.5 bedeutet 50% und 1 bedeutet 100% (beliebige Zwischenschritte m\u00f6glich).   Progbar wird meistens bei komplexen Berechnungen eingeblendet, um den Fortschritt des Prozesses zu zeigen. "
    },
    "category": "gui",
    "subCategory": "progress-bar",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "confirm": {
    "name": "Confirm",
    "description": {
      "en": "",
      "de": "Die Anweisung Confirm blendet eine Nachricht ein, die 2 Buttons enth\u00e4lt: OK und ABBRECHEN. Gib dazu einfach einen Text ein. Zeilenumbruch kann mit Chr$(13) erfolgen. Wird Warnung auf 1 gesetzt, dann erscheint ein Warnsymbol statt Infosymbol.  Wenn dieses Dialog abgebrochen wurde, dann wird 0 zur\u00fcckgeliefert - ansonsten 1. "
    },
    "category": "gui",
    "subCategory": "request",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "0 - Klick auf Abbrechen  1 - Klick auf OK" } },
    "code": ""
  },
  "notify": {
    "name": "Notify",
    "description": {
      "en": "",
      "de": "Die Anweisung Notify blendet eine Nachricht ein, die nur ein OK-Button enth\u00e4lt. Gib dazu einfach einen Text ein. Zeilenumbruch kann mit Chr$(13) erfolgen. Wird Warnung auf 1 gesetzt, dann erscheint ein Warnsymbol statt Infosymbol. "
    },
    "category": "gui",
    "subCategory": "request",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "proceed": {
    "name": "Proceed",
    "description": {
      "en": "",
      "de": "Die Anweisung Proceed blendet eine Nachricht ein, die 3 Buttons enth\u00e4lt: JA, NEIN, ABBRECHEN. Gib dazu einfach einen Text ein. Zeilenumbruch kann mit CHR$(13) erfolgen. Wird Warnung auf 1 gesetzt, dann erscheint ein Warnsymbol statt Infosymbol. "
    },
    "category": "gui",
    "subCategory": "request",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "1=Klick auf JA  0=Klick auf NEIN  -1=Klick auf ABBRECHEN " }
    },
    "code": ""
  },
  "requestcolor": {
    "name": "RequestColor",
    "description": {
      "en": "",
      "de": "Die Funktion RequestColor blendet einen Standarddialog zur Auswahl einer Farbe ein. Die drei Parameter geben eine Farbe vor, die bereits beim \u00d6ffnen des Dialogs ausgew\u00e4hlt wird. "
    },
    "category": "gui",
    "subCategory": "request",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0=Dialog wurde abgebrochen  1=Farbe wurde ausgew\u00e4hlt" }
    },
    "code": ""
  },
  "requestdir": {
    "name": "RequestDir",
    "description": {
      "en": "",
      "de": "Die Funktion RequestDir blendet einen Standarddialog zur Auswahl eines Ordners ein. Der optionale Parameter \"Titel\" kann ein kurzer Text sein, der dann im Fenster erscheint. Es kann auch ein Startpfad vorgegeben werden. Wurde ein Ordner ausgew\u00e4hlt und auf OK geklickt, dann wird der komplette Pfad zur\u00fcckgeliefert. Wurde die Auswahl abgebrochen, dann wird ein leerer String zur\u00fcckgeliefert. "
    },
    "category": "gui",
    "subCategory": "request",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Es wird ein Pfad zur\u00fcckgeliefert. Wurde die Auswahl abgebrochen, dann wird ein leerer String zur\u00fcckgeliefert."
      }
    },
    "code": ""
  },
  "requestedblue": {
    "name": "RequestedBlue",
    "description": {
      "en": "",
      "de": "Die Funktion RequestedBlue ermittelt eine Farbe, die zuletzt mit RequestColor ausgew\u00e4hlt wurde. Weitere Funktionen wie RequestedGreen und RequestedRed erg\u00e4nzen diese Funktion. "
    },
    "category": "gui",
    "subCategory": "request",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0-255 = Blauanteil der zuletzt ausgew\u00e4hlten Farbe" }
    },
    "code": ""
  },
  "requestedgreen": {
    "name": "RequestedGreen",
    "description": {
      "en": "",
      "de": "Die Funktion RequestedGreen ermittelt eine Farbe, die zuletzt mit RequestColor ausgew\u00e4hlt wurde. Weitere Funktionen wie RequestedBlue und RequestedRed erg\u00e4nzen diese Funktion. "
    },
    "category": "gui",
    "subCategory": "request",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0-255 = Gr\u00fcnanteil der zuletzt ausgew\u00e4hlten Farbe" }
    },
    "code": ""
  },
  "requestedred": {
    "name": "RequestedRed",
    "description": {
      "en": "",
      "de": "Die Funktion RequestedRed ermittelt eine Farbe, die zuletzt mit RequestColor ausgew\u00e4hlt wurde. Weitere Funktionen wie RequestedGreen und RequestedBlue erg\u00e4nzen diese Funktion. "
    },
    "category": "gui",
    "subCategory": "request",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0-255 = Rotanteil der zuletzt ausgew\u00e4hlten Farbe" }
    },
    "code": ""
  },
  "requestfile": {
    "name": "RequestFile",
    "description": {
      "en": "",
      "de": "Die Funktion RequestFile blendet einen Standarddialog zur Auswahl einer Datei ein. \"titel\" ist ein Text, der in Titelleiste erscheinen soll. \"type\" ist ein String mit 1 oder mehr Dateitypen (alle Dateitypen m\u00fcssen mit Komma getrennt werden). Nur ausgew\u00e4hlte Dateitypen werden angezeigt. Wird \"Speichern\" auf 1 gesetzt, dann wird zus\u00e4tzlich abgefragt, ob eine Datei \u00fcberschrieben werden soll.   Wurde eine Datei ausgew\u00e4hlt und auf OK geklickt, dann wird der komplette Pfad zur\u00fcckgeliefert. Wurde die Auswahl abgebrochen, dann wird ein leerer String zur\u00fcckgeliefert. "
    },
    "category": "gui",
    "subCategory": "request",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Dateiname wird zur\u00fcckgeliefert. Wurde die Auswahl abgebrochen, dann wird ein leerer String zur\u00fcckgeliefert."
      }
    },
    "code": ""
  },
  "requestfont": {
    "name": "RequestFont",
    "description": {
      "en": "",
      "de": "Die Funktion RequestFont blendet einen Standarddialog zur Auswahl einer Schrift ein. Wurde eine Schrift ausgew\u00e4hlt und auf OK geklickt, dann wird diese Schrift geladen und die Identit\u00e4t der Schrift zur\u00fcckgeliefert. Wurde die Auswahl abgebrochen, dann wird 0 zur\u00fcckgeliefert. "
    },
    "category": "gui",
    "subCategory": "request",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t einer Schrift wird zur\u00fcckgeliefert. Bei 0 wurde die Auswahl abgebrochen."
      }
    },
    "code": ""
  },
  "createslider": {
    "name": "CreateSlider",
    "description": {
      "en": "",
      "de": "Die Funktion CreateSlider erstellt ein Slider Objekt. Gib dazu die Startkoordinate X/Y und Breite/H\u00f6he an. Gruppe ist die Identit\u00e4t von Window, Panel, Tabber oder Canvas. Style 1 ist ein horizontaler Balken, Style 2 ist ein vertikaler Balken.   Slider ist ein einfacher Scrollbalken. F\u00fcr Listen werden keine zus\u00e4tzliche Balken ben\u00f6tigt. Mit SetSliderRange oder SetSliderValue kann man den Slider einstellen. "
    },
    "category": "gui",
    "subCategory": "slider",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t eines Slider Objekts wird zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "setsliderrange": {
    "name": "SetSliderRange",
    "description": {
      "en": "",
      "de": "Die Anweisung SetSliderRange definiert den Bewegungsbereich eines Slider Objekts. Der Parameter \"Sichtbar\" gibt die sichtbare Breite/H\u00f6he an (z.B. sichtbare Eintr\u00e4ge oder sichtbare Gr\u00f6\u00dfe eines Bildes). Der Parameter \"Total\" gibt die Gesamtgr\u00f6\u00dfe an (z.B. Anzahl der Eintr\u00e4ge oder Gr\u00f6\u00dfe eines Bildes).   Mit SetSliderValue kann die Position eingestellt werden. Mit SliderValue kann aktuelle Position ausgelesen werden."
    },
    "category": "gui",
    "subCategory": "slider",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "setslidervalue": {
    "name": "SetSliderValue",
    "description": {
      "en": "",
      "de": "Die Anweisung SetSliderValue setzt die Position von Slider-Objekt fest. Dieser Wert f\u00e4ngt ab 0 an und endet mit maximal eingestelltem Wert (Total minus Sichtbar).   Der Bewegungsbereich kann mit SetSliderRange eingestellt werden. Aktuelle Position kann mit SliderValue abgefragt werden. "
    },
    "category": "gui",
    "subCategory": "slider",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "slidervalue": {
    "name": "SliderValue",
    "description": {
      "en": "",
      "de": "Die Funktion SliderValue ermittelt aktuelle Position bzw. Wert eines Slider Objekts. Dies ist meistens nach einem Event n\u00fctzlich. Dieser Wert f\u00e4ngt ab 0 an und endet mit maximal eingestelltem Wert (Total minus Sichtbar).   Der Bewegungsbereich kann mit SetSliderRange eingestellt werden. Position kann mit SetSliderValue ge\u00e4ndert werden. "
    },
    "category": "gui",
    "subCategory": "slider",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Position bzw. Wert eines Sliders wird zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "addtextareatext": {
    "name": "AddTextAreaText",
    "description": {
      "en": "",
      "de": "Die Anweisung AddTextAreaText f\u00fcgt Text immer ganz hinten in ein Textarea-Objekt ein. Textarea ist ein RichTextBox-Objekt - somit l\u00e4sst sich Schriftart oder Schriftfarbe einstellen (siehe dazu SetTextAreaFont, SetTextAreaColor). Mit TextAreaText kann kompletter Text als String wieder ausgelesen werden (ohne Formatierungen!) "
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "createtextarea": {
    "name": "CreateTextArea",
    "description": {
      "en": "",
      "de": "Die Funktion CreateTextArea erstellt ein Textarea-Objekt. Gib dazu die Startkoordinate x/y und breite/h\u00f6he an. Gruppe ist die Identit\u00e4t von Window, Panel, Tabber oder Canvas.   Textarea ist ein RichTextBox-Objekt - somit l\u00e4sst sich Schriftart oder Schriftfarbe einstellen (siehe dazu SetTextAreaFont, SetTextAreaColor).  SetGadgetText l\u00f6scht alten Text und setzt neuen Text.  AddTextAreaText f\u00fcgt Text hinten in ein Textarea-Objekt ein.  Mit TextAreaText kann kompletter Text als String wieder ausgelesen werden. "
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t des Textarea-Objekts wird zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "formattextareatext": {
    "name": "FormatTextAreaText",
    "description": {
      "en": "",
      "de": "Die Anweisung FormatTextAreaText \u00e4ndert die Formatierung eines Textes in Textarea-Objekt. Hierzu z\u00e4hlt die Farb\u00e4nderung und Style\u00e4nderung (fett oder kursiv). Die Position und L\u00e4nge kann bestimmt werden. Die Einheit ist entweder in Zeichen oder Zeilen. Siehe auch SetTextAreaColor und SetTextAreaFont. "
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "locktextarea": {
    "name": "LockTextArea",
    "description": {
      "en": "",
      "de": "Die Anweisung LockTextArea sperrt Textarea-Objekt f\u00fcr Format\u00e4nderung. Dies sollte geschehen bevor Text modifiziert wird. Danach muss es wieder mit UnlockTextArea ge\u00f6ffnet werden. Diese Methode verhindert visuelle Flimmereffekte und beschleunigt ein Programm. "
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "settextareacolor": {
    "name": "SetTextAreaColor",
    "description": {
      "en": "",
      "de": "Die Anweisung SetTextAreaColor setzt Textfarbe oder Hintergrundfarbe von Textarea-Objekt. Parameter Rot, Gr\u00fcn und Blau sind die Farbanteile im Bereich von 0 bis 255.  Wird Parameter \"Hintergrund\" auf 0 gesetzt, dann wird Farbe des ganzen Textes ge\u00e4ndert.  Wird Parameter \"Hintergrund\" auf 1 gesetzt, dann wird Hintergrundfarbe des ganzen Objekts ge\u00e4ndert.  Der Befehl SetTextAreaFont \u00e4ndert die Schriftart und SetTextAreaTabs \u00e4ndert Tabulatoreinstellung. "
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "settextareafont": {
    "name": "SetTextAreaFont",
    "description": {
      "en": "",
      "de": "Die Anweisung SetTextAreaFont setzt andere Schriftart in Textarea-Objekt. Der Parameter \"Schrift\" ist die Identit\u00e4t einer Schrift, die mit LoadFont ermittelt wurde. Diese \u00c4nderung wird auf kompletten Text angewendet.   Der Befehl SetTextAreaColor \u00e4ndert Schriftfarbe oder Hintergrundfarbe.  Der Befehl SetTextAreaTabs \u00e4ndert Tabulatoreinstellung. "
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "settextareatabs": {
    "name": "SetTextAreaTabs",
    "description": {
      "en": "",
      "de": "Die Anweisung SetTextAreaTabs stellt Tabulatorgr\u00f6\u00dfe in Textarea-Objekt ein. Die Tabulatorgr\u00f6\u00dfe ist von Schriftart unabh\u00e4ngig und kann jederzeit auf ganzes Objekt angewendet werden.   Der Befehl SetTextAreaColor \u00e4ndert Schriftfarbe oder Hintergrundfarbe. Der Befehl SetTextAreaFont \u00e4ndert die Schriftart. "
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "settextareatext": {
    "name": "SetTextAreaText",
    "description": {
      "en": "",
      "de": "Die Anweisung SetTextAreaText f\u00fcgt einen neuen Text in Textarea-Objekt ein. Position und \u00dcberschreibl\u00e4nge kann beliebig bestimmt werden. Einheit ist entweder in Zeichen oder in Zeilen.   Mit AddTextAreaText kann Text immer nur hinzugef\u00fcgt werden. Mit SetGadgetText kann kompletter Text ersetzt werden."
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "textareachar": {
    "name": "TextAreaChar",
    "description": {
      "en": "",
      "de": "Die Funktion TextAreaChar ermittelt die Position des ersten Zeichens einer Zeile in Textarea-Objekt.  Gebe hierzu einfach die Identit\u00e4t von Textarea-Objekt und Nummer der Zeile an. Nach TextAreaText kann Text ab dieser Position ausgelesen werden."
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Startposition des ersten Zeichens" } },
    "code": ""
  },
  "textareacursor": {
    "name": "TextAreaCursor",
    "description": {
      "en": "",
      "de": "Die Funktion TextAreaCursor liefert die Position des Textcursors. Gebe hierzu Identit\u00e4t von Textarea und Einheit-Code an. Je nach Einheit-Code kann Zeichenposition oder Zeilenposition ermittelt werden. "
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Position des Cursors wird zur\u00fcckgeliefert" } },
    "code": ""
  },
  "textarealen": {
    "name": "TextAreaLen",
    "description": {
      "en": "",
      "de": "Die Funktion TextAreaLen ermittelt Anzahl der Zeichen/Zeilen in einem Textarea-Objekt. Hierzu wird die Identit\u00e4t von Textarea ben\u00f6tigt und Einheit-Code (1=Zeichen, 2=Zeilen). "
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Liefert Anzahl der Zeichen/Zeilen zur\u00fcck" } },
    "code": ""
  },
  "textarealine": {
    "name": "TextAreaLine",
    "description": {
      "en": "",
      "de": "Die Funktion TextAreaLine ermittelt Zeilennummer aus Position eines Zeichens in einem Textarea-Objekt. Mit TextAreaText kann ja kompletter Text ausgelesen werden - dabei wird Position ab Anfang des Strings ber\u00fccksichtigt."
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Nummer der Zeile wird zur\u00fcckgeliefert" } },
    "code": ""
  },
  "textarealinelen": {
    "name": "TextAreaLineLen",
    "description": {
      "en": "",
      "de": "Die Funktion TextAreaLineLen ermittelt die Anzahl der Zeichen einer Zeile in Textarea-Objekt. Gebe hierzu einfach die Identit\u00e4t von Textarea-Objekt und Nummer der Zeile an."
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Anzahl der Zeichen wird zur\u00fcckgeliefert" } },
    "code": ""
  },
  "textareasellen": {
    "name": "TextAreaSelLen",
    "description": {
      "en": "",
      "de": "Die Funktion TextAreaSelLen ermittelt die Anzahl markierter Zeichen oder Zeilen in Textarea-Objekt. Gebe hierzu einfach die Identit\u00e4t eines Textarea-Objekts und Einheit-Code an. "
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Anzahl der Zeichen/Zeilen wird zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "textareatext": {
    "name": "TextAreaText",
    "description": {
      "en": "",
      "de": "Die Funktion TextAreaText liefert kompletten Text aus Textarea-Objekt zur\u00fcck. Zeilenumbr\u00fcche werden als Chr$(13)+Chr$(10) - Kombination gespeichert. Die neuen Parameter Pos, L\u00e4nge und Einheit sind ab BlitzPlus 1.34 verf\u00fcgbar.   Neuer Text kann mit AddTextAreaText eingef\u00fcgt werden. SetTextAreaColor, SetTextAreaFont oder SetTextAreaTabs \u00e4ndern Farbe, Schriftart oder Tabulatorabstand. "
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird kompletter Text aus Textarea zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "unlocktextarea": {
    "name": "UnlockTextArea",
    "description": {
      "en": "",
      "de": "Die Anweisung UnlockTextArea \u00f6ffnet Textarea-Objekt. Dies sollte nach Textmodifikation geschehen. Zuvor muss ein Textarea-Objekt mit LockTextArea gesperrt worden sein. Diese Methode verhindert visuelle Flimmereffekte und beschleunigt ein Programm. "
    },
    "category": "gui",
    "subCategory": "text-area",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "createlabel": {
    "name": "CreateLabel",
    "description": {
      "en": "",
      "de": "Label ist ein Objekt zum Anzeigen von Text - es ist nicht interaktiv und liefert keine Events zur\u00fcck. Sollte der Text zu lang sein, dann wird der umgebrochen. Mit Chr$(13) kann man einen manuellen Zeilenumbruch erzwingen. "
    },
    "category": "gui",
    "subCategory": "text-field",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t des Label-Objekts wird zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "createtextfield": {
    "name": "CreateTextField",
    "description": {
      "en": "",
      "de": "Die Funktion CreateTextField erstellt ein Textfield-Objekt (Eingabezeile). Gib dazu die Startkoordinate X/Y und Breite/H\u00f6he an. Gruppe ist die Identit\u00e4t von Window, Panel, Tabber oder Canvas.   Text kann mit SetGadgetText gesetzt und mit TextFieldText wieder ausgelesen werden. "
    },
    "category": "gui",
    "subCategory": "text-field",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t des Textfield-Objekts wird zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "textfieldtext": {
    "name": "TextFieldText",
    "description": {
      "en": "",
      "de": "Die Funktion TextFieldText liefert kompletten Text aus Textfield-Objekt zur\u00fcck. Zeilenumbr\u00fcche werden nicht unterst\u00fctzt (\"Steuerzeichen\" k\u00f6nnen aber zur\u00fcckgeliefert werden). Der Text kann mit SetGadgetText ge\u00e4ndert werden. "
    },
    "category": "gui",
    "subCategory": "text-field",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird ein Text aus Textfield zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "createtoolbar": {
    "name": "CreateToolBar",
    "description": {
      "en": "",
      "de": "Die Funktion CreateToolBar erstellt ein Toolbar-Objekt (Werkzeugleiste). Gib dazu die Startkoordinate x/y und breite/h\u00f6he an. Gruppe ist die Identit\u00e4t von Window, Panel, Tabber oder Canvas.       Toolbar ist eine horizontale Leiste mit Symbolen. Die Grafikdatei enth\u00e4lt Symbole. Jedes Symbol muss exakt quadratisch sein und horizontal angeordnet sein. Grafikanzahl wird automatisch ermittelt (L\u00e4nge geteilt durch H\u00f6he). Pixel oben/links gibt die Transparenzfarbe an. Ein Bild, das nur aus der Transparentfarbe besteht erzeugt einen Trenner in der Toolbar.   Nach einem Mausklick auf ein Symbol wird ein Event empfangen. EventData enth\u00e4lt Nummer des Symbols (Start ab 0). "
    },
    "category": "gui",
    "subCategory": "toolbar",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t des Toolbar-Objekts wird zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "disabletoolbaritem": {
    "name": "DisableToolBarItem",
    "description": {
      "en": "",
      "de": "Die Anweisung DisableToolBarItem schaltet ein Symbol in der Toolbar aus. Es erscheint danach grau und reagiert nicht mehr auf Eingaben. Events werden auch nicht mehr zur\u00fcckgeliefert. Mit EnableToolBarItem kann es wieder eingeschaltet werden. "
    },
    "category": "gui",
    "subCategory": "toolbar",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "enabletoolbaritem": {
    "name": "EnableToolBarItem",
    "description": {
      "en": "",
      "de": "Die Anweisung EnableToolBarItem schaltet ein Symbol in der Toolbar ein. Es erscheint danach wieder farbig und reagiert wieder auf Eingaben. Events werden auch wieder zur\u00fcckgeliefert. Mit DisableToolBarItem kann es wieder ausgeschaltet werden. "
    },
    "category": "gui",
    "subCategory": "toolbar",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "settoolbartips": {
    "name": "SetToolBarTips",
    "description": {
      "en": "",
      "de": "Die Anweisung SetToolBarTips \u00e4ndert bzw. setzt Hinweistexte in Toolbar-Objekt. Toolbar ist eine horizontale Leiste mit Symbolen. Wenn die Maus eine kurze Zeit \u00fcber einem Symbol gehalten wird, dann erscheint ein Hinweistext zu dem Symbol. Normalerweise sind mehrere Symbole in einer Toolbar - deshalb werden mehrere Texte durch Komma getrennt angegeben. "
    },
    "category": "gui",
    "subCategory": "toolbar",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "addtreeviewnode": {
    "name": "AddTreeViewNode",
    "description": {
      "en": "",
      "de": "Die Funktion AddTreeViewNode f\u00fcgt einen neuen Zweig in ein Treeview-Objekt ein. Dazu ist nur eine Bezeichnung notwendig.  Zus\u00e4tzlich wird noch die Identit\u00e4t eines Zweiges ben\u00f6tigt, zu dem dieser neue Zweig hinzugef\u00fcgt werden soll. Eine leere Liste hat jedoch noch keine Eintr\u00e4ge - darum kann mit TreeViewRoot ein imagin\u00e4rer Zweig ermittelt werden. Mit InsertTreeViewNode kann ein neuer Zweig an eine bestimmte Position eingef\u00fcgt werden. "
    },
    "category": "gui",
    "subCategory": "tree-view",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t des neuen Zweiges zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "collapsetreeviewnode": {
    "name": "CollapseTreeViewNode",
    "description": {
      "en": "",
      "de": "Die Anweisung CollapseTreeViewNode klappt einen Zweig von Treelist-Objekt ein. Alle Unterzweige werden somit versteckt und der angegebene Zweig bekommt ein [+]-Zeichen. Mit ExpandTreeViewNode kann man umgekehrt Zweige \u00f6ffnen. "
    },
    "category": "gui",
    "subCategory": "tree-view",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "counttreeviewnodes": {
    "name": "CountTreeViewNodes",
    "description": {
      "en": "",
      "de": "Funktion CountTreeViewNodes ermittelt die Anzahl der Eintr\u00e4ge, die in einem Treeview-Zweig enthalten sind. Mit AddTreeViewNode / InsertTreeViewNode k\u00f6nnen weitere Zweige hinzugef\u00fcgt werden. Mit FreeTreeViewNode k\u00f6nnen Zweige entfernt werden. "
    },
    "category": "gui",
    "subCategory": "tree-view",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Anzahl der Zweige" } },
    "code": ""
  },
  "createtreeview": {
    "name": "CreateTreeView",
    "description": {
      "en": "",
      "de": "Die Funktion CreateTreeView erstellt ein Treelist-Objekt. Gib dazu die Startkoordinate X/Y und Breite/H\u00f6he an. Gruppe ist die Identit\u00e4t von Window, Panel, Tabber oder Canvas.   Mit AddTreeViewNode  / InsertTreeViewNode k\u00f6nnen neue Zweige eingef\u00fcgt und mit FreeTreeViewNode gel\u00f6scht werden. "
    },
    "category": "gui",
    "subCategory": "tree-view",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t des Treelist-Objekts wird zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "expandtreeviewnode": {
    "name": "ExpandTreeViewNode",
    "description": {
      "en": "",
      "de": "Die Anweisung ExpandTreeViewNode klappt einen Zweig von Treelist-Objekt auf. Unterzweige werden somit wieder angezeigt und der angegebene Zweig bekommt ein [-]-Zeichen. Mit CollapseTreeViewNode kann man umgekehrt Zweige schlie\u00dfen. "
    },
    "category": "gui",
    "subCategory": "tree-view",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "freetreeviewnode": {
    "name": "FreeTreeViewNode",
    "description": {
      "en": "",
      "de": "Die Anweisung FreeTreeViewNode l\u00f6scht einen Zweig aus einem Treeview-Objekt. Sollten bereits Unterzweige existieren, dann werden diese ebenfalls gel\u00f6scht. "
    },
    "category": "gui",
    "subCategory": "tree-view",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "inserttreeviewnode": {
    "name": "InsertTreeViewNode",
    "description": {
      "en": "",
      "de": "Die Funktion InsertTreeViewNode f\u00fcgt einen Eintrag an beliebige Position in ein Treeview-Objekt ein. Dazu ist eine Einf\u00fcgeposition und eine Bezeichnung notwendig. Zus\u00e4tzlich wird noch die Identit\u00e4t eines Zweiges ben\u00f6tigt, zu dem dieser neue Eintrag hinzugef\u00fcgt werden soll. Eine leere Liste hat jedoch noch keine Eintr\u00e4ge - darum kann mit TreeViewRoot ein imagin\u00e4rer Zweig ermittelt werden. Mit AddTreeViewNode kann dagegen ein neuer Eintrag hinten an die Liste angef\u00fcgt werden. "
    },
    "category": "gui",
    "subCategory": "tree-view",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t des neuen Zweiges zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "modifytreeviewnode": {
    "name": "ModifyTreeViewNode",
    "description": {
      "en": "",
      "de": "Die Anweisung ModifyTreeViewNode \u00e4ndert Bezeichnung eines Treeview-Zweiges. Ein Zweig kann mit AddTreeViewNode oder InsertTreeViewNode eingef\u00fcgt werden. "
    },
    "category": "gui",
    "subCategory": "tree-view",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "selectedtreeviewnode": {
    "name": "SelectedTreeViewNode",
    "description": {
      "en": "",
      "de": "Die Funktion SelectedTreeViewNode ermittelt ausgew\u00e4hlten Zweig eines Treeview-Objekts. Dies ist meistens nach einem Event n\u00fctzlich. Mit SelectTreeViewNode kann ein Zweig manuell ausgew\u00e4hlt werden.   Wenn kein Zweig ausgew\u00e4hlt ist, dann wird 0 zur\u00fcckgeliefert - ansonsten wird die Identit\u00e4t des ausgew\u00e4hlten Zweiges zur\u00fcckgeliefert. "
    },
    "category": "gui",
    "subCategory": "tree-view",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t des ausgew\u00e4hlten Zweiges wird zur\u00fcckgeliefert. Wenn 0 zur\u00fcckgeliefert wird, dann ist kein Eintrag ausgew\u00e4hlt."
      }
    },
    "code": ""
  },
  "selecttreeviewnode": {
    "name": "SelectTreeViewNode",
    "description": {
      "en": "",
      "de": "Die Anweisung SelectTreeViewNode w\u00e4hlt einen Zweig in Treeview-Objekt aus. Gebe einfach die Identit\u00e4t eines Zweiges an. Man kann nur Zweige ausw\u00e4hlen - die Auswahl kann sp\u00e4ter nicht aufgehoben werden. Mit SelectedTreeViewNode kann man ausgew\u00e4hlten Eintrag ermitteln. "
    },
    "category": "gui",
    "subCategory": "tree-view",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "treeviewnodetext": {
    "name": "TreeViewNodeText",
    "description": { "en": "", "de": "Liefert den zum TreeViewNode geh\u00f6rende Bezeichnung zur\u00fcck." },
    "category": "gui",
    "subCategory": "tree-view",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Die Bezeichnung eines Zweiges" } },
    "code": ""
  },
  "treeviewroot": {
    "name": "TreeViewRoot",
    "description": {
      "en": "",
      "de": "Die Funktion TreeViewRoot ermittelt die Identit\u00e4t eines Root-Zweiges aus einem Treeview-Objekt. Wenn eine Liste mit CreateTreeView erstellt wird, dann enth\u00e4lt diese Liste noch keine Eintr\u00e4ge. Darum kann mit TreeViewRoot ein imagin\u00e4rer Zweig ermittelt werden. Dieser Zweig stellt die h\u00f6chste Ebene dar und neue Zweige m\u00fcssen zuerst zu diesem Root-Zweig hinzugef\u00fcgt werden. "
    },
    "category": "gui",
    "subCategory": "tree-view",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t eines Root-Zweiges wird zur\u00fcckgeliefert" }
    },
    "code": ""
  },
  "activatewindow": {
    "name": "ActivateWindow",
    "description": {
      "en": "",
      "de": "Die Anweisung ActivateWindow w\u00e4hlt ein anderes BB-Fenster aus. Dazu wird die Identit\u00e4t dieses Fensters ben\u00f6tigt. Mit ActiveWindow kann dagegen das aktive Fenster ermittelt werden. "
    },
    "category": "gui",
    "subCategory": "window",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "activewindow": {
    "name": "ActiveWindow",
    "description": {
      "en": "",
      "de": "Die Funktion ActiveWindow liefert die Identit\u00e4t eines ausgew\u00e4hlten Fensters. Es werden allerdings nur BB-Fenster ber\u00fccksichtigt. Sollte gerade kein BB-Fenster ausgew\u00e4hlt sein, dann wird die Identit\u00e4t des letzten BB-Fensters zur\u00fcckgeliefert. "
    },
    "category": "gui",
    "subCategory": "window",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t des letzten aktiven Fensters als Integer" }
    },
    "code": ""
  },
  "createwindow": {
    "name": "CreateWindow",
    "description": {
      "en": "",
      "de": "Die Funktion CreateWindow erstellt ein Fenster-Objekt. Gib dazu die Titelbezeichnung, Startkoordinate X/Y und Breite/H\u00f6he an. Optionaler Parameter \"Gruppe\" kann Desktop()-Handle sein - ansonsten benutzt BB automatisch Desktop()-Handle. Style ist dagegen viel Interessanter."
    },
    "category": "gui",
    "subCategory": "window",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Identit\u00e4t eines Fenster-Objektes" } },
    "code": ""
  },
  "maximizewindow": {
    "name": "MaximizeWindow",
    "description": {
      "en": "",
      "de": "Die Anweisung MaximizeWindow maximiert ein BlitzBasic-Fenster. Dadurch wird ein Fenster auf maximale Gr\u00f6\u00dfe gestreckt (entspricht ca. Desktopgr\u00f6\u00dfe). MinimizeWindow minimiert ein Fenster dagegen in die Taskleiste. "
    },
    "category": "gui",
    "subCategory": "window",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "minimizewindow": {
    "name": "MinimizeWindow",
    "description": {
      "en": "",
      "de": "Die Anweisung MinimizeWindow minimiert ein BlitzBasic-Fenster. Dadurch wird ein Fenster in die Taskleiste verkleinert. MaximizeWindow vergr\u00f6\u00dfert ein Fenster dagegen auf die maximale Gr\u00f6\u00dfe."
    },
    "category": "gui",
    "subCategory": "window",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "restorewindow": {
    "name": "RestoreWindow",
    "description": {
      "en": "",
      "de": "Die Anweisung RestoreWindow kann nach minimieren oder maximieren eines Fensters verwendet werden. So wird ein Fenster wiederhergestellt."
    },
    "category": "gui",
    "subCategory": "window",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "setminwindowsize": {
    "name": "SetMinWindowSize",
    "description": {
      "en": "",
      "de": "Die Anweisung SetMinWindowSize setzt minimale Fenstergr\u00f6\u00dfe fest. Maximale Fenstergr\u00f6\u00dfe entspricht weiterhin der Desktopgr\u00f6\u00dfe. Wird Breite und H\u00f6he ausgelassen, dann wird aktuelle Fenstergr\u00f6\u00dfe zur minimalen Gr\u00f6\u00dfe gesetzt. Ein Fenster kann zudem mit SetGadgetShape ver\u00e4ndert werden! "
    },
    "category": "gui",
    "subCategory": "window",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "setstatustext": {
    "name": "SetStatusText",
    "description": {
      "en": "",
      "de": "Die Funktion SetStatusText \u00e4ndert den Text in unterer Statusleiste eines Fensters. Der Text kann sp\u00e4ter nicht wieder ausgelesen werden. "
    },
    "category": "gui",
    "subCategory": "window",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Unbekannt, wahrscheinlich Identit\u00e4t der Statusleiste" }
    },
    "code": ""
  },
  "windowmaximized": {
    "name": "WindowMaximized",
    "description": {
      "en": "",
      "de": "Die Funktion WindowMaximized ermittelt, ob ein Fenster maximiert ist. Ein maximiertes Fenster hat maximale Gr\u00f6\u00dfe (entspricht ca. Desktopgr\u00f6\u00dfe)."
    },
    "category": "gui",
    "subCategory": "window",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0 = Fenster ist nicht Maximiert  1 = Fenster ist Maximiert" }
    },
    "code": ""
  },
  "windowminimized": {
    "name": "WindowMinimized",
    "description": {
      "en": "",
      "de": "Die Funktion WindowMinimized ermittelt, ob ein Fenster minimiert ist. Ein minimiertes Fenster wird in die Taskleiste ausgeblendet."
    },
    "category": "gui",
    "subCategory": "window",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0 = Fenster ist nicht minimiert  1 = Fenster ist minimiert" }
    },
    "code": ""
  },
  "createlistener": {
    "name": "CreateListener",
    "description": {
      "en": "",
      "de": "Der Befehl CreateListener erstellt einen H\u00f6rer und liefert die Identit\u00e4t des H\u00f6rers zur\u00fcck.    Zur Zeit wird nur ein H\u00f6rer unterst\u00fctzt - da man immer nur ein Lautsprechersystem hat!   Mit dem Parameter \"parent\" \u00fcbergibt man die Objektidentit\u00e4t zu dem es hinzugef\u00fcgt werden soll. Falls nun ein Parent-Objekt bewegt wird, dann werden alle hinzugef\u00fcgten Objekte automatisch verschoben. Ein Child-Objekt verschiebt dagegen kein Parent-Objekt mit. Ein H\u00f6rer wird an der Position des Parent-Objekts erstellt (normalerweise eine Kamera).   Der optionale Parameter \"rolloff\" gibt an, ab wann die Lautst\u00e4rke mit Entfernung reduziert werden soll (Standard ist 1).   Der optionale Parameter \"doppler\" ist f\u00fcr den Doppler-Effekt verantwortlich. Doppler-Effekt (benannt nach dem Physiker Chr. Doppler) ist eine Frequenz\u00e4nderung bei \u00e4ndernder Entfernung des Erregers von Schallwellen. M\u00f6chte man den Effekt erh\u00f6hen, dann muss man auch diesen Wert \u00e4ndern (Standard ist 1).   Der optionale Parameter \"distanz\" gibt an, wie die Lautst\u00e4rke bei einer Entfernung reduziert wird. Es ist somit ein Entfernungsma\u00dfstab. Da alle Objekte skalierbar sind, muss man auch die richtige Gr\u00f6\u00dfe f\u00fcr den Soundma\u00dfstab w\u00e4hlen (z.B. die Einheit 1 kann einer Menschengr\u00f6\u00dfe oder der Gr\u00f6\u00dfe eines Hauses entsprechen)."
    },
    "category": "sound",
    "subCategory": "3d",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t des H\u00f6rers zur\u00fcckgeliefert." }
    },
    "code": ""
  },
  "emitsound": {
    "name": "EmitSound",
    "description": {
      "en": "",
      "de": "Der Befehl EmitSound spielt einen 3D-Sound ab und liefert danach die Identit\u00e4t des Soundkanals zur\u00fcck.   Bevor man diesen Befehl benutzen kann, muss man zuerst noch einen Sound mit Load3DSound laden. Load3DSound liefert danach die Identit\u00e4t des Sounds zur\u00fcck. Die Identit\u00e4ten von diesem Sound und von einem Objekt m\u00fcssen danach eingegeben werden.   Aus allen vorhandenen Informationen generiert BlitzBasic einen 3D-Sound, wobei Position und Winkel der Objekte zueinander beachtet wird. Es entsteht ein 3D-Sound, der allerdings nur mit einer speziellen Soundkarte und mit min 4 Boxen realistisch erkling. "
    },
    "category": "sound",
    "subCategory": "3d",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Es wird die Identit\u00e4t des Soundkanals zur\u00fcckgeliefert " }
    },
    "code": ""
  },
  "load3dsound": {
    "name": "Load3DSound",
    "description": {
      "en": "",
      "de": "Diese Anweisung l\u00e4dt einen Sounddatei in den Speicher. Beim Abspielen wird es dann direkt aus dem Speicher abgespielt (und muss nicht jedes Mal geladen werden). Es k\u00f6nnen Wav-Dateien geladen werden. Die Vollversion kann zus\u00e4tzlich Raw- und Mp3-Dateien laden. F\u00fcr MID-Dateien muss man PlayMusic benutzen!   Beim Laden wird eine Nummer zur\u00fcckgeliefert, die f\u00fcr weitere Soundbefehle unbedingt angegeben werden muss. Wird dagegen eine Null zur\u00fcckgeliefert, so konnte dieser Soundeffekt nicht geladen werden (wurde z.B. nicht gefunden).   Benutze nach dem Laden den Befehl EmitSound. Dieser Befehl produziert einen 3D-Soundeffekt. "
    },
    "category": "sound",
    "subCategory": "3d",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t des Sounds. Wird eine Null zur\u00fcckgeliefert, so konnte diese Datei nicht geladen werden"
      }
    },
    "code": ""
  },
  "channelpan": {
    "name": "ChannelPan",
    "description": {
      "en": "",
      "de": "Diese Anweisung setzt den Balance-Wert eines Sounds fest. So kann man dann genau h\u00f6ren woher die Spielfigur kommt - es entsteht ein r\u00e4umliches Gef\u00fchl und man kann sich auf das Objekt vorbereiten. Auch einige Soundeffekte sind somit m\u00f6glich. "
    },
    "category": "sound",
    "subCategory": "channels",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "channelpitch": {
    "name": "ChannelPitch",
    "description": {
      "en": "",
      "de": "Diese Anweisung setzt die Sample-Frequenz eines Sounds fest. So kann man dann beliebig die Tonh\u00f6he \u00e4ndern. Hat ein Sound eine Samplerate von 22050 und man setzt es auf 44100, so wird der Ton h\u00f6her. Wird ein kleinerer Wert angegeben (z.B. 11025), so wird der Ton tiefer. ChannelPitch kann zur beliebigen Zeit eingesetzt werden und funktioniert besser als SoundPitch. "
    },
    "category": "sound",
    "subCategory": "channels",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "channelplaying": {
    "name": "ChannelPlaying",
    "description": {
      "en": "",
      "de": "Diese Funktion ermittelt, ob ein Sound gerade abgespielt wird. Wenn ja, dann wird der Wert 1 zur\u00fcckgeliefert, sonst aber 0. Dies kann man f\u00fcr eine st\u00e4ndige Wiederholung benutzen. "
    },
    "category": "sound",
    "subCategory": "channels",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "0 = Sound wird gerade nicht abgespielt  1 = Sound wird gerade abgespielt" }
    },
    "code": ""
  },
  "channelvolume": {
    "name": "ChannelVolume",
    "description": {
      "en": "",
      "de": "Diese Anweisung \u00e4ndert die Lautst\u00e4rke eines Sounds. Somit kann man z.B. die Entfernung eines Objekts im Spiel simulieren. Ist ein Objekt weit entfernt, so ist es zun\u00e4chst leise und wird dann immer lauter."
    },
    "category": "sound",
    "subCategory": "channels",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "pausechannel": {
    "name": "PauseChannel",
    "description": {
      "en": "",
      "de": "Dieser Befehl h\u00e4lt die Wiedergabe eines Sounds an, die mit PlaySound gestartet wurde. Es funktioniert fast wie StopChannel, nur kann der Sound danach an der selben Stelle mit ResumeChannel fortgesetzt werden."
    },
    "category": "sound",
    "subCategory": "channels",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "resumechannel": {
    "name": "ResumeChannel",
    "description": {
      "en": "",
      "de": "Wurde eine Audio Wiedergabe mit dem Befehl PauseChannel angehalten, so kann sie an genau der Stelle, wo sie angehalten wurde, weiter abgespielt werden. F\u00fcr den Namen muss man die Identit\u00e4t des Soundkanals angeben, die mit PlaySound ermittelt werden kann."
    },
    "category": "sound",
    "subCategory": "channels",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "stopchannel": {
    "name": "StopChannel",
    "description": {
      "en": "",
      "de": "Dieser Befehl stoppt die Wiedergabe eines Sounds (Wav, Midi, Mp3 oder CD-Audio). Beim n\u00e4chsten Abspielen wird dieser Sound vom Anfang abgespielt.   Nat\u00fcrlich sollte vorher PlaySound oder PlayCDTrack ausgef\u00fchrt worden sein. Diese Befehle liefern dann eine Kanalidentit\u00e4t f\u00fcr den Sound. Die Identit\u00e4t wird dann mit StopChannel verwendet."
    },
    "category": "sound",
    "subCategory": "channels",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "playcdtrack": {
    "name": "PlayCDTrack",
    "description": {
      "en": "",
      "de": "Dieser Befehl spielt einen Soundtrack von einer CD ab. Man muss nur die Titelnummer und den Abspielmodus angeben. Es wird eine Kanalidentit\u00e4t zur\u00fcckgeliefert, die f\u00fcr weitere Befehle notwendig ist. "
    },
    "category": "sound",
    "subCategory": "music-samples",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Identit\u00e4t des Kanals (f\u00fcr weitere Befehle)" }
    },
    "code": ""
  },
  "playmusic": {
    "name": "PlayMusic",
    "description": {
      "en": "",
      "de": "Dieser Befehl l\u00e4dt eine Hintergrundmusik und spielt die sofort ab. Nachdem die Musik abgespielt wurde, wird der Speicher freigegeben und die Musik muss erneut mit PlayMusic gestartet werden. Allerdings kann immer nur eine Musik mit diesem Befehl gleichzeitig abgespielt werden.   Mit dem Parameter \"modus\" kann ein Sound automatisch angehalten werden. Erst nach ResumeChannel wird die Musik weiter abgespielt. "
    },
    "category": "sound",
    "subCategory": "music-samples",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "Kanal Identit\u00e4t f\u00fcr Channel-Befehle. " } },
    "code": ""
  },
  "freesound": {
    "name": "FreeSound",
    "description": {
      "en": "",
      "de": "Diese Anweisung entfernt eine vorher mit LoadSound geladene Sounddatei aus dem Speicher. Dadurch wird mehr Speicher frei. Dies sollte m\u00f6glichst angewendet werden, um den Speicher zu schonen - besonders bei \u00e4lteren Rechnern wird es da kritisch."
    },
    "category": "sound",
    "subCategory": "music-samples",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "loadsound": {
    "name": "LoadSound",
    "description": {
      "en": "",
      "de": "Diese Anweisung l\u00e4dt einen Soundeffekt in den Speicher. Beim Abspielen wird es dann direkt aus dem Speicher abgespielt (und muss nicht jedes Mal geladen werden). Es k\u00f6nnen Wav-Dateien geladen werden. Die Vollversion kann zus\u00e4tzlich Raw- und Mp3-Dateien laden. F\u00fcr MID-Dateien muss man PlayMusic benutzen!   Beim Laden wird eine Nummer zur\u00fcckgeliefert, die f\u00fcr weitere Soundbefehle unbedingt angegeben werden muss. Wird dagegen eine Null zur\u00fcckgeliefert, so konnte dieser Soundeffekt nicht geladen werden (wurde z.B. nicht gefunden). "
    },
    "category": "sound",
    "subCategory": "music-samples",
    "params": [],
    "return": {
      "name": "",
      "description": {
        "en": "",
        "de": "Identit\u00e4t des Sounds. Wird eine Null zur\u00fcckgeliefert, so konnte diese Datei nicht geladen werden. "
      }
    },
    "code": ""
  },
  "loopsound": {
    "name": "LoopSound",
    "description": {
      "en": "",
      "de": "Dieser Befehl spielt einen Soundeffekt wie PlaySound ab. LoopSound spielt einen Sound aber ununterbrochen ab. Den Soundeffekt muss man vorher mit LoadSound laden. Dieser Befehl ist besonders f\u00fcr Hintergrundmusik gut geeignet. "
    },
    "category": "sound",
    "subCategory": "music-samples",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "playsound": {
    "name": "PlaySound",
    "description": {
      "en": "",
      "de": "Dieser Befehl spielt einen Soundeffekt ab, der vorher mit LoadSound geladen wurde. Es k\u00f6nnen viele Musikeffekte auf einmal abgespielt werden. Um einen Sound im Loop abzuspielen, kann der Befehl LoopSoundverwendet werden.   Benutze StopChannel, um den Soundeffekt anzuhalten. Siehe auch weitere Channel-Befehle. "
    },
    "category": "sound",
    "subCategory": "music-samples",
    "params": [],
    "return": {
      "name": "",
      "description": { "en": "", "de": "Eine Kanal Identit\u00e4t f\u00fcr Channel-Befehle." }
    },
    "code": ""
  },
  "soundpan": {
    "name": "SoundPan",
    "description": {
      "en": "",
      "de": "Diese Anweisung setzt den Balance-Wert eines Sounds fest. So kann man dann genau h\u00f6ren woher die Spielfigur kommt - es entsteht ein r\u00e4umliches Gef\u00fchl und man kann sich auf das Objekt vorbereiten. Auch einige Soundeffekte sind somit m\u00f6glich. SoundPan muss vor dem Abspielen ausgef\u00fchrt werden. "
    },
    "category": "sound",
    "subCategory": "music-samples",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "soundpitch": {
    "name": "SoundPitch",
    "description": {
      "en": "",
      "de": "Diese Anweisung setzt die Sample-Frequenz eines Sounds fest. So kann man dann beliebig die Tonh\u00f6he \u00e4ndern. Hat ein Sound eine Samplerate von 22050 und man setzt es auf 44100, so wird der Ton h\u00f6her. Wird ein kleinerer Wert angegeben (z.B. 11025), so wird der Ton tiefer. SoundPitch kann nur vor dem Abspielen ausgef\u00fchrt werden. "
    },
    "category": "sound",
    "subCategory": "music-samples",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  },
  "soundvolume": {
    "name": "SoundVolume",
    "description": {
      "en": "",
      "de": "Diese Anweisung \u00e4ndert die Lautst\u00e4rke eines Sounds. Somit kann man z.B. die Entfernung eines Objekts im Spiel simulieren. Ist ein Objekt weit entfernt, so ist es leise und in der N\u00e4he laut. SoundVolume kann nur vor dem Abspielen ausgef\u00fchrt werden. "
    },
    "category": "sound",
    "subCategory": "music-samples",
    "params": [],
    "return": { "name": "", "description": { "en": "", "de": "" } },
    "code": ""
  }
}
